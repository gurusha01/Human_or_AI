The paper presents an effective method for integrating ancestral constraints into the process of identifying optimal Bayesian networks from data. This is achieved by converting a set of ancestral constraints into a (maximal) collection of ordering constraints, which are subsequently utilized in a score-based learning algorithm that leverages the EC tree framework introduced by [Chen et al., 2015]. The proposed approach is evaluated against a straightforward adaptation of the ILP-based Gobnilp algorithm, demonstrating significant performance improvements in the specific context considered. The paper is generally well-written and clearly articulated, though the solution itself is conceptually straightforward. The work addresses a novel problem with a corresponding solution, yielding interesting results that, while not groundbreaking, are certainly relevant to a specialized audience. The problem tackled is both intriguing and new, as there is no readily available "standard solution" for optimal Bayesian network learning with ancestral constraints (novelty=3). However, this lack of standard solutions may partly stem from the somewhat artificial nature of the problem setting: when ancestral relations are involved, it might be more appropriate to employ general causal discovery methods that can also account for unobserved confounders (impact=2).
The proposed approach translates ancestral constraints, which are challenging to incorporate into decomposable-score-based algorithms, into ordering constraints that are more naturally expressed in terms of edge absence and are compatible with decomposable scores. This transformation is performed using a MaxSAT solver, ensuring that all implied ancestral constraints are explicitly represented. However, certain rules outlined in lines 257-261 appear unusual or incomplete. For instance, the premise of acyclicity rule 3 is symmetric ((X < Y) and (Z < W) == (Z < W) and (X < Y)), but the conclusion is not (Y -/-> Z). Similarly, rule 4 seems to exclude ancestral constraints of the form "X and Y do not cause each other." Additionally, in practical scenarios, it is likely that only a small number of ancestral constraints would be provided, which may not substantially reduce the search space. 
The comparison with Gobnilp, augmented with linear constraints, appears impressive; however, Gobnilp is not specifically designed to address this problem. A more meaningful performance benchmark could involve assuming that the ancestral constraints align with the optimal model and comparing the proposed method against a greedy algorithm such as GES, which, given oracle input, should yield the same output. While greedy algorithms generally cannot guarantee optimality, such a comparison would provide a more insightful evaluation of the efficiency achieved by the proposed approach.
Minor comments:
- Line 30: Is there a distinction between a (standard) oracle and an omniscient oracle?
- Line 38: Does "empower the oracle" mean "use in combination with the oracle"?
- Line 90: Clarify here that optimizing refers to minimizing.
- Line 164: Theorem 1 should explicitly state that the set of constraints A satisfied by CPDAG P on the EC tree is only a subset of the constraints A satisfied by the full DAG G; otherwise, the "iff" condition does not hold.
- Lines 225-227: Theorem 3 is unlikely to yield many positive edge implications given sparse or small sets of ancestral constraints.
- Line 267: The rule is not easily recognizable as representing "acyclicity" (see earlier comments).
- Line 310: For graphs of reasonable size, having 10%-25% ancestral constraints would imply substantial prior knowledge of the target graph, which is not typical in practice.