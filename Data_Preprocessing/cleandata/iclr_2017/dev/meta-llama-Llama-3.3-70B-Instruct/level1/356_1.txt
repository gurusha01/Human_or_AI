Summary
The paper proposes a novel technique called Neuro-Symbolic Program Synthesis (NSPS) that learns to generate programs incrementally based on given input-output examples. The approach uses a Recursive-Reverse-Recursive Neural Network (R3NN) to encode and expand partial program trees into full program trees. The paper demonstrates the effectiveness of NSPS in the domain of regular expression-based string transformations, showing that it can construct programs for both known and unseen tasks.
Decision
I decide to Accept this paper, with the main reason being that the approach is well-motivated and supported by experimental results. The paper tackles a specific problem in program induction, namely the limitations of existing neural architectures, and proposes a novel solution that addresses these limitations.
Supporting Arguments
The paper provides a clear and well-structured presentation of the problem, the proposed approach, and the experimental results. The authors motivate the need for a neuro-symbolic approach to program synthesis, highlighting the limitations of existing neural architectures. The R3NN model is well-described, and the experimental results demonstrate its effectiveness in constructing programs for both known and unseen tasks. The paper also provides a thorough comparison with existing approaches, including a simple recurrent model (io2seq), and shows that the R3NN model outperforms it.
Additional Feedback
To further improve the paper, I suggest that the authors provide more details on the training process, including the hyperparameter settings and the computational resources used. Additionally, it would be interesting to see more examples of the constructed programs, including those that are not perfect but still achieve good results. The authors may also want to consider providing more analysis on the limitations of the approach and potential avenues for future research.
Questions for the Authors
1. Can you provide more details on the training process, including the hyperparameter settings and the computational resources used?
2. How do you plan to address the scalability issues in training with programs of larger size?
3. Can you provide more examples of the constructed programs, including those that are not perfect but still achieve good results?
4. How do you think the approach can be extended to other domains, such as numerical computations or data structures?