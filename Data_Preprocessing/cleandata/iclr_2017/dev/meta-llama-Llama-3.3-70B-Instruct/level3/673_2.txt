This paper proposes a novel technique called Neuro-Symbolic Program Synthesis (NSPS) that learns to generate a program incrementally without the need for an explicit search. The approach is based on two novel neural modules: the cross correlation I/O network and the Recursive-Reverse-Recursive Neural Network (R3NN). The R3NN model encodes partial trees in a Domain-Specific Language (DSL) and assigns probabilities to different non-terminals in a partial derivation and corresponding expansions to guide the search for complete derivations.
The paper tackles the specific question of program induction, which is a fundamental problem in Machine Learning and Artificial Intelligence. The approach is well-motivated, as it addresses the limitations of existing neural architectures for program induction, such as being computationally expensive and hard to train, and not being able to learn interpretable programs.
However, I decide to reject this paper due to two key reasons. Firstly, the experimental results are unconvincing due to the lack of comparison with other state-of-the-art methods, such as FLANN, and the lack of speed comparison. Secondly, the paper's motivation to eliminate heuristics used to prune memories is undermined by the authors' own use of heuristics in Section 3.1, which feels like a workaround rather than a solution.
To improve the paper, I suggest that the authors provide more convincing experimental results, including comparisons with other state-of-the-art methods and speed comparisons. Additionally, the authors should address the issue of using heuristics in their approach and provide a more rigorous solution to eliminate the need for heuristics.
I would like to ask the authors to clarify the following points: (1) How does the R3NN model handle the case where the input-output examples are inconsistent or noisy? (2) Can the authors provide more details on the training process, including the hyperparameter settings and the optimization algorithm used? (3) How does the NSPS approach compare to other program synthesis techniques, such as those based on symbolic constraint solving or stochastic search?