This paper introduces an approach to character language modeling (CLMs) that involves the development of a domain-specific language (DSL) to represent CLMs. The experimental results indicate mixed performance compared to neural CLM methods when applied to Linux kernel data and Wikipedia text. However, the proposed DSL models are marginally more compact and faster to query than neural CLMs. Despite these advantages, the approach is challenging to comprehend and appears to target a niche sub-community already familiar with this methodology, lacking sufficient clarity for the broader ICLR audience. A significant concern is the paper's failure to adequately demonstrate that the proposed DSL constitutes a valid probabilistic model and to explain how the model is trained to fit the data, particularly given the absence of a gradient-based training approach. Furthermore, the experiments feel incomplete without presenting samples generated by the model or analyzing the learned representations to understand what the model has captured. Overall, the paper does not provide enough detail for readers to fully grasp or replicate the proposed approach.
The majority of the model section focuses on describing the DSL but does not clarify how probabilities are computed within this framework or how training is conducted. How exactly are probabilities encoded in the model? The DSL description seems to rely solely on discrete decisions, with no clear integration of probabilistic elements.
While training may have been addressed in prior work, this paper needs to include a discussion of the training process to ensure clarity. Section 2.5 falls short in explaining how training is performed or how any notion of optimality is achieved.
Given that this model operates in a hypothesis space distinct from neural models or n-grams, examining samples generated by the model is crucial. While the current experiments demonstrate the model's ability to score utterances, it would be particularly compelling to see whether the model can produce more structured outputs than neural approaches, such as enforcing long-range syntax constraints like balanced brackets.