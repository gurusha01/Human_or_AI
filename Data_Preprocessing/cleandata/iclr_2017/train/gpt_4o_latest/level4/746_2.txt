The central idea of this paper is compelling and holds significant potential: leveraging the powerful "divide and conquer" algorithmic strategy to develop improved programs for tasks like sorting and planar convex hull computation. However, the current execution of this concept is not sufficiently convincing and requires refinement before it can be accepted. In its present form, the paper has the characteristics of a proof-of-concept, making it more suitable for a workshop setting.
My primary concern lies in the limited applicability of the proposed method to other tasks. Typically, program induction demonstrations on well-known tasks using input-output examples aim to establish that a generic learning framework can solve these tasks and, by extension, be useful for other problems due to its generality. In contrast, this work introduces a learning framework that is highly customized to the two specific tasks under consideration. The paper essentially shows that, with sufficient engineering effort (e.g., hardcoding the recurrence structure and designing task-specific supervision rules for lower recurrence levels), one can achieve a partially trainable sorter or convex hull solver.
I also found the paper somewhat difficult to follow. High-level concepts are interwoven with low-level implementation details, making it unclear how the models function, how much of their behavior is learned versus explicitly designed, and how the overall approach works. While the authors' responses to questions clarified some aspects, these clarifications did not make their way into the manuscript. Additionally, the blending of task-specific tricks for the two problems further adds to the confusion. The paper would be significantly more accessible if it explicitly outlined the challenges encountered and the potential solutions, rather than presenting the method as a general-purpose approach.
Highlights:
+ Proof-of-concept implementation of the important "divide and conquer" paradigm with partial trainability  
++ Explicit consideration of the computational complexity of the induced programs  
- The approach lacks generality and cannot be readily applied to new, unknown problems; the networks rely on task-specific engineering  
- The writing style portrays the method as broadly applicable but ultimately relies on low-level details tailored to each task