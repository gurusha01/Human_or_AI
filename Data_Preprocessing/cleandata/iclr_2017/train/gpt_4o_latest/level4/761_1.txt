This paper represents an initial exploration into the task of learning to statically analyze source code. It introduces a basic toy programming language that incorporates loops and branching constructs. The goal is to ascertain whether all variables in a program are defined prior to their usage. The authors experiment with various off-the-shelf sequence classification models and propose a novel model that employs a "differentiable set" to track which variables have been defined at any given point. Results demonstrate that an LSTM model achieves 98% accuracy, while the differentiable set model achieves 99.3% accuracy with sequence-level supervision and 99.7% accuracy with strong token-level supervision. Additionally, the authors train an LSTM language model on correct code and use it to flag low-probability tokens (based on a manually tuned threshold) as potential sources of error.
One area for clarification is the reasoning patterns required to solve these tasks. For instance, does the model need to statically infer whether an `if` condition can ever evaluate to true, or is the task as straightforward as verifying whether a variable appears on the left-hand side before it is encountered on the right-hand side in the program's textual representation?
Strengths:
- The concept of learning a static analyzer is intriguing and holds significant potential for future research.
- Identifying whether variables are defined before use is a foundational step toward more complex static analysis tasks.
- The experimental setup appears reasonable.
- The differentiable set is a simple yet potentially useful modeling tool.
Weaknesses:
- The experimental setup is highly simplified, raising questions about its applicability to real-world challenges in learning a static analyzer.
- The models employed are relatively basic. While the differentiable set introduces some novelty, its utility as a general-purpose construct remains unclear and is demonstrated only marginally on this task.
Overall:
This work is a promising starting point, and I am interested in seeing how this research direction evolves. However, I believe it is premature to accept this paper to ICLR at this stage. I would be excited to see future efforts that extend this system to analyze more complex code properties and address scenarios where a learned static analyzer could provide practical benefits, potentially leveraging machine learning capabilities that traditional static analysis techniques cannot offer.