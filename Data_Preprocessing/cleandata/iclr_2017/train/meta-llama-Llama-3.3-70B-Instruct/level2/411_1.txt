This paper presents a novel learning-based approach for code super-optimization, which is the task of transforming a given program into a more efficient version while preserving its input-output behavior. The authors propose to learn the proposal distribution used in stochastic search-based methods, such as Stoke, to improve the efficiency of the optimization process. The learned proposal distribution is shown to outperform the state-of-the-art approaches on two datasets, including the Hacker's Delight benchmark and a dataset of automatically generated programs.
I decide to accept this paper, with the main reason being that it presents a well-motivated and well-executed approach to improving code super-optimization. The paper clearly outlines the problem, provides a thorough review of related work, and presents a novel solution that is supported by experimental results.
The approach is well-motivated, as it addresses the limitation of current stochastic search-based methods, which do not learn from past behavior or leverage the semantics of the program under consideration. The authors provide a clear explanation of the learning objective, the parameterization of the proposal distribution, and the reinforcement learning framework used to estimate the parameters.
The experimental results are convincing, showing that the learned proposal distribution outperforms the state-of-the-art approaches on both datasets. The results are also supported by a thorough analysis of the optimization process, including the evolution of the loss function and the comparison of the optimized programs.
To further improve the paper, I suggest that the authors provide more details on the implementation of the learning framework, including the choice of hyperparameters and the training procedure. Additionally, it would be interesting to see more examples of optimized programs and a more detailed analysis of the trade-offs between the different approaches.
Some questions I would like the authors to answer include: How do the authors plan to extend this approach to more complex programs and larger datasets? What are the potential applications of this approach beyond code super-optimization? How do the authors plan to address the issue of overfitting, which may occur when learning the proposal distribution from a limited dataset?