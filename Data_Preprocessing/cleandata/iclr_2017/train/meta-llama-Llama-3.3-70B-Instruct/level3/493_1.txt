Summary of the Paper's Contributions
The paper proposes Compositional Kernel Machines (CKMs), a novel instance-based method for object recognition that addresses the limitations of deep architectures and other kernel methods. CKMs utilize a sum-product function to represent a discriminant function, enabling tractable summation over an exponential set of virtual instances. This approach mitigates the curse of dimensionality and improves sample complexity. The authors also propose a method to discriminatively learn weights on individual instance elements, which improves upon uniform weighting.
Decision to Accept
Based on the review, I decide to accept the paper. The key reasons for this choice are: (1) the paper tackles an interesting and relevant problem in the field of computer vision, and (2) the proposed approach is well-motivated and supported by theoretical and empirical results.
Supporting Arguments
The paper provides a clear and concise introduction to the problem of object recognition and the limitations of existing approaches. The authors propose a novel solution, CKMs, which is well-motivated by the need to address the curse of dimensionality and improve sample complexity. The paper provides a thorough theoretical analysis of CKMs, including a definition of the model, a learning procedure, and a discussion of scalability. The experimental results demonstrate the effectiveness of CKMs in several scenarios, including object recognition and composition/symmetry tasks.
Additional Feedback
To further improve the paper, I suggest that the authors provide more discussion on the connection between CKMs and existing research on directly optimizing task losses, as seen in references [2] and [3]. Additionally, citing relevant references such as Gupta et al. (2014) could enrich the paper's quality. The authors may also consider providing more details on the implementation of the sum-product function and the optimization procedure.
Questions for the Authors
To clarify my understanding of the paper, I would like the authors to answer the following questions:
1. Can you provide more insight into the choice of the max-sum semiring (⊕ = max, ⊗ = +) in the experimental architecture?
2. How do the authors plan to address the potential issue of overfitting in CKMs, especially when the number of virtual instances is large?
3. Can you provide more details on the computational resources required to train and test CKMs, and how they compare to those required by deep architectures?