This paper presents a novel approach to learning algorithmic tasks by leveraging the principle of divide and conquer, which is a fundamental concept in discrete mathematics and computer science. The authors propose a recursive split and merge architecture that can be trained using only input-output pairs, without the need for intermediate supervision. The model is designed to optimize both accuracy and computational complexity, making it a promising approach for learning complex tasks.
The specific question tackled by the paper is how to learn algorithmic tasks that can be solved using the divide and conquer principle, without requiring explicit supervision at each step of the process. The approach is well-motivated, as it builds on the idea of dynamic programming and the use of neural networks to solve complex tasks.
The paper supports its claims through a series of experiments on two paradigmatic problems: sorting and finding the planar convex hull. The results show that the proposed approach can achieve impressive generalization performance and robustness to input distribution, even when using weak supervision.
However, I decide to reject this paper for two main reasons. Firstly, the comparison to existing approaches is incomplete, and the authors do not provide a direct comparison using grey image patches for visualization. Secondly, the use of 10 samples to estimate both conditional and marginal distributions is not justified, particularly when compared to the limiting case of infinite samples.
To improve the paper, I suggest that the authors provide a more comprehensive comparison to existing approaches, including a direct comparison using grey image patches for visualization. Additionally, the authors should justify their choice of 10 samples to estimate the distributions, or consider using a larger number of samples to improve the accuracy of their estimates.
Some questions I would like the authors to answer to clarify my understanding of the paper include: How do the authors plan to extend their approach to more complex tasks, such as those that require multiple recursive splits and merges? How do the authors plan to handle tasks that do not have a clear divide and conquer structure? What are the potential applications of this approach to real-world problems, and how do the authors plan to evaluate its performance in these contexts?