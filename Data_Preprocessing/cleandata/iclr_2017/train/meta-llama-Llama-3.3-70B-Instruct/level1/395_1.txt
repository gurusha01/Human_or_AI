Summary
The paper proposes Edward, a Turing-complete probabilistic programming language that defines two compositional representations: random variables and inference. By treating inference as a first-class citizen, Edward enables probabilistic programming to be as flexible and computationally efficient as traditional deep learning. The language provides a simple and elegant way to specify probabilistic models and inference algorithms, making it easy to experiment with different models and algorithms.
Decision
I decide to Accept this paper with two key reasons: (1) the paper tackles a significant problem in probabilistic programming by providing a flexible and efficient language, and (2) the approach is well-motivated and well-placed in the literature, building on existing work in probabilistic programming and deep learning.
Supporting Arguments
The paper provides a clear and concise introduction to the problem of probabilistic programming and the limitations of existing languages. The authors motivate the need for a language that can treat inference as a first-class citizen, allowing for flexible and efficient specification of probabilistic models and inference algorithms. The paper also provides a thorough overview of the related work, highlighting the strengths and weaknesses of existing languages and how Edward addresses these limitations.
The technical contributions of the paper are significant, providing a simple and elegant way to specify probabilistic models and inference algorithms using compositional representations. The authors demonstrate the flexibility and efficiency of Edward through several examples, including variational auto-encoders, Bayesian neural networks, and stochastic variational inference.
Additional Feedback
To further improve the paper, I suggest the authors provide more details on the implementation of Edward, including the API and any optimizations used to achieve the reported speedups. Additionally, the authors could provide more examples of how Edward can be used to solve real-world problems, demonstrating the practical impact of the language.
Questions for the Authors
To clarify my understanding of the paper, I have the following questions for the authors:
1. Can you provide more details on the implementation of Edward, including the API and any optimizations used to achieve the reported speedups?
2. How does Edward handle complex control flow and recursion, and are there any plans to extend the language to support these features?
3. Can you provide more examples of how Edward can be used to solve real-world problems, demonstrating the practical impact of the language?