The paper proposes an end-to-end differentiable programming language for learning programs from input-output examples, drawing inspiration from functional programming languages. The authors investigate the effects of various modeling choices, including memory allocation schemes, immutable data, type systems, and built-in control-flow structures, on the success rate of learning algorithms. They develop a range of models, from a simple assembly-like language to a differentiable functional programming language, and evaluate their performance on several program induction tasks.
I decide to accept this paper, with the primary reason being that it presents a well-motivated and well-executed study on the design of end-to-end differentiable programming languages. The paper provides a clear and thorough analysis of the modeling choices and their impact on the learning performance, and the empirical evaluation demonstrates the effectiveness of the proposed approach.
The paper supports its claims through a comprehensive set of experiments, which show that the proposed modeling recommendations significantly improve the success ratio of learning programs from input-output examples. The authors also provide a detailed discussion of the related work, highlighting the differences between their approach and existing methods in the programming languages community and neural networks learning algorithms.
To further improve the paper, I would like to see more discussion on the potential applications of the proposed approach, particularly in areas where deterministic tools are known to perform poorly, such as the integration of perceptual data, priors, and "soft" side information. Additionally, it would be interesting to see more analysis on the learned programs, such as their interpretability and generalizability to new tasks.
Some questions I would like the authors to answer to clarify my understanding of the paper include: (1) How do the authors plan to extend the proposed approach to support more complex data structures, such as arrays and associative maps? (2) Can the authors provide more insights into the trade-offs between using immutable and mutable registers, and how this choice affects the learning performance? (3) How do the authors envision the proposed approach being used in practice, and what are the potential benefits and challenges of deploying it in real-world applications?