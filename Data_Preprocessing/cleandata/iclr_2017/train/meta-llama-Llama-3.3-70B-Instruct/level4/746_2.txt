The core concept presented in this submission is intriguing and warrants further exploration, as it seeks to leverage the "divide and conquer" algorithm design paradigm to improve program learning for tasks like sorting and planar convex hull computation. However, the current execution falls short of being convincing and requires refinement to be considered for acceptance. In its present form, the paper resembles a proof-of-concept, which might be more suitable for a workshop presentation.
A primary concern is the method's limited applicability to other tasks. Typically, demonstrations of program induction from input-output examples on well-known tasks aim to showcase a generic learning machine's capability to solve these tasks and imply its usefulness for other tasks due to its generality. In contrast, this contribution presents a learning machine that is heavily tailored to the two selected tasks. Essentially, the paper demonstrates that with sufficient engineering effort, such as hardcoding the recurrence structure and designing task-specific supervision rules at lower recurrence levels, it is possible to develop a partially trainable sorter or convex hull solver.
I found the contribution challenging to comprehend due to the intermixing of high-level ideas with low-level implementation details necessary for the model to function. It remains unclear how the models operate, what aspects were learned, and what was designed. Although the authors' responses to questions provided some clarification, this information was not incorporated into the paper. The concurrent description of tricks required for both tasks further adds to the confusion. I believe the paper would be more accessible if it clearly outlined the challenges faced by the authors and potential solutions, rather than promising a general solution.
Key points:
+ The submission provides a proof-of-concept for a partially trainable implementation of the significant "divide and conquer" paradigm.
+ It includes explicit reasoning about the complexity of induced programs.
- The solution lacks generality, making it inapplicable to unknown problems, as the networks rely on task-specific tricks.
- The writing style suggests a general method but frequently resorts to low-level, task-specific details.