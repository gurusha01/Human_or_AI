This paper proposes a novel approach to semantic parsing by employing a neural sequence-to-sequence (seq2seq) model, referred to as the "programmer," which encodes a natural language question and generates a corresponding program. The programmer is augmented with a 'key variable' memory module that stores (a) entities mentioned in the question and (b) intermediate variable values produced during the execution of partial programs. These stored variables are subsequently utilized to incrementally construct the program.  
Additionally, the model incorporates discrete operations (e.g., argmax or "hop to next edges in a KB"), which are executed by a separate component termed the "interpreter/computer." This component not only performs the operations but also maintains intermediate values, as described earlier. Since the programmer is fundamentally a seq2seq model, the interpreter/computer also functions as a syntax and type checker, ensuring that the decoder generates only valid tokens. For instance, the second argument of the "hop" operation must be a KB predicate. The model is trained using weak supervision and directly optimizes the evaluation metric (F-score).  
Given the involvement of discrete operations and non-differentiable reward functions, the training process employs policy gradients (REINFORCE). However, as REINFORCE gradients are known to exhibit high variance, it is standard practice to pretrain the model using a maximum likelihood objective or identify effective action sequences through an auxiliary objective. This paper adopts the latter strategy, employing an iterative maximum likelihood approach to discover high-quality sequences. The results and discussion sections are well-structured, and the model achieves state-of-the-art (SOTA) performance on the WebQuestions dataset compared to other weakly supervised models.  
The paper is well-written, with clear explanations that make it easy to follow.  
This work introduces an innovative and promising research direction, with significant potential for future exploration. I strongly recommend its acceptance and look forward to seeing it presented at the conference.  
Questions for the Authors (in order of importance):  
1. An alternative training strategy could involve bootstrapping the parameters (\(\theta\)) from the iterative ML method instead of adding pseudo-gold programs to the beam (i.e., omitting Line 510). Did you explore this approach, and if so, why do you believe it was unsuccessful?  
2. What baseline model did you use in the REINFORCE training? Did you implement a separate network to predict the value function? This aspect should be elaborated upon in the paper.  
3. Did the generated programs involve multiple hop operations, or were they restricted to single hops? If multiple hops were present, could you provide an example? (I understand if this is constrained by the word limit of your response.)  
4. Could you provide an example where the filter operation is applied?  
5. I am unclear about the rationale for replacing entities in the question with the special ENT symbol. Could you clarify the motivation behind this design choice?  
Minor Comments:  
- Line 161: "describe" → "describing"  
- Line 318: "decoder reads ')'" → "decoder generates ')'"