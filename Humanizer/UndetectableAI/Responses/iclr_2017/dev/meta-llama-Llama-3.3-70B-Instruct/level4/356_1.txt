This paper suggests a way to create string manipulation programs based on input output examples using a type of programs governed by a simple context free grammar rule set. The method relies on a model called the Recursive Reverse Recursive Neural Network (RRNN) to assign probabilities to program structures by analyzing them in both bottom up and top down approaches. The outcomes are tested against real world datasets including the FlashFill test, from Microsoft Excel. 
The topic of program synthesis has caught the attention of many in the learning community due to its importance and potential impact.The method discussed in the research paper that combines parse trees and recursive neural networks seems interesting and full of possibilities.However the models complexity and clarity raise some concerns; certain parts need explanation.The experimental section is a bit lacking overall suggesting that the paper may not be ready, for publication given the state of its results. 
At glance the papers idea seemed promising; however after a thorough review it was discovered that while the method attains a 38 percent accuracy on the FlashFill benchmark with 5 input output examples. this rate decreases to 29 percent when the number of examples is raised to 10. This surprising decline raises questions that suggest a possible issue, in how it was executed or a core restriction of the model. To ensure that program synthesis is successful and efficient, in creating programs effectively handles input output examples are essential as intricate programs typically need several examples to precisely describe how they function. 
The sections deficiencies make it difficult to endorse the paper for publication in its current state; hence a recommendation, for a weak rejection is put forward.The authors are advised to take into account the feedback provided and make revisions before resubmitting since the core concept demonstrates promise. 
Additional remarks and inquiries are as follows; 
When looking at how probability's adjusted in a structured way and the comparison, between starting with detailed elements and going up or down in evaluation of possibilities is considered. Does this mean different ways of finishing a program are listed and their potential outcomes are compared? If this is the case it might make it harder to use the model for programs because of the high expense related to listing all possible completions. 
Exploring how well the model performs with one input output pair, per program and whether this leads to better outcomes. 
Could you provide details on Section 5,.12? Maybe include some examples to help understand how the input output representation works and the assumptions it makes about the number of examples, for tasks?
In the section of your work; 1) Share baseline results from the FlashFill benchmark for comparison. 2) Clearly explain how your method works with programs of lengths. 3) Define what makes a program correct. Whether it needs to match an existing program or perform well on new input output examples. 4) Specify if the accuracy reported is based on the performing program from various samples or, after refining with training information. 
Finally the paper goes over the suggested page limit. It might be a good idea to shorten it to make it easier to read and in line, with the guidelines. 