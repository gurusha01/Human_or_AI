{
  "name" : "c59b469d724f7919b7d35514184fdc0f.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "A Latent Source Model for Online Collaborative Filtering",
    "authors" : [ "Guy Bresler", "George H. Chen", "Devavrat Shah" ],
    "emails" : [ "gbresler@mit.edu", "georgehc@mit.edu", "devavrat@mit.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Recommendation systems have become ubiquitous in our lives, helping us filter the vast expanse of information we encounter into small selections tailored to our personal tastes. Prominent examples include Amazon recommending items to buy, Netflix recommending movies, and LinkedIn recommending jobs. In practice, recommendations are often made via collaborative filtering, which boils down to recommending an item to a user by considering items that other similar or “nearby” users liked. Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].\nMost such systems operate in the “online” setting, where items are constantly recommended to users over time. In many scenarios, it does not make sense to recommend an item that is already consumed. For example, once Alice watches a movie, there’s little point to recommending the same movie to her again, at least not immediately, and one could argue that recommending unwatched movies and already watched movies could be handled as separate cases. Finally, what matters is whether a likable item is recommended to a user rather than an unlikable one. In short, a good online recommendation system should recommend different likable items continually over time.\nDespite the success of collaborative filtering, there has been little theoretical development to justify its effectiveness in the online setting. We address this theoretical gap with our two main contributions in this paper. First, we frame online recommendation as a learning problem that fuses the lines of work on sleeping bandits and clustered bandits. We impose the constraint that once an item is consumed by a user, the system can’t recommend the item to the same user again. Our second main contribution is to analyze a cosine-similarity collaborative filtering algorithm. The key insight is our inclusion of two types of exploration in the algorithm: (1) the standard random exploration for probing the space of items, and (2) a novel “joint” exploration for finding different user types. Under our learning problem setup, after nearly log(km) initial time steps, the proposed algorithm achieves near-optimal performance relative to an oracle algorithm that recommends all likable items first. The nearly logarithmic dependence is a result of using the two different exploration types. We note that the algorithm does not know k.\nOutline. We present our model and learning problem for online recommendation systems in Section 2, provide a collaborative filtering algorithm and its performance guarantee in Section 3, and give the proof idea for the performance guarantee in Section 4. An overview of experimental results is given in Section 5. We discuss our work in the context of prior work in Section 6."
    }, {
      "heading" : "2 A Model and Learning Problem for Online Recommendations",
      "text" : "We consider a system with n users and m items. At each time step, each user is recommended an item that she or he hasn’t consumed yet, upon which, for simplicity, we assume that the user immediately consumes the item and rates it +1 (like) or −1 (dislike).1 The reward earned by the recommendation system up to any time step is the total number of liked items that have been recommended so far across all users. Formally, index time by t ∈ {1, 2, . . . }, and users by u ∈ [n] , {1, . . . , n}. Let πut ∈ [m] , {1, . . . ,m} be the item recommended to user u at time t. Let Y (t)ui ∈ {−1, 0,+1} be the rating provided by user u for item i up to and including time t, where 0 indicates that no rating has been given yet. A reasonable objective is to maximize the expected reward r(T ) up to time T :\nr(T ) , T∑ t=1 n∑ u=1 E[Y (T )uπut ] = m∑ i=1 n∑ u=1 E[Y (T )ui ].\nThe ratings are noisy: the latent item preferences for user u are represented by a length-m vector pu ∈ [0, 1]m, where user u likes item i with probability pui, independently across items. For a user u, we say that item i is likable if pui > 1/2 and unlikable if pui < 1/2. To maximize the expected reward r(T ), clearly likable items for the user should be recommended before unlikable ones.\nIn this paper, we focus on recommending likable items. Thus, instead of maximizing the expected reward r(T ), we aim to maximize the expected number of likable items recommended up to time T :\nr (T ) + , T∑ t=1 n∑ u=1 E[Xut] , (1)\nwhere Xut is the indicator random variable for whether the item recommended to user u at time t is likable, i.e., Xut = +1 if puπut > 1/2 and Xut = 0 otherwise. Maximizing r\n(T ) and r(T )+ differ since the former asks that we prioritize items according to their probability of being liked.\nRecommending likable items for a user in an arbitrary order is sufficient for many real recommendation systems such as for movies and music. For example, we suspect that users wouldn’t actually prefer to listen to music starting from the songs that their user type would like with highest probability to the ones their user type would like with lowest probability; instead, each user would listen to songs that she or he finds likable, ordered such that there is sufficient diversity in the playlist to keep the user experience interesting. We target the modest goal of merely recommending likable items, in any order. Of course, if all likable items have the same probability of being liked and similarly for all unlikable items, then maximizing r(T ) and r(T )+ are equivalent.\n1In practice, a user could ignore the recommendation. To keep our exposition simple, however, we stick to this setting that resembles song recommendation systems like Pandora that per user continually recommends a single item at a time. For example, if a user rates a song as “thumbs down” then we assign a rating of −1 (dislike), and any other action corresponds to +1 (like).\nThe fundamental challenge is that to learn about a user’s preference for an item, we need the user to rate (and thus consume) the item. But then we cannot recommend that item to the user again! Thus, the only way to learn about a user’s preferences is through collaboration, or inferring from other users’ ratings. Broadly, such inference is possible if the users preferences are somehow related.\nIn this paper, we assume a simple structure for shared user preferences. We posit that there are k < n different types of users, where users of the same type have identical item preference vectors. The number of types k represents the heterogeneity in the population. For ease of exposition, in this paper we assume that a user belongs to each user type with probability 1/k. We refer to this model as a latent source model, where each user type corresponds to a latent source of users. We remark that there is evidence suggesting real movie recommendation data to be well modeled by clustering of both users and items [21]. Our model only assumes clustering over users.\nOur problem setup relates to some versions of the multi-armed bandit problem. A fundamental difference between our setup and that of the standard stochastic multi-armed bandit problem [23, 8] is that the latter allows each item to be recommended an infinite number of times. Thus, the solution concept for the stochastic multi-armed bandit problem is to determine the best item (arm) and keep choosing it [3]. This observation applies also to “clustered bandits” [9], which like our work seeks to capture collaboration between users. On the other hand, sleeping bandits [15] allow for the available items at each time step to vary, but the analysis is worst-case in terms of which items are available over time. In our setup, the sequence of items that are available is not adversarial. Our model combines the collaborative aspect of clustered bandits with dynamic item availability from sleeping bandits, where we impose a strict structure on how items become unavailable."
    }, {
      "heading" : "3 A Collaborative Filtering Algorithm and Its Performance Guarantee",
      "text" : "This section presents our algorithm COLLABORATIVE-GREEDY and its accompanying theoretical performance guarantee. The algorithm is syntactically similar to the ε-greedy algorithm for multiarmed bandits [22], which explores items with probability ε and otherwise greedily chooses the best item seen so far based on a plurality vote. In our algorithm, the greedy choice, or exploitation, uses the standard cosine-similarity measure. The exploration, on the other hand, is split into two types, a standard item exploration in which a user is recommended an item that she or he hasn’t consumed yet uniformly at random, and a joint exploration in which all users are asked to provide a rating for the next item in a shared, randomly chosen sequence of items. Let’s fill in the details.\nAlgorithm. At each time step t, either all the users are asked to explore, or an item is recommended to each user by choosing the item with the highest score for that user. The pseudocode is described in Algorithm 1. There are two types of exploration: random exploration, which is for exploring the space of items, and joint exploration, which helps to learn about similarity between users. For a pre-specified rate α ∈ (0, 4/7], we set the probability of random exploration to be εR(n) = 1/nα\nAlgorithm 1: COLLABORATIVE-GREEDY Input: Parameters θ ∈ [0, 1], α ∈ (0, 4/7]. Select a random ordering σ of the items [m]. Define\nεR(n) = 1\nnα , and εJ(t) =\n1\ntα .\nfor time step t = 1, 2, . . . , T do With prob. εR(n): (random exploration) for each user, recommend a random item that the user has not rated. With prob. εJ(t): (joint exploration) for each user, recommend the first item in σ that the user has not rated. With prob. 1− εJ(t)− εR(n): (exploitation) for each user u, recommend an item j that the user has not rated and that maximizes score p̃(t)uj , which depends on threshold θ. end\n(decaying with the number of users), and the probability of joint exploration to be εJ(t) = 1/tα (decaying with time).2\nNext, we define user u’s score p̃(t)ui for item i at time t. Recall that we observe Y (t) ui = {−1, 0,+1} as user u’s rating for item i up to time t, where 0 indicates that no rating has been given yet. We define\np̃ (t) ui ,  ∑ v∈Ñ (t)u 1{Y (t)vi = +1}∑ v∈Ñ (t)u 1{Y (t)vi 6= 0} if ∑ v∈Ñ (t)u 1{Y (t)vi 6= 0} > 0,\n1/2 otherwise,\nwhere the neighborhood of user u is given by\nÑ (t)u , {v ∈ [n] : 〈Ỹ (t)u , Ỹ (t)v 〉 ≥ θ|supp(Ỹ (t)u ) ∩ supp(Ỹ (t)v )|},\nand Ỹ (t)u consists of the revealed ratings of user u restricted to items that have been jointly explored. In other words,\nỸ (t) ui =\n{ Y\n(t) ui if item i is jointly explored by time t,\n0 otherwise.\nThe neighborhoods are defined precisely by cosine similarity with respect to jointed explored items. To see this, for users u and v with revealed ratings Ỹ (t)u and Ỹ (t) v , let Ωuv , supp(Ỹ (t) u )∩supp(Ỹ (t)v ) be the support overlap of Ỹ (t)u and Ỹ (t) v , and let 〈·, ·〉Ωuv be the dot product restricted to entries in Ωuv . Then 〈Ỹ (t)u , Ỹ (t)v 〉 |Ωuv| = 〈Ỹ (t)u , Ỹ (t)v 〉Ωuv√\n〈Ỹ (t)u , Ỹ (t)u 〉Ωuv √ 〈Ỹ (t)v , Ỹ (t)v 〉Ωuv ,\nwhich is the cosine similarity of revealed rating vectors Ỹ (t)u and Ỹ (t) v restricted to the overlap of their supports. Thus, users u and v are neighbors if and only if their cosine similarity is at least θ.\nTheoretical performance guarantee. We now state our main result on the proposed collaborative filtering algorithm’s performance with respect to the objective stated in equation (1). We begin with two reasonable, and seemingly necessary, conditions under which our the results will be established.\nA1 No ∆-ambiguous items. There exists some constant ∆ > 0 such that\n|pui − 1/2| ≥ ∆ for all users u and items i. (Smaller ∆ corresponds to more noise.)\nA2 γ-incoherence. There exist a constant γ ∈ [0, 1) such that if users u and v are of different types, then their item preference vectors pu and pv satisfy\n1 m 〈2pu − 1, 2pv − 1〉 ≤ 4γ∆2,\nwhere 1 is the all ones vector. Note that a different way to write the left-hand side is E[ 1m 〈Y ∗u , Y ∗v 〉], where Y ∗u and Y ∗v are fully-revealed rating vectors of users u and v, and the expectation is over the random ratings of items.\nThe first condition is a low noise condition to ensure that with a finite number of samples, we can correctly classify each item as either likable or unlikable. The incoherence condition asks that the different user types are well-separated so that cosine similarity can tease apart the users of different types over time. We provide some examples after the statement of the main theorem that suggest the incoherence condition to be reasonable, allowing E[〈Y ∗u , Y ∗v 〉] to scale as Θ(m) rather than o(m). We assume that the number of users satisfies n = O(mC) for some constant C > 1. This is without loss of generality since otherwise, we can randomly divide the n users into separate population\n2For ease of presentation, we set the two explorations to have the same decay rate α, but our proof easily extends to encompass different decay rates for the two exploration types. Furthermore, the constant 4/7 ≥ α is not special. It could be different and only affects another constant in our proof.\npools, each of size O(mC) and run the recommendation algorithm independently for each pool to achieve the same overall performance guarantee.\nFinally, we define µ, the minimum proportion of likable items for any user (and thus any user type):\nµ , min u∈[n]\n∑m i=1 1{pui > 1/2}\nm .\nTheorem 1. Let δ ∈ (0, 1) be some pre-specified tolerance. Take as input to COLLABORATIVEGREEDY θ = 2∆2(1 + γ) where γ ∈ [0, 1) is as defined in A2, and α ∈ (0, 4/7]. Under the latent source model and assumptions A1 and A2, if the number of users n = O(mC) satisfies\nn = Ω ( km log 1 δ + (4 δ )1/α) ,\nthen for any Tlearn ≤ T ≤ µm, the expected proportion of likable items recommended by COLLABORATIVE-GREEDY up until time T satisfies\nr (T ) + Tn ≥ ( 1− Tlearn T ) (1− δ),\nwhere\nTlearn = Θ\n(( log km∆δ ∆4(1− γ)2 )1/(1−α) + (4 δ )1/α) .\nTheorem 1 says that there are Tlearn initial time steps for which the algorithm may be giving poor recommendations. Afterward, for Tlearn < T < µm, the algorithm becomes near-optimal, recommending a fraction of likable items 1−δ close to what an optimal oracle algorithm (that recommends all likable items first) would achieve. Then for time horizon T > µm, we can no longer guarantee that there are likable items left to recommend. Indeed, if the user types each have the same fraction of likable items, then even an oracle recommender would use up the µm likable items by this time. Meanwhile, to give a sense of how long the learning period Tlearn is, note that when α = 1/2, we have Tlearn scaling as log2(km), and if we choose α close to 0, then Tlearn becomes nearly log(km). In summary, after Tlearn initial time steps, the simple algorithm proposed is essentially optimal.\nTo gain intuition for incoherence condition A2, we calculate the parameter γ for three examples. Example 1. Consider when there is no noise, i.e., ∆ = 12 . Then users’ ratings are deterministic given their user type. Produce k vectors of probabilities by drawing m independent Bernoulli( 12 ) random variables (0 or 1 with probability 12 each) for each user type. For any item i and pair of users u and v of different types, Y ∗ui · Y ∗vi is a Rademacher random variable (±1 with probability 12 each), and thus the inner product of two user rating vectors is equal to the sum of m Rademacher\nrandom variables. Standard concentration inequalities show that one may take γ = Θ (√\nlogm m\n) to\nsatisfy γ-incoherence with probability 1− 1/poly(m). Example 2. We expand on the previous example by choosing an arbitrary ∆ > 0 and making all latent source probability vectors have entries equal to 12 ±∆ with probability 12 each. As before let user u and v are from different type. Now E[Y ∗ui ·Y ∗vi] = (12 + ∆)2 + ( 12 −∆)2− 2( 14 −∆2) = 4∆2 if pui = pvi and E[Y ∗ui · Y ∗vi] = 2( 14 − ∆2) − ( 12 + ∆)2 − ( 12 − ∆)2 = −4∆2 if pui = 1 − pvi. The value of the inner product E[〈Y ∗u , Y ∗v 〉] is again equal to the sum of m Rademacher random variables, but this time scaled by 4∆2. For similar reasons as before, γ = Θ (√ logm m ) suffices to satisfy γ-incoherence with probability 1− 1/poly(m). Example 3. Continuing with the previous example, now suppose each entry is 12 +∆ with probability µ ∈ (0, 1/2) and 12 − ∆ with probability 1 − µ. Then for two users u and v of different types, pui = pvi with probability µ2 + (1 − µ)2. This implies that E[〈Y ∗u , Y ∗v 〉] = 4m∆2(1 − 2µ)2. Again, using standard concentration, this shows that γ = (1−2µ)2 +Θ (√ logm m ) suffices to satisfy γ-incoherence with probability 1− 1/poly(m)."
    }, {
      "heading" : "4 Proof of Theorem 1",
      "text" : "Recall that Xut is the indicator random variable for whether the item πut recommended to user u at time t is likable, i.e., puπut > 1/2. Given assumption A1, this is equivalent to the event that puπut ≥ 12 + ∆. The expected proportion of likable items is\nr (T ) +\nTn =\n1\nTn T∑ t=1 n∑ u=1 E[Xut] = 1 Tn T∑ t=1 n∑ u=1 P(Xut = 1).\nOur proof focuses on lower-bounding P(Xut = 1). The key idea is to condition on what we call the “good neighborhood” event Egood(u, t):\nEgood(u, t) = {\nat time t, user u has ≥ n 5k neighbors from the same user type (“good neighbors”), and ≤ ∆tn 1−α\n10km neighbors from other user types (“bad neighbors”)\n} .\nThis good neighborhood event will enable us to argue that after an initial learning time, with high probability there are at most ∆ as many ratings from bad neighbors as there are from good neighbors.\nThe proof of Theorem 1 consists of two parts. The first part uses joint exploration to show that after a sufficient amount of time, the good neighborhood event Egood(u, t) holds with high probability. Lemma 1. For user u, after\nt ≥ ( 2 log(10kmnα/∆) ∆4(1− γ)2 )1/(1−α)\ntime steps,\nP(Egood(u, t)) ≥ 1− exp ( − n\n8k\n) − 12 exp ( − ∆\n4(1− γ)2t1−α 20\n) .\nIn the above lower bound, the first exponentially decaying term could be thought of as the penalty for not having enough users in the system from the k user types, and the second decaying term could be thought of as the penalty for not yet clustering the users correctly.\nThe second part of our proof to Theorem 1 shows that, with high probability, the good neighborhoods have, through random exploration, accurately estimated the probability of liking each item. Thus, we correctly classify each item as likable or not with high probability, which leads to a lower bound on P(Xut = 1). Lemma 2. For user u at time t, if the good neighborhood event Egood(u, t) holds and t ≤ µm, then\nP(Xut = 1) ≥ 1− 2m exp ( − ∆ 2tn1−α\n40km ) − 1 tα − 1 nα .\nHere, the first exponentially decaying term could be thought of as the cost of not classifying items correctly as likable or unlikable, and the last two decaying terms together could be thought of as the cost of exploration (we explore with probability εJ(t) + εR(n) = 1/tα + 1/nα).\nWe defer the proofs of Lemmas 1 and 2 to the supplementary material. Combining these lemmas and choosing appropriate constraints on the numbers of users and items, we produce the following lemma. Lemma 3. Let δ ∈ (0, 1) be some pre-specified tolerance. If the number of users n and items m satisfy\nn ≥ max { 8k log 4 δ , (4 δ )1/α} ,\nµm ≥ t ≥ max {( 2 log(10kmnα/∆) ∆4(1− γ)2 )1/(1−α) , ( 20 log(96/δ) ∆4(1− γ)2 )1/(1−α) , (4 δ )1/α} ,\nnt1−α ≥ 40km ∆2\nlog (16m\nδ\n) ,\nthen P(Xut = 1) ≥ 1− δ.\nProof. With the above conditions on n and t satisfied, we combine Lemmas 1 and 2 to obtain\nP(Xut = 1) ≥ 1− exp ( − n\n8k\n) − 12 exp ( − ∆\n4(1− γ)2t1−α 20\n) − 2m exp ( − ∆ 2tn1−α\n40km ) − 1 tα − 1 nα ≥ 1− δ 4 − δ 8 − δ 8 − δ 4 − δ 4 = 1− δ.\nTheorem 1 follows as a corollary to Lemma 3. As previously mentioned, without loss of generality, we take n = O(mC). Then with number of users n satisfying\nO(mC) = n = Ω ( km log 1 δ + (4 δ )1/α) ,\nand for any time step t satisfying µm ≥ t ≥ Θ ((\nlog km∆δ ∆4(1− γ)2 )1/(1−α) + (4 δ )1/α) , Tlearn ,\nwe simultaneously meet all of the conditions of Lemma 3. Note that the upper bound on number of users n appears since without it, Tlearn would depend on n (observe that in Lemma 3, we ask that t be greater than a quantity that depends on n). Provided that the time horizon satisfies T ≤ µm, then\nr (T ) +\nTn ≥ 1 Tn T∑ t=Tlearn n∑ u=1 P(Xut = 1) ≥ 1 Tn T∑ t=Tlearn n∑ u=1 (1− δ) = (T − Tlearn)(1− δ) T ,\nyielding the theorem statement."
    }, {
      "heading" : "5 Experimental Results",
      "text" : "We provide only a summary of our experimental results here, deferring full details to the supplementary material. We simulate an online recommendation system based on movie ratings from the Movielens10m and Netflix datasets, each of which provides a sparsely filled user-by-movie rating matrix with ratings out of 5 stars. Unfortunately, existing collaborative filtering datasets such as the two we consider don’t offer the interactivity of a real online recommendation system, nor do they allow us to reveal the rating for an item that a user didn’t actually rate. For simulating an online system, the former issue can be dealt with by simply revealing entries in the user-by-item rating matrix over time. We address the latter issue by only considering a dense “top users vs. top items” subset of each dataset. In particular, we consider only the “top” users who have rated the most number of items, and the “top” items that have received the most number of ratings. While this dense part of the dataset is unrepresentative of the rest of the dataset, it does allow us to use actual ratings provided by users without synthesizing any ratings. A rigorous validation would require an implementation of an actual interactive online recommendation system, which is beyond the scope of our paper.\nFirst, we validate that our latent source model is reasonable for the dense parts of the two datasets we consider by looking for clustering behavior across users. We find that the dense top users vs. top movies matrices do in fact exhibit clustering behavior of users and also movies, as shown in Figure 1(a). The clustering was found via Bayesian clustered tensor factorization, which was previously shown to model real movie ratings data well [21].\nNext, we demonstrate our algorithm COLLABORATIVE-GREEDY on the two simulated online movie recommendation systems, showing that it outperforms two existing recommendation algorithms Popularity Amongst Friends (PAF) [4] and a method by Deshpande and Montanari (DM) [12]. Following the experimental setup of [4], we quantize a rating of 4 stars or more to be +1 (likable), and a rating less than 4 stars to be −1 (unlikable). While we look at a dense subset of each dataset, there are still missing entries. If a user u hasn’t rated item j in the dataset, then we set the corresponding true rating to 0, meaning that in our simulation, upon recommending item j to user u, we receive 0 reward, but we still mark that user u has consumed item j; thus, item j can no longer be recommended to user u. For both Movielens10m and Netflix datasets, we consider the top n = 200 users and the top m = 500 movies. For Movielens10m, the resulting user-by-rating matrix has 80.7% nonzero entries. For Netflix, the resulting matrix has 86.0% nonzero entries. For an algorithm that\nrecommends item πut to user u at time t, we measure the algorithm’s average cumulative reward up to time T as 1n ∑T t=1 ∑n u=1 Y (T ) uπut , where we average over users. For all four methods, we recommend items until we reach time T = 500, i.e., we make movie recommendations until each user has seen all m = 500 movies. We disallow the matrix completion step for DM to see the users that we actually test on, but we allow it to see the the same items as what is in the simulated online recommendation system in order to compute these items’ feature vectors (using the rest of the users in the dataset). Furthermore, when a rating is revealed, we provide DM both the thresholded rating and the non-thresholded rating, the latter of which DM uses to estimate user feature vectors over time. We discuss choice of algorithm parameters in the supplementary material. In short, parameters θ and α of our algorithm are chosen based on training data, whereas we allow the other algorithms to use whichever parameters give the best results on the test data. Despite giving the two competing algorithms this advantage, COLLABORATIVE-GREEDY outperforms the two, as shown in Figure 1(b). Results on the Netflix dataset are similar."
    }, {
      "heading" : "6 Discussion and Related Work",
      "text" : "This paper proposes a model for online recommendation systems under which we can analyze the performance of recommendation algorithms. We theoretical justify when a cosine-similarity collaborative filtering method works well, with a key insight of using two exploration types.\nThe closest related work is by Biau et al. [7], who study the asymptotic consistency of a cosinesimilarity nearest-neighbor collaborative filtering method. Their goal is to predict the rating of the next unseen item. Barman and Dabeer [4] study the performance of an algorithm called Popularity Amongst Friends, examining its ability to predict binary ratings in an asymptotic informationtheoretic setting. In contrast, we seek to understand the finite-time performance of such systems. Dabeer [11] uses a model similar to ours and studies online collaborative filtering with a moving horizon cost in the limit of small noise using an algorithm that knows the numbers of user types and item types. We do not model different item types, our algorithm is oblivious to the number of user types, and our performance metric is different. Another related work is by Deshpande and Montanari [12], who study online recommendations as a linear bandit problem; their method, however, does not actually use any collaboration beyond a pre-processing step in which offline collaborative filtering (specifically matrix completion) is solved to compute feature vectors for items.\nOur work also relates to the problem of learning mixture distributions (c.f., [10, 18, 5, 2]), where one observes samples from a mixture distribution and the goal is to learn the mixture components and weights. Existing results assume that one has access to the entire high-dimensional sample or that the samples are produced in an exogenous manner (not chosen by the algorithm). Neither assumption holds in our setting, as we only see each user’s revealed ratings thus far and not the user’s entire preference vector, and the recommendation algorithm affects which samples are observed (by choosing which item ratings are revealed for each user). These two aspects make our setting more challenging than the standard setting for learning mixture distributions. However, our goal is more modest. Rather than learning the k item preference vectors, we settle for classifying them as likable or unlikable. Despite this, we suspect having two types of exploration to be useful in general for efficiently learning mixture distributions in the active learning setting.\nAcknowledgements. This work was supported in part by NSF grant CNS-1161964 and by Army Research Office MURI Award W911NF-11-1-0036. GHC was supported by an NDSEG fellowship."
    } ],
    "references" : [ {
      "title" : "A preliminary study on a recommender system for the million songs dataset challenge",
      "author" : [ "Fabio Aiolli" ],
      "venue" : "In Proceedings of the Italian Information Retrieval Workshop,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2013
    }, {
      "title" : "Tensor decompositions for learning latent variable",
      "author" : [ "Anima Anandkumar", "Rong Ge", "Daniel Hsu", "Sham M. Kakade", "Matus Telgarsky" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2012
    }, {
      "title" : "Finite-time analysis of the multiarmed bandit problem",
      "author" : [ "Peter Auer", "Nicolò Cesa-Bianchi", "Paul Fischer" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2002
    }, {
      "title" : "Analysis of a collaborative filter based on popularity amongst neighbors",
      "author" : [ "Kishor Barman", "Onkar Dabeer" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2012
    }, {
      "title" : "Polynomial learning of distribution families",
      "author" : [ "Mikhail Belkin", "Kaushik Sinha" ],
      "venue" : "In Foundations of Computer Science (FOCS),",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2010
    }, {
      "title" : "The million song dataset",
      "author" : [ "Thierry Bertin-Mahieux", "Daniel P.W. Ellis", "Brian Whitman", "Paul Lamere" ],
      "venue" : "In Proceedings of the 12th International Conference on Music Information Retrieval",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2011
    }, {
      "title" : "Statistical analysis of k-nearest neighbor collaborative recommendation",
      "author" : [ "Gérard Biau", "Benoı̂t Cadre", "Laurent Rouvière" ],
      "venue" : "The Annals of Statistics,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2010
    }, {
      "title" : "Regret analysis of stochastic and nonstochastic multi-armed bandit problems",
      "author" : [ "Sébastien Bubeck", "Nicolò Cesa-Bianchi" ],
      "venue" : "Foundations and Trends in Machine Learning,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2012
    }, {
      "title" : "Learning mixtures of product distributions using correlations and independence",
      "author" : [ "Kamalika Chaudhuri", "Satish Rao" ],
      "venue" : "In Conference on Learning Theory,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2008
    }, {
      "title" : "Adaptive collaborating filtering: The low noise regime",
      "author" : [ "Onkar Dabeer" ],
      "venue" : "In IEEE International Symposium on Information Theory, pages 1197–1201,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2013
    }, {
      "title" : "Linear bandits in high dimension and recommendation",
      "author" : [ "Yash Deshpande", "Andrea Montanari" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2013
    }, {
      "title" : "Exploiting compositionality to explore a large space of model structures",
      "author" : [ "Roger B. Grosse", "Ruslan Salakhutdinov", "William T. Freeman", "Joshua B. Tenenbaum" ],
      "venue" : "In Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2012
    }, {
      "title" : "Probability inequalities for sums of bounded random variables",
      "author" : [ "Wassily Hoeffding" ],
      "venue" : "Journal of the American statistical association,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1963
    }, {
      "title" : "Regret bounds for sleeping experts and bandits",
      "author" : [ "Robert Kleinberg", "Alexandru Niculescu-Mizil", "Yogeshwer Sharma" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2010
    }, {
      "title" : "The BellKor solution to the Netflix grand prize. http://www.netflixprize.com/ assets/GrandPrize2009_BPC_BellKor.pdf",
      "author" : [ "Yehuda Koren" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2009
    }, {
      "title" : "Amazon.com recommendations: item-to-item collaborative filtering",
      "author" : [ "Greg Linden", "Brent Smith", "Jeremy York" ],
      "venue" : "IEEE Internet Computing,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2003
    }, {
      "title" : "Settling the polynomial learnability of mixtures of gaussians",
      "author" : [ "Ankur Moitra", "Gregory Valiant" ],
      "venue" : "Proceedings of the 51st Annual IEEE Symposium on Foundations of Computer Science,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2010
    }, {
      "title" : "The pragmatic theory solution to the netflix grand prize",
      "author" : [ "Martin Piotte", "Martin Chabbert" ],
      "venue" : "http:// www.netflixprize.com/assets/GrandPrize2009_BPC_PragmaticTheory.pdf,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2009
    }, {
      "title" : "Grouplens: An open architecture for collaborative filtering of netnews",
      "author" : [ "Paul Resnick", "Neophytos Iacovou", "Mitesh Suchak", "Peter Bergstrom", "John Riedl" ],
      "venue" : "In Proceedings of the 1994 ACM Conference on Computer Supported Cooperative Work, CSCW",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1994
    }, {
      "title" : "Modelling relational data using bayesian clustered tensor factorization",
      "author" : [ "Ilya Sutskever", "Ruslan Salakhutdinov", "Joshua B. Tenenbaum" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2009
    }, {
      "title" : "Reinforcement Learning: An Introduction",
      "author" : [ "Richard S. Sutton", "Andrew G. Barto" ],
      "venue" : null,
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1998
    }, {
      "title" : "On the Likelihood that one Unknown Probability Exceeds",
      "author" : [ "William R. Thompson" ],
      "venue" : "Another in View of the Evidence of Two Samples. Biometrika,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1933
    }, {
      "title" : "The bigchaos solution to the netflix grand prize",
      "author" : [ "Andreas Töscher", "Michael Jahrer" ],
      "venue" : "http://www. netflixprize.com/assets/GrandPrize2009_BPC_BigChaos.pdf,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 18,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 15,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 162,
      "endOffset" : 166
    }, {
      "referenceID" : 14,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 233,
      "endOffset" : 245
    }, {
      "referenceID" : 22,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 233,
      "endOffset" : 245
    }, {
      "referenceID" : 17,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 233,
      "endOffset" : 245
    }, {
      "referenceID" : 0,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 287,
      "endOffset" : 290
    }, {
      "referenceID" : 5,
      "context" : "Collaborative filtering has been used extensively for decades now including in the GroupLens news recommendation system [20], Amazon’s item recommendation system [17], the Netflix Prize winning algorithm by BellKor’s Pragmatic Chaos [16, 24, 19], and a recent song recommendation system [1] that won the Million Song Dataset Challenge [6].",
      "startOffset" : 335,
      "endOffset" : 338
    }, {
      "referenceID" : 19,
      "context" : "We remark that there is evidence suggesting real movie recommendation data to be well modeled by clustering of both users and items [21].",
      "startOffset" : 132,
      "endOffset" : 136
    }, {
      "referenceID" : 21,
      "context" : "A fundamental difference between our setup and that of the standard stochastic multi-armed bandit problem [23, 8] is that the latter allows each item to be recommended an infinite number of times.",
      "startOffset" : 106,
      "endOffset" : 113
    }, {
      "referenceID" : 7,
      "context" : "A fundamental difference between our setup and that of the standard stochastic multi-armed bandit problem [23, 8] is that the latter allows each item to be recommended an infinite number of times.",
      "startOffset" : 106,
      "endOffset" : 113
    }, {
      "referenceID" : 2,
      "context" : "Thus, the solution concept for the stochastic multi-armed bandit problem is to determine the best item (arm) and keep choosing it [3].",
      "startOffset" : 130,
      "endOffset" : 133
    }, {
      "referenceID" : 13,
      "context" : "On the other hand, sleeping bandits [15] allow for the available items at each time step to vary, but the analysis is worst-case in terms of which items are available over time.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 20,
      "context" : "The algorithm is syntactically similar to the ε-greedy algorithm for multiarmed bandits [22], which explores items with probability ε and otherwise greedily chooses the best item seen so far based on a plurality vote.",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 19,
      "context" : "The clustering was found via Bayesian clustered tensor factorization, which was previously shown to model real movie ratings data well [21].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 3,
      "context" : "Next, we demonstrate our algorithm COLLABORATIVE-GREEDY on the two simulated online movie recommendation systems, showing that it outperforms two existing recommendation algorithms Popularity Amongst Friends (PAF) [4] and a method by Deshpande and Montanari (DM) [12].",
      "startOffset" : 214,
      "endOffset" : 217
    }, {
      "referenceID" : 10,
      "context" : "Next, we demonstrate our algorithm COLLABORATIVE-GREEDY on the two simulated online movie recommendation systems, showing that it outperforms two existing recommendation algorithms Popularity Amongst Friends (PAF) [4] and a method by Deshpande and Montanari (DM) [12].",
      "startOffset" : 263,
      "endOffset" : 267
    }, {
      "referenceID" : 3,
      "context" : "Following the experimental setup of [4], we quantize a rating of 4 stars or more to be +1 (likable), and a rating less than 4 stars to be −1 (unlikable).",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 6,
      "context" : "[7], who study the asymptotic consistency of a cosinesimilarity nearest-neighbor collaborative filtering method.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "Barman and Dabeer [4] study the performance of an algorithm called Popularity Amongst Friends, examining its ability to predict binary ratings in an asymptotic informationtheoretic setting.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 9,
      "context" : "Dabeer [11] uses a model similar to ours and studies online collaborative filtering with a moving horizon cost in the limit of small noise using an algorithm that knows the numbers of user types and item types.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 10,
      "context" : "Another related work is by Deshpande and Montanari [12], who study online recommendations as a linear bandit problem; their method, however, does not actually use any collaboration beyond a pre-processing step in which offline collaborative filtering (specifically matrix completion) is solved to compute feature vectors for items.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 8,
      "context" : ", [10, 18, 5, 2]), where one observes samples from a mixture distribution and the goal is to learn the mixture components and weights.",
      "startOffset" : 2,
      "endOffset" : 16
    }, {
      "referenceID" : 16,
      "context" : ", [10, 18, 5, 2]), where one observes samples from a mixture distribution and the goal is to learn the mixture components and weights.",
      "startOffset" : 2,
      "endOffset" : 16
    }, {
      "referenceID" : 4,
      "context" : ", [10, 18, 5, 2]), where one observes samples from a mixture distribution and the goal is to learn the mixture components and weights.",
      "startOffset" : 2,
      "endOffset" : 16
    }, {
      "referenceID" : 1,
      "context" : ", [10, 18, 5, 2]), where one observes samples from a mixture distribution and the goal is to learn the mixture components and weights.",
      "startOffset" : 2,
      "endOffset" : 16
    } ],
    "year" : 2014,
    "abstractText" : "Despite the prevalence of collaborative filtering in recommendation systems, there has been little theoretical development on why and how well it works, especially in the “online” setting, where items are recommended to users over time. We address this theoretical gap by introducing a model for online recommendation systems, cast item recommendation under the model as a learning problem, and analyze the performance of a cosine-similarity collaborative filtering method. In our model, each of n users either likes or dislikes each of m items. We assume there to be k types of users, and all the users of a given type share a common string of probabilities determining the chance of liking each item. At each time step, we recommend an item to each user, where a key distinction from related bandit literature is that once a user consumes an item (e.g., watches a movie), then that item cannot be recommended to the same user again. The goal is to maximize the number of likable items recommended to users over time. Our main result establishes that after nearly log(km) initial learning time steps, a simple collaborative filtering algorithm achieves essentially optimal performance without knowing k. The algorithm has an exploitation step that uses cosine similarity and two types of exploration steps, one to explore the space of items (standard in the literature) and the other to explore similarity between users (novel to this work).",
    "creator" : null
  }
}