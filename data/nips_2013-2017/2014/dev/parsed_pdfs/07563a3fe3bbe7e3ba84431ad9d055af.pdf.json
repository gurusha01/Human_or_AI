{
  "name" : "07563a3fe3bbe7e3ba84431ad9d055af.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Discriminative Unsupervised Feature Learning with Convolutional Neural Networks",
    "authors" : [ "Alexey Dosovitskiy", "Jost Tobias Springenberg", "Martin Riedmiller" ],
    "emails" : [ "dosovits@cs.uni-freiburg.de", "springj@cs.uni-freiburg.de", "riedmiller@cs.uni-freiburg.de", "brox@cs.uni-freiburg.de" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Convolutional neural networks (CNNs) trained via backpropagation were recently shown to perform well on image classification tasks with millions of training images and thousands of categories [1, 2]. The feature representation learned by these networks achieves state-of-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 3], Caltech-256 [2] and the CaltechUCSD birds dataset [3]; scene recognition on the SUN-397 database [3]; detection on the PASCAL VOC dataset [4]. This capability to generalize to new datasets makes supervised CNN training an attractive approach for generic visual feature learning.\nThe downside of supervised training is the need for expensive labeling, as the amount of required labeled samples grows quickly the larger the model gets. The large performance increase achieved by methods based on the work of Krizhevsky et al. [1] was, for example, only possible due to massive efforts on manually annotating millions of images. For this reason, unsupervised learning – although currently underperforming – remains an appealing paradigm, since it can make use of raw unlabeled images and videos. Furthermore, on vision tasks outside classification it is not even certain whether training based on object class labels is advantageous. For example, unsupervised feature learning is known to be beneficial for image restoration [5] and recent results show that it outperforms supervised feature learning also on descriptor matching [6].\nIn this work we combine the power of a discriminative objective with the major advantage of unsupervised feature learning: cheap data acquisition. We introduce a novel training procedure for convolutional neural networks that does not require any labeled data. It rather relies on an automatically generated surrogate task. The task is created by taking the idea of data augmentation – which is commonly used in supervised learning – to the extreme. Starting with trivial surrogate classes consisting of one random image patch each, we augment the data by applying a random set of transformations to each patch. Then we train a CNN to classify these surrogate classes. We refer to this method as exemplar training of convolutional neural networks (Exemplar-CNN).\nThe feature representation learned by Exemplar-CNN is, by construction, discriminative and invariant to typical transformations. We confirm this both theoretically and empirically, showing that this approach matches or outperforms all previous unsupervised feature learning methods on the standard image classification benchmarks STL-10, CIFAR-10, and Caltech-101."
    }, {
      "heading" : "1.1 Related Work",
      "text" : "Our approach is related to a large body of work on unsupervised learning of invariant features and training of convolutional neural networks.\nConvolutional training is commonly used in both supervised and unsupervised methods to utilize the invariance of image statistics to translations (e.g. LeCun et al. [7], Kavukcuoglu et al. [8], Krizhevsky et al. [1]). Similar to our approach the current surge of successful methods employing convolutional neural networks for object recognition often rely on data augmentation to generate additional training samples for their classification objective (e.g. Krizhevsky et al. [1], Zeiler and Fergus [2]). While we share the architecture (a convolutional neural network) with these approaches, our method does not rely on any labeled training data.\nIn unsupervised learning, several studies on learning invariant representations exist. Denoising autoencoders [9], for example, learn features that are robust to noise by trying to reconstruct data from randomly perturbed input samples. Zou et al. [10] learn invariant features from video by enforcing a temporal slowness constraint on the feature representation learned by a linear autoencoder. Sohn and Lee [11] and Hui [12] learn features invariant to local image transformations. In contrast to our discriminative approach, all these methods rely on directly modeling the input distribution and are typically hard to use for jointly training multiple layers of a CNN.\nThe idea of learning features that are invariant to transformations has also been explored for supervised training of neural networks. The research most similar to ours is early work on tangent propagation [13] (and the related double backpropagation [14]) which aims to learn invariance to small predefined transformations in a neural network by directly penalizing the derivative of the output with respect to the magnitude of the transformations. In contrast, our algorithm does not regularize the derivative explicitly. Thus it is less sensitive to the magnitude of the applied transformation.\nThis work is also loosely related to the use of unlabeled data for regularizing supervised algorithms, for example self-training [15] or entropy regularization [16]. In contrast to these semi-supervised methods, Exemplar-CNN training does not require any labeled data.\nFinally, the idea of creating an auxiliary task in order to learn a good data representation was used by Ahmed et al. [17], Collobert et al. [18]."
    }, {
      "heading" : "2 Creating Surrogate Training Data",
      "text" : "The input to the training procedure is a set of unlabeled images, which come from roughly the same distribution as the images to which we later aim to apply the learned features. We randomly sample N ∈ [50, 32000] patches of size 32×32 pixels from different images at varying positions and scales forming the initial training set X = {x1, . . .xN}. We are interested in patches containing objects or parts of objects, hence we sample only from regions containing considerable gradients.\nWe define a family of transformations {Tα|α ∈ A} parameterized by vectors α ∈ A, where A is the set of all possible parameter vectors. Each transformation Tα is a composition of elementary transformations from the following list:\n• translation: vertical or horizontal translation by a distance within 0.2 of the patch size; • scaling: multiplication of the patch scale by a factor between 0.7 and 1.4; • rotation: rotation of the image by an angle up to 20 degrees; • contrast 1: multiply the projection of each patch pixel onto the principal components of the\nset of all pixels by a factor between 0.5 and 2 (factors are independent for each principal component and the same for all pixels within a patch); • contrast 2: raise saturation and value (S and V components of the HSV color representation) of all pixels to a power between 0.25 and 4 (same for all pixels within a patch), multiply these values by a factor between 0.7 and 1.4, add to them a value between −0.1 and 0.1;\n• color: add a value between −0.1 and 0.1 to the hue (H component of the HSV color representation) of all pixels in the patch (the same value is used for all pixels within a patch).\nAll numerical parameters of elementary transformations, when concatenated together, form a single parameter vector α. For each initial patch xi ∈ X we sample K ∈ [1, 300] random parameter vectors {α1i , . . . , αKi } and apply the corresponding transformations Ti = {Tα1i , . . . , TαKi } to the patch xi. This yields the set of its transformed versions Sxi = Tixi = {Txi|T ∈ Ti}. Afterwards we subtract the mean of each pixel over the whole resulting dataset. We do not apply any other preprocessing. Exemplary patches sampled from the STL-10 unlabeled dataset are shown in Fig. 1. Examples of transformed versions of one patch are shown in Fig. 2 ."
    }, {
      "heading" : "3 Learning Algorithm",
      "text" : "Given the sets of transformed image patches, we declare each of these sets to be a class by assigning label i to the class Sxi . We next train a CNN to discriminate between these surrogate classes. Formally, we minimize the following loss function:\nL(X) = ∑ xi∈X ∑ T∈Ti l(i, Txi), (1)\nwhere l(i, Txi) is the loss on the transformed sample Txi with (surrogate) true label i. We use a CNN with a softmax output layer and optimize the multinomial negative log likelihood of the network output, hence in our case\nl(i, Txi) =M(ei, f(Txi)), M(y, f) = −〈y, log f〉 = − ∑ k yk log fk, (2)\nwhere f(·) denotes the function computing the values of the output layer of the CNN given the input data, and ei is the ith standard basis vector. We note that in the limit of an infinite number of transformations per surrogate class, the objective function (1) takes the form\nL̂(X) = ∑ xi∈X Eα[l(i, Tαxi)], (3)\nwhich we shall analyze in the next section.\nIntuitively, the classification problem described above serves to ensure that different input samples can be distinguished. At the same time, it enforces invariance to the specified transformations. In the following sections we provide a foundation for this intuition. We first present a formal analysis of the objective, separating it into a well defined classification problem and a regularizer that enforces invariance (resembling the analysis in Wager et al. [19]). We then discuss the derived properties of this classification problem and compare it to common practices for unsupervised feature learning."
    }, {
      "heading" : "3.1 Formal Analysis",
      "text" : "We denote by α ∈ A the random vector of transformation parameters, by g(x) the vector of activations of the second-to-last layer of the network when presented the input patch x, by W the matrix\nof the weights of the last network layer, by h(x) = Wg(x) the last layer activations before applying the softmax, and by f(x) = softmax (h(x)) the output of the network. By plugging in the definition of the softmax activation function\nsoftmax (z) = exp(z)/‖ exp(z)‖1 (4) the objective function (3) with loss (2) takes the form∑\nxi∈X Eα [ −〈ei, h(Tαxi)〉+ log ‖ exp(h(Tαxi))‖1 ] . (5)\nWith ĝi = Eα [g(Tαxi)] being the average feature representation of transformed versions of the image patch xi we can rewrite Eq. (5) as∑\nxi∈X\n[ −〈ei, Wĝi〉+ log ‖ exp(Wĝi)‖1 ] + ∑ xi∈X [ Eα [log ‖ exp(h(Tαxi))‖1]− log ‖ exp(Wĝi)‖1 ] .\n(6)\nThe first sum is the objective function of a multinomial logistic regression problem with input-target pairs (ĝi, ei). This objective falls back to the transformation-free instance classification problem L(X) = ∑ xi∈X l(i, xi) if g(xi) = Eα[g(Tαx)]. In general, this equality does not hold and thus the first sum enforces correct classification of the average representation Eα[g(Tαxi)] for a given input sample. For a truly invariant representation, however, the equality is achieved. Similarly, if we suppose that Tαx = x for α = 0, that for small values of α the feature representation g(Tαxi) is approximately linear with respect to α and that the random variable α is centered, i.e. Eα [α] = 0, then ĝi = Eα [g(Tαxi)] ≈ Eα [g(xi) + ∇α(g(Tαxi))|α=0 α] = g(xi). The second sum in Eq. (6) can be seen as a regularizer enforcing all h(Tαxi) to be close to their average value, i.e., the feature representation is sought to be approximately invariant to the transformations Tα. To show this we use the convexity of the function log ‖ exp(·)‖1 and Jensen’s inequality, which yields (proof in supplementary material)\nEα [log ‖ exp(h(Tαxi))‖1]− log ‖ exp(Wĝi)‖1 ≥ 0. (7) If the feature representation is perfectly invariant, then h(Tαxi) = Wĝi and inequality (7) turns to equality, meaning that the regularizer reaches its global minimum."
    }, {
      "heading" : "3.2 Conceptual Comparison to Previous Unsupervised Learning Methods",
      "text" : "Suppose we want to unsupervisedly learn a feature representation useful for a recognition task, for example classification. The mapping from input images x to a feature representation g(x) should then satisfy two requirements: (1) there must be at least one feature that is similar for images of the same category y (invariance); (2) there must be at least one feature that is sufficiently different for images of different categories (ability to discriminate).\nMost unsupervised feature learning methods aim to learn such a representation by modeling the input distribution p(x). This is based on the assumption that a good model of p(x) contains information about the category distribution p(y|x). That is, if a representation is learned, from which a given sample can be reconstructed perfectly, then the representation is expected to also encode information about the category of the sample (ability to discriminate). Additionally, the learned representation should be invariant to variations in the samples that are irrelevant for the classification task, i.e., it should adhere to the manifold hypothesis (see e.g. Rifai et al. [20] for a recent discussion). Invariance is classically achieved by regularization of the latent representation, e.g., by enforcing sparsity [8] or robustness to noise [9].\nIn contrast, the discriminative objective in Eq. (1) does not directly model the input distribution p(x) but learns a representation that discriminates between input samples. The representation is not required to reconstruct the input, which is unnecessary in a recognition or matching task. This leaves more degrees of freedom to model the desired variability of a sample. As shown in our analysis (see Eq. (7)), we achieve partial invariance to transformations applied during surrogate data creation by forcing the representation g(Tαxi) of the transformed image patch to be predictive of the surrogate label assigned to the original image patch xi.\nIt should be noted that this approach assumes that the transformations Tα do not change the identity of the image content. If we, for example, use a color transformation we will force the network to be invariant to this change and cannot expect the extracted features to perform well in a task relying on color information (such as differentiating black panthers from pumas)1."
    }, {
      "heading" : "4 Experiments",
      "text" : "To compare our discriminative approach to previous unsupervised feature learning methods, we report classification results on the STL-10 [21], CIFAR-10 [22] and Caltech-101 [23] datasets. Moreover, we assess the influence of the augmentation parameters on the classification performance and study the invariance properties of the network."
    }, {
      "heading" : "4.1 Experimental Setup",
      "text" : "The datasets we test on differ in the number of classes (10 for CIFAR and STL, 101 for Caltech) and the number of samples per class. STL is especially well suited for unsupervised learning as it contains a large set of 100,000 unlabeled samples. In all experiments (except for the dataset transfer experiment in the supplementary material) we extracted surrogate training data from the unlabeled subset of STL-10. When testing on CIFAR-10, we resized the images from 32×32 pixels to 64×64 pixels so that the scale of depicted objects roughly matches the two other datasets.\nWe worked with two network architectures. A “small” network was used to evaluate the influence of different components of the augmentation procedure on classification performance. It consists of two convolutional layers with 64 filters each followed by a fully connected layer with 128 neurons. This last layer is succeeded by a softmax layer, which serves as the network output. A “large” network, consisting of three convolutional layers with 64, 128 and 256 filters respectively followed by a fully connected layer with 512 neurons, was trained to compare our method to the state-of-theart. In both models all convolutional filters are connected to a 5×5 region of their input. 2×2 maxpooling was performed after the first and second convolutional layers. Dropout [24] was applied to the fully connected layers. We trained the networks using an implementation based on Caffe [25]. Details on the training, the hyperparameter settings, and an analysis of the performance depending on the network architecture is provided in the supplementary material. Our code and training data are available at http://lmb.informatik.uni-freiburg.de/resources .\nWe applied the feature representation to images of arbitrary size by convolutionally computing the responses of all the network layers except the top softmax. To each feature map, we applied the pooling method that is commonly used for the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure for STL-10 and CIFAR-10 [26, 10, 27, 12]; 2) 3-layer spatial pyramid, i.e. max-pooling over the whole image as well as within 4 quadrants and within the cells of a 4 × 4 grid, resulting in 1 + 4 + 16 = 21 values per feature map, which is the standard for Caltech-101 [28, 10, 29]. Finally, we trained a linear support vector machine (SVM) on the pooled features.\nOn all datasets we used the standard training and test protocols. On STL-10 the SVM was trained on 10 pre-defined folds of the training data. We report the mean and standard deviation achieved on the fixed test set. For CIFAR-10 we report two results: (1) training the SVM on the whole CIFAR-10 training set (’CIFAR-10’); (2) the average over 10 random selections of 400 training samples per class (’CIFAR-10(400)’). For Caltech-101 we followed the usual protocol of selecting 30 random samples per class for training and not more than 50 samples per class for testing. This was repeated 10 times."
    }, {
      "heading" : "4.2 Classification Results",
      "text" : "In Table 1 we compare Exemplar-CNN to several unsupervised feature learning methods, including the current state-of-the-art on each dataset. We also list the state-of-the-art for supervised learning (which is not directly comparable). Additionally we show the dimensionality of the feature vectors\n1Such cases could be covered either by careful selection of applied transformations or by combining features from multiple networks trained with different sets of transformations and letting the final classifier choose which features to use.\nproduced by each method before final pooling. The small network was trained on 8000 surrogate classes containing 150 samples each and the large one on 16000 classes with 100 samples each.\nThe features extracted from the larger network match or outperform the best prior result on all datasets. This is despite the fact that the dimensionality of the feature vector is smaller than that of most other approaches and that the networks are trained on the STL-10 unlabeled dataset (i.e. they are used in a transfer learning manner when applied to CIFAR-10 and Caltech 101). The increase in performance is especially pronounced when only few labeled samples are available for training the SVM (as is the case for all the datasets except full CIFAR-10). This is in agreement with previous evidence that with increasing feature vector dimensionality and number of labeled samples, training an SVM becomes less dependent on the quality of the features [26, 12]. Remarkably, on STL-10 we achieve an accuracy of 72.8%, which is a large improvement over all previously reported results."
    }, {
      "heading" : "4.3 Detailed Analysis",
      "text" : "We performed additional experiments (using the “small” network) to study the effect of three design choices in Exemplar-CNN training and validate the invariance properties of the learned features. Experiments on sampling ’seed’ patches from different datasets can be found in the supplementary."
    }, {
      "heading" : "4.3.1 Number of Surrogate Classes",
      "text" : "We varied the number N of surrogate classes between 50 and 32000. As a sanity check, we also tried classification with random filters. The results are shown in Fig. 3.\nClearly, the classification accuracy increases with the number of surrogate classes until it reaches an optimum at about 8000 surrogate classes after which it did not change or even decreased. This is to be expected: the larger the number of surrogate classes, the more likely it is to draw very similar or even identical samples, which are hard or impossible to discriminate. Few such cases are not detrimental to the classification performance, but as soon as such collisions dominate the set of surrogate labels, the discriminative loss is no longer reasonable and training the network to the surrogate task no longer succeeds. To check the validity of this explanation we also plot in Fig. 3 the classification error on the validation set (taken from the surrogate data) computed after training the network. It rapidly grows as the number of surrogate classes increases. We also observed that the optimal number of surrogate classes increases with the size of the network (not shown in the figure), but eventually saturates. This demonstrates the main limitation of our approach to randomly sample ’seed’ patches: it does not scale to arbitrarily large amounts of unlabeled data. However, we do not see this as a fundamental restriction and discuss possible solutions in Section 5 ."
    }, {
      "heading" : "4.3.2 Number of Samples per Surrogate Class",
      "text" : "Fig. 4 shows the classification accuracy when the number K of training samples per surrogate class varies between 1 and 300. The performance improves with more samples per surrogate class and\n2 On Caltech-101 one can either measure average accuracy over all samples (average overall accuracy) or calculate the accuracy for each class and then average these values (average per-class accuracy). These differ, as some classes contain fewer than 50 test samples. Most researchers in ML use average overall accuracy.\nsaturates at around 100 samples. This indicates that this amount is sufficient to approximate the formal objective from Eq. (3), hence further increasing the number of samples does not significantly change the optimization problem. On the other hand, if the number of samples is too small, there is insufficient data to learn the desired invariance properties.\n4.3.3 Types of Transformations\nWe varied the transformations used for creating the surrogate data to analyze their influence on the final classification performance. The set of ’seed’ patches was fixed. The result is shown in Fig. 5. The value ’0’ corresponds to applying random compositions of all elementary transformations: scaling, rotation, translation, color variation, and contrast variation. Different columns of the plot show the difference in classification accuracy as we discarded some types of elementary transformations.\nSeveral tendencies can be observed. First, rotation and scaling have only a minor impact on the performance, while translations, color variations and contrast variations are significantly more important. Secondly, the results on STL-\n10 and CIFAR-10 consistently show that spatial invariance and color-contrast invariance are approximately of equal importance for the classification performance. This indicates that variations in color and contrast, though often neglected, may also improve performance in a supervised learning scenario. Thirdly, on Caltech-101 color and contrast transformations are much more important compared to spatial transformations than on the two other datasets. This is not surprising, since Caltech-101 images are often well aligned, and this dataset bias makes spatial invariance less useful."
    }, {
      "heading" : "4.3.4 Invariance Properties of the Learned Representation",
      "text" : "In a final experiment, we analyzed to which extent the representation learned by the network is invariant to the transformations applied during training. We randomly sampled 500 images from the STL-10 test set and applied a range of transformations (translation, rotation, contrast, color) to each image. To avoid empty regions beyond the image boundaries when applying spatial transformations, we cropped the central 64×64 pixel sub-patch from each 96×96 pixel image. We then applied two measures of invariance to these patches.\nFirst, as an explicit measure of invariance, we calculated the normalized Euclidean distance between normalized feature vectors of the original image patch and the transformed one [10] (see the supplementary material for details). The downside of this approach is that the distance between extracted features does not take into account how informative and discriminative they are. We there-\nfore evaluated a second measure – classification performance depending on the magnitude of the transformation applied to the classified patches – which does not come with this problem. To compute the classification accuracy, we trained an SVM on the central 64 × 64 pixel patches from one fold of the STL-10 training set and measured classification performance on all transformed versions of 500 samples from the test set.\nThe results of both experiments are shown in Fig. 6 . Due to space restrictions we show only few representative plots. Overall the experiment empirically confirms that the Exemplar-CNN objective leads to learning invariant features. Features in the third layer and the final pooled feature representation compare favorably to a HOG baseline (Fig. 6 (a)). Furthermore, adding stronger transformations in the surrogate training data leads to more invariant classification with respect to these transformations (Fig. 6 (b)-(d)). However, adding too much contrast variation may deteriorate classification performance (Fig. 6 (d)). One possible reason is that level of contrast can be a useful feature: for example, strong edges in an image are usually more important than weak ones."
    }, {
      "heading" : "5 Discussion",
      "text" : "We have proposed a discriminative objective for unsupervised feature learning by training a CNN without class labels. The core idea is to generate a set of surrogate labels via data augmentation. The features learned by the network yield a large improvement in classification accuracy compared to features obtained with previous unsupervised methods. These results strongly indicate that a discriminative objective is superior to objectives previously used for unsupervised feature learning.\nOne potential shortcoming of the proposed method is that in its current state it does not scale to arbitrarily large datasets. Two probable reasons for this are that (1) as the number of surrogate classes grows larger, many of them become similar, which contradicts the discriminative objective, and (2) the surrogate task we use is relatively simple and does not allow the network to learn invariance to complex variations, such as 3D viewpoint changes or inter-instance variation. We hypothesize that the presented approach could learn more powerful higher-level features, if the surrogate data were more diverse. This could be achieved by using additional weak supervision, for example, by means of video or a small number of labeled samples. Another possible way of obtaining richer surrogate training data and at the same time avoiding similar surrogate classes would be (unsupervised) merging of similar surrogate classes. We see these as interesting directions for future work."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We acknowledge funding by the ERC Starting Grant VideoLearn (279401); the work was also partly supported by the BrainLinks-BrainTools Cluster of Excellence funded by the German Research Foundation (DFG, grant number EXC 1086)."
    } ],
    "references" : [ {
      "title" : "ImageNet classification with deep convolutional neural networks",
      "author" : [ "A. Krizhevsky", "I. Sutskever", "G.E. Hinton" ],
      "venue" : "NIPS, pages 1106–1114",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Visualizing and understanding convolutional networks",
      "author" : [ "M.D. Zeiler", "R. Fergus" ],
      "venue" : "ECCV",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "DeCAF: A deep convolutional activation feature for generic visual recognition",
      "author" : [ "J. Donahue", "Y. Jia", "O. Vinyals", "J. Hoffman", "N. Zhang", "E. Tzeng", "T. Darrell" ],
      "venue" : "ICML",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Rich feature hierarchies for accurate object detection and semantic segmentation",
      "author" : [ "R. Girshick", "J. Donahue", "T. Darrell", "J. Malik" ],
      "venue" : "CVPR",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Simple sparsification improves sparse denoising autoencoders in denoising highly corrupted images",
      "author" : [ "K. Cho" ],
      "venue" : "ICML. JMLR Workshop and Conference Proceedings",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Descriptor matching with convolutional neural networks: a comparison to SIFT",
      "author" : [ "P. Fischer", "A. Dosovitskiy", "T. Brox" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2014
    }, {
      "title" : "Backpropagation applied to handwritten zip code recognition",
      "author" : [ "Y. LeCun", "B. Boser", "J.S. Denker", "D. Henderson", "R.E. Howard", "W. Hubbard", "L.D. Jackel" ],
      "venue" : "Neural Computation, 1(4):541–551",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "Learning convolutional feature hierachies for visual recognition",
      "author" : [ "K. Kavukcuoglu", "P. Sermanet", "Y. Boureau", "K. Gregor", "M. Mathieu", "Y. LeCun" ],
      "venue" : "NIPS",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Extracting and composing robust features with denoising autoencoders",
      "author" : [ "P. Vincent", "H. Larochelle", "Y. Bengio", "P.-A. Manzagol" ],
      "venue" : "ICML, pages 1096–1103",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Deep learning of invariant features via simulated fixations in video",
      "author" : [ "W.Y. Zou", "A.Y. Ng", "S. Zhu", "K. Yu" ],
      "venue" : "NIPS, pages 3212–3220",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Learning invariant representations with local transformations",
      "author" : [ "K. Sohn", "H. Lee" ],
      "venue" : "ICML",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Direct modeling of complex invariances for visual object features",
      "author" : [ "K.Y. Hui" ],
      "venue" : "ICML",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Tangent Prop - A formalism for specifying selected invariances in an adaptive network",
      "author" : [ "P. Simard", "B. Victorri", "Y. LeCun", "J.S. Denker" ],
      "venue" : "NIPS",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "Improving generalization performance using double backpropagation",
      "author" : [ "H. Drucker", "Y. LeCun" ],
      "venue" : "IEEE Transactions on Neural Networks, 3(6):991–997",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "Semi supervised logistic regression",
      "author" : [ "M.-R. Amini", "P. Gallinari" ],
      "venue" : "ECAI, pages 390–394",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Entropy regularization",
      "author" : [ "Y. Grandvalet", "Y. Bengio" ],
      "venue" : "Semi-Supervised Learning, pages 151–168. MIT Press",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Training hierarchical feed-forward visual recognition models using transfer learning from pseudo-tasks",
      "author" : [ "A. Ahmed", "K. Yu", "W. Xu", "Y. Gong", "E. Xing" ],
      "venue" : "ECCV (3), pages 69–82",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Natural language processing (almost) from scratch",
      "author" : [ "R. Collobert", "J. Weston", "L. Bottou", "M. Karlen", "K. Kavukcuoglu", "P. Kuksa" ],
      "venue" : "Journal of Machine Learning Research, 12:2493–2537",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Dropout training as adaptive regularization",
      "author" : [ "S. Wager", "S. Wang", "P. Liang" ],
      "venue" : "In NIPS",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2013
    }, {
      "title" : "The manifold tangent classifier",
      "author" : [ "S. Rifai", "Y.N. Dauphin", "P. Vincent", "Y. Bengio", "X. Muller" ],
      "venue" : "In NIPS",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2011
    }, {
      "title" : "An analysis of single-layer networks in unsupervised feature learning",
      "author" : [ "A. Coates", "H. Lee", "A.Y. Ng" ],
      "venue" : "AISTATS",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Learning multiple layers of features from tiny images",
      "author" : [ "A. Krizhevsky", "G. Hinton" ],
      "venue" : "Master’s thesis, Department of Computer Science, University of Toronto",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Learning generative visual models from few training examples: An incremental bayesian approach tested on 101 object categories",
      "author" : [ "L. Fei-Fei", "R. Fergus", "P. Perona" ],
      "venue" : "CVPR WGMBV",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Improving neural networks by preventing co-adaptation of feature detectors",
      "author" : [ "G.E. Hinton", "N. Srivastava", "A. Krizhevsky", "I. Sutskever", "R.R. Salakhutdinov" ],
      "venue" : null,
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2012
    }, {
      "title" : "Caffe: Convolutional architecture for fast feature embedding",
      "author" : [ "Y. Jia", "E. Shelhamer", "J. Donahue", "S. Karayev", "J. Long", "R. Girshick", "S. Guadarrama", "T. Darrell" ],
      "venue" : "arXiv preprint arXiv:1408.5093",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Selecting receptive fields in deep networks",
      "author" : [ "A. Coates", "A.Y. Ng" ],
      "venue" : "NIPS, pages 2528–2536",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Unsupervised feature learning for RGB-D based object recognition",
      "author" : [ "L. Bo", "X. Ren", "D. Fox" ],
      "venue" : "In ISER,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2012
    }, {
      "title" : "Ask the locals: multi-way local pooling for image recognition",
      "author" : [ "Y. Boureau", "N. Le Roux", "F. Bach", "J. Ponce", "Y. LeCun" ],
      "venue" : "ICCV’11. IEEE",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Multipath sparse coding using hierarchical matching pursuit",
      "author" : [ "L. Bo", "X. Ren", "D. Fox" ],
      "venue" : "CVPR, pages 660–667",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Multi-task bayesian optimization",
      "author" : [ "K. Swersky", "J. Snoek", "R.P. Adams" ],
      "venue" : "NIPS",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Network in network",
      "author" : [ "M. Lin", "Q. Chen", "S. Yan" ],
      "venue" : "ICLR",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Spatial pyramid pooling in deep convolutional networks for visual recognition",
      "author" : [ "K. He", "X. Zhang", "S. Ren", "J. Sun" ],
      "venue" : "ECCV",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Convolutional neural networks (CNNs) trained via backpropagation were recently shown to perform well on image classification tasks with millions of training images and thousands of categories [1, 2].",
      "startOffset" : 192,
      "endOffset" : 198
    }, {
      "referenceID" : 1,
      "context" : "Convolutional neural networks (CNNs) trained via backpropagation were recently shown to perform well on image classification tasks with millions of training images and thousands of categories [1, 2].",
      "startOffset" : 192,
      "endOffset" : 198
    }, {
      "referenceID" : 1,
      "context" : "The feature representation learned by these networks achieves state-of-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 3], Caltech-256 [2] and the CaltechUCSD birds dataset [3]; scene recognition on the SUN-397 database [3]; detection on the PASCAL VOC dataset [4].",
      "startOffset" : 257,
      "endOffset" : 263
    }, {
      "referenceID" : 2,
      "context" : "The feature representation learned by these networks achieves state-of-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 3], Caltech-256 [2] and the CaltechUCSD birds dataset [3]; scene recognition on the SUN-397 database [3]; detection on the PASCAL VOC dataset [4].",
      "startOffset" : 257,
      "endOffset" : 263
    }, {
      "referenceID" : 1,
      "context" : "The feature representation learned by these networks achieves state-of-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 3], Caltech-256 [2] and the CaltechUCSD birds dataset [3]; scene recognition on the SUN-397 database [3]; detection on the PASCAL VOC dataset [4].",
      "startOffset" : 277,
      "endOffset" : 280
    }, {
      "referenceID" : 2,
      "context" : "The feature representation learned by these networks achieves state-of-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 3], Caltech-256 [2] and the CaltechUCSD birds dataset [3]; scene recognition on the SUN-397 database [3]; detection on the PASCAL VOC dataset [4].",
      "startOffset" : 315,
      "endOffset" : 318
    }, {
      "referenceID" : 2,
      "context" : "The feature representation learned by these networks achieves state-of-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 3], Caltech-256 [2] and the CaltechUCSD birds dataset [3]; scene recognition on the SUN-397 database [3]; detection on the PASCAL VOC dataset [4].",
      "startOffset" : 362,
      "endOffset" : 365
    }, {
      "referenceID" : 3,
      "context" : "The feature representation learned by these networks achieves state-of-the-art performance not only on the classification task for which the network was trained, but also on various other visual recognition tasks, for example: classification on Caltech-101 [2, 3], Caltech-256 [2] and the CaltechUCSD birds dataset [3]; scene recognition on the SUN-397 database [3]; detection on the PASCAL VOC dataset [4].",
      "startOffset" : 403,
      "endOffset" : 406
    }, {
      "referenceID" : 0,
      "context" : "[1] was, for example, only possible due to massive efforts on manually annotating millions of images.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "For example, unsupervised feature learning is known to be beneficial for image restoration [5] and recent results show that it outperforms supervised feature learning also on descriptor matching [6].",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 5,
      "context" : "For example, unsupervised feature learning is known to be beneficial for image restoration [5] and recent results show that it outperforms supervised feature learning also on descriptor matching [6].",
      "startOffset" : 195,
      "endOffset" : 198
    }, {
      "referenceID" : 8,
      "context" : "Denoising autoencoders [9], for example, learn features that are robust to noise by trying to reconstruct data from randomly perturbed input samples.",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 9,
      "context" : "[10] learn invariant features from video by enforcing a temporal slowness constraint on the feature representation learned by a linear autoencoder.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "Sohn and Lee [11] and Hui [12] learn features invariant to local image transformations.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 11,
      "context" : "Sohn and Lee [11] and Hui [12] learn features invariant to local image transformations.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 12,
      "context" : "The research most similar to ours is early work on tangent propagation [13] (and the related double backpropagation [14]) which aims to learn invariance to small predefined transformations in a neural network by directly penalizing the derivative of the output with respect to the magnitude of the transformations.",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 13,
      "context" : "The research most similar to ours is early work on tangent propagation [13] (and the related double backpropagation [14]) which aims to learn invariance to small predefined transformations in a neural network by directly penalizing the derivative of the output with respect to the magnitude of the transformations.",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 14,
      "context" : "This work is also loosely related to the use of unlabeled data for regularizing supervised algorithms, for example self-training [15] or entropy regularization [16].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 15,
      "context" : "This work is also loosely related to the use of unlabeled data for regularizing supervised algorithms, for example self-training [15] or entropy regularization [16].",
      "startOffset" : 160,
      "endOffset" : 164
    }, {
      "referenceID" : 0,
      "context" : "For each initial patch xi ∈ X we sample K ∈ [1, 300] random parameter vectors {α(1) i , .",
      "startOffset" : 44,
      "endOffset" : 52
    }, {
      "referenceID" : 7,
      "context" : ", by enforcing sparsity [8] or robustness to noise [9].",
      "startOffset" : 24,
      "endOffset" : 27
    }, {
      "referenceID" : 8,
      "context" : ", by enforcing sparsity [8] or robustness to noise [9].",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 20,
      "context" : "To compare our discriminative approach to previous unsupervised feature learning methods, we report classification results on the STL-10 [21], CIFAR-10 [22] and Caltech-101 [23] datasets.",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 21,
      "context" : "To compare our discriminative approach to previous unsupervised feature learning methods, we report classification results on the STL-10 [21], CIFAR-10 [22] and Caltech-101 [23] datasets.",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 22,
      "context" : "To compare our discriminative approach to previous unsupervised feature learning methods, we report classification results on the STL-10 [21], CIFAR-10 [22] and Caltech-101 [23] datasets.",
      "startOffset" : 173,
      "endOffset" : 177
    }, {
      "referenceID" : 23,
      "context" : "Dropout [24] was applied to the fully connected layers.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 24,
      "context" : "We trained the networks using an implementation based on Caffe [25].",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 25,
      "context" : "To each feature map, we applied the pooling method that is commonly used for the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure for STL-10 and CIFAR-10 [26, 10, 27, 12]; 2) 3-layer spatial pyramid, i.",
      "startOffset" : 223,
      "endOffset" : 239
    }, {
      "referenceID" : 9,
      "context" : "To each feature map, we applied the pooling method that is commonly used for the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure for STL-10 and CIFAR-10 [26, 10, 27, 12]; 2) 3-layer spatial pyramid, i.",
      "startOffset" : 223,
      "endOffset" : 239
    }, {
      "referenceID" : 26,
      "context" : "To each feature map, we applied the pooling method that is commonly used for the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure for STL-10 and CIFAR-10 [26, 10, 27, 12]; 2) 3-layer spatial pyramid, i.",
      "startOffset" : 223,
      "endOffset" : 239
    }, {
      "referenceID" : 11,
      "context" : "To each feature map, we applied the pooling method that is commonly used for the respective dataset: 1) 4-quadrant max-pooling, resulting in 4 values per feature map, which is the standard procedure for STL-10 and CIFAR-10 [26, 10, 27, 12]; 2) 3-layer spatial pyramid, i.",
      "startOffset" : 223,
      "endOffset" : 239
    }, {
      "referenceID" : 27,
      "context" : "max-pooling over the whole image as well as within 4 quadrants and within the cells of a 4 × 4 grid, resulting in 1 + 4 + 16 = 21 values per feature map, which is the standard for Caltech-101 [28, 10, 29].",
      "startOffset" : 192,
      "endOffset" : 204
    }, {
      "referenceID" : 9,
      "context" : "max-pooling over the whole image as well as within 4 quadrants and within the cells of a 4 × 4 grid, resulting in 1 + 4 + 16 = 21 values per feature map, which is the standard for Caltech-101 [28, 10, 29].",
      "startOffset" : 192,
      "endOffset" : 204
    }, {
      "referenceID" : 28,
      "context" : "max-pooling over the whole image as well as within 4 quadrants and within the cells of a 4 × 4 grid, resulting in 1 + 4 + 16 = 21 values per feature map, which is the standard for Caltech-101 [28, 10, 29].",
      "startOffset" : 192,
      "endOffset" : 204
    }, {
      "referenceID" : 25,
      "context" : "Algorithm STL-10 CIFAR-10(400) CIFAR-10 Caltech-101 #features Convolutional K-means Network [26] 60.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 27,
      "context" : "0 — 8000 Multi-way local pooling [28] — — — 77.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 26,
      "context" : "6 556 Hierarchical Matching Pursuit (HMP) [27] 64.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 28,
      "context" : "5± 1 — — — 1000 Multipath HMP [29] — — — 82.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 25,
      "context" : "This is in agreement with previous evidence that with increasing feature vector dimensionality and number of labeled samples, training an SVM becomes less dependent on the quality of the features [26, 12].",
      "startOffset" : 196,
      "endOffset" : 204
    }, {
      "referenceID" : 11,
      "context" : "This is in agreement with previous evidence that with increasing feature vector dimensionality and number of labeled samples, training an SVM becomes less dependent on the quality of the features [26, 12].",
      "startOffset" : 196,
      "endOffset" : 204
    }, {
      "referenceID" : 9,
      "context" : "First, as an explicit measure of invariance, we calculated the normalized Euclidean distance between normalized feature vectors of the original image patch and the transformed one [10] (see the supplementary material for details).",
      "startOffset" : 180,
      "endOffset" : 184
    } ],
    "year" : 2014,
    "abstractText" : "Current methods for training convolutional neural networks depend on large amounts of labeled samples for supervised training. In this paper we present an approach for training a convolutional neural network using only unlabeled data. We train the network to discriminate between a set of surrogate classes. Each surrogate class is formed by applying a variety of transformations to a randomly sampled ’seed’ image patch. We find that this simple feature learning algorithm is surprisingly successful when applied to visual object recognition. The feature representation learned by our algorithm achieves classification results matching or outperforming the current state-of-the-art for unsupervised learning on several popular datasets (STL-10, CIFAR-10, Caltech-101).",
    "creator" : null
  }
}