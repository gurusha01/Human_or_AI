{
  "name" : "33e8075e9970de0cfea955afd4644bb2.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Wavelets on Graphs via Deep Learning",
    "authors" : [ "Raif M. Rustamov" ],
    "emails" : [ "rustamov@stanford.edu", "guibas@stanford.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Processing of signals on graphs is emerging as a fundamental problem in an increasing number of applications [22]. Indeed, in addition to providing a direct representation of a variety of networks arising in practice, graphs serve as an overarching abstraction for many other types of data. Highdimensional data clouds such as a collection of handwritten digit images, volumetric and connectivity data in medical imaging, laser scanner acquired point clouds and triangle meshes in computer graphics – all can be abstracted using weighted graphs. Given this generality, it is desirable to extend the flexibility of classical tools such as wavelets to the processing of signals defined on weighted graphs.\nA number of approaches for constructing wavelets on graphs have been proposed, including, but not limited to the CKWT [7], Haar-like wavelets [24, 10], diffusion wavelets [6], spectral wavelets [12], tree-based wavelets [19], average-interpolating wavelets [21], and separable filterbank wavelets [17]. However, all of these constructions are guided solely by the structure of the underlying graph, and do not take directly into consideration the particular class of signals to be processed. While this information can be incorporated indirectly when building the underlying graph (e.g. [19, 17]), such an approach does not fully exploit the degrees of freedom inherent in wavelet design. In contrast, a variety of signal class specific and adaptive wavelet constructions exist on images and multidimensional regular domains, see [9] and references therein. Bridging this gap is challenging because obtaining graph wavelets, let alone adaptive ones, is complicated by the irregularity of the underlying space. In addition, theoretical guidance for such adaptive constructions is lacking as it remains largely unknown how the properties of the graph wavelet transforms, such as sparsity, relate to the structural properties of graph signals and their underlying graphs [22].\nThe goal of our work is to provide a machine learning framework for constructing wavelets on weighted graphs that can sparsely represent a given class of signals. Our construction uses the lifting\nscheme as applied to the Haar wavelets, and is based on the observation that the update and predict steps of the lifting scheme are similar to the encode and decode steps of an auto-encoder. From this point of view, the recurrent nature of the lifting scheme gives rise to a structure resembling a deep auto-encoder network.\nParticular properties that the resulting wavelets must satisfy, such as sparse representation of signals, local support, and vanishing moments, determine the training objective and the structure of the involved neural networks. The goal of achieving sparsity translates into minimizing a sparsity surrogate of the auto-encoder reconstruction error. Vanishing moments and locality can be satisfied by tying the weights of the auto-encoder in a special way and by restricting receptive fields of neurons in a manner that incorporates the structure of the underlying graph. The training is unsupervised, and is conducted similarly to the greedy (pre-)training [13, 14, 2, 20] of a stack of auto-encoders.\nThe advantages of our construction are three-fold. First, when no training functions are specified by the application, we can impose a smoothness prior and obtain a novel general-purpose wavelet construction on graphs. Second, our wavelets are adaptive to a class of signals and after training we obtain a linear transform; this is in contrast to adapting to the input signal (e.g. by modifying the underlying graph [19, 17]) which effectively renders those transforms non-linear. Third, our construction provides efficient and exact analysis and synthesis operators and results in a critically sampled basis that respects the multiscale structure imposed on the underlying graph.\nThe paper is organized as follows: in §2 we briefly overview the lifting scheme. Next, in §3 we provide a general overview of our approach, and fill in the details in §4. Finally, we present a number of experiments in §5."
    }, {
      "heading" : "2 Lifting scheme",
      "text" : "The goal of wavelet design is to obtain a multiresolution [16] ofL2(G) – the set of all functions/signals on graph G. Namely, a nested sequence of approximation spaces from coarse to fine of the form V1 ⊂ V2 ⊂ ... ⊂ V`max = L2(G) is constructed. Projecting a signal in the spaces V` provides better and better approximations with increasing level `. Associated wavelet/detail spaces W` satisfying V`+1 = V` ⊕W` are also obtained. Scaling functions {φ`,k} provide a basis for approximation space V`, and similarly wavelet functions {ψ`,k} for W`. As a result, for any signal f ∈ L2(G) on graph and any level `0 < `max, we have the wavelet decomposition\nf = ∑ k a`0,kφ`0,k + `max−1∑ `=`0 ∑ k d`,kψ`,k. (1)\nThe coefficients a`,k and d`,k appearing in this decomposition are called approximation (also, scaling) and detail (also, wavelet) coefficients respectively. For simplicity, we use a` and d` to denote the vectors of all approximation and detail coefficients at level `.\nOur construction of wavelets is based on the lifting scheme [23]. Starting with a given wavelet transform, which in our case is the Haar transform (HT ), one can obtain lifted wavelets by applying the process illustrated in Figure 1(left) starting with ` = `max − 1, a`max = f and iterating down until ` = 1. At every level the lifted coefficients a` and d` are computed by augmenting the Haar\ncoefficients ā` and d̄` (of the lifted approximation coefficients a`+1) as follows\na` ← ā` + Ud̄` d` ← d̄` − Pa`\nwhere update (U ) and predict (P ) are linear operators (matrices). Note that in adaptive wavelet designs the update and predict operators will vary from level to level, but for simplicity of notation we do not indicate this explicitly.\nThis process is always invertible – the backward transform is depicted, with IHT being the inverse Haar transform, in Figure 1(right) and allows obtaining perfect reconstruction of the original signal. While the wavelets and scaling functions are not explicitly computed during either forward or backward transform, it is possible to recover them using the expansion of Eq. (1). For example, to obtain a specific scaling function φ`,k, one simply sets all of approximation and detail coefficients to zero, except for a`,k = 1 and runs the backward transform."
    }, {
      "heading" : "3 Approach",
      "text" : "For a given class of signals, our objective is to design wavelets that yield approximately sparse expansions in Eq.(1) – i.e. the detail coefficients are mostly small with a tiny fraction of large coefficients. Therefore, we learn the update and predict operators that minimize some sparsity surrogate of the detail (wavelet) coefficients of given training functions {fn}nmaxn=1 . For a fixed multiresolution level `, and a training function fn, let ān` and d̄ n ` be the Haar approximation and detail coefficient vectors of fn received at level ` (i.e. applied to an`+1as in Figure 1(left)). Consider the minimization problem\n{U,P} = arg min U,P ∑ n s(dn` ) = arg min U,P ∑ n s(d̄n` − P (ān` + Ud̄n` )), (2)\nwhere s is some sparse penalty function. This can be seen as optimizing a linear auto-encoder with encoding step given by ān` + Ud̄ n ` , and decoding step given by multiplication with the matrix P . Since we would like to obtain a linear wavelet transform, the linearity of the encode and decode steps is of crucial importance. In addition to linearity and the special form of bias terms, our auto-encoders differ from commonly used ones in that we enforce sparsity on the reconstruction error, rather than the hidden representation – in our setting, the reconstruction errors correspond to detail coefficients.\nThe optimization problem of Eq. 2 suffers from a trivial solution: by choosing update matrix to have large norm (e.g. a large coefficient times identity matrix), and predict operator equal to the inverse of update, one can practically cancel the contribution of the bias terms, obtaining almost perfect reconstruction. Trivial solutions are a well-known problem in the context of auto-encoders, and an effective solution is to tie the weights of the encode and decode steps by setting U = P t. This also has the benefit of decreasing the number of parameters to learn. We also follow a similar strategy and tie the weights of update and predict steps, but the specific form of tying is dictated by the wavelet properties and will be discussed in §4.2. The training is conducted in a manner similar to the greedy pre-training of a stack of auto-encoders [13, 14, 2, 20]. Namely, we first train the the update and predict operators at the finest level: here the input to the lifting step are the original training functions – this corresponds to ` = `max − 1 and ∀n, an`+1 = fn in Figure 1(left). After training of this finest level is completed, we obtain new approximation coefficients an` which are passed to the next level as the training functions, and this process is repeated until one reaches the coarsest level.\nThe use of tied auto-encoders is motivated by their success in deep learning revealing their capability to learn useful features from the data under a variety of circumstances. The choice of the lifting scheme as the backbone of our construction is motivated by several observations. First, every invertible 1D discrete wavelet transform can be factored into lifting steps [8], which makes lifting a universal tool for constructing multiresolutions. Second, lifting scheme is always invertible, and provides exact reconstruction of signals. Third, it affords fast (linear time) and memory efficient (in-place) implementation after the update and predict operators are specified. We choose to apply lifting to Haar wavelets specifically because Haar wavelets are easy to define on any underlying space provided that it can be hierarchically partitioned [24, 10]. Our use of update-first scheme mirrors its\ncommon use for adaptive wavelet constructions in image processing literature, which is motivated by its stability; see [4] for a thorough discussion."
    }, {
      "heading" : "4 Construction details",
      "text" : "We consider a simple connected weighted graph G with vertex set V of size N . A signal on the graph is represented by a vector f ∈ RN . Let W be the N × N edge weight matrix (since there are no self-loops, Wii = 0), and let S be the diagonal N × N matrix of vertex weights; if no vertex weights are given, we set Sii = ∑ j Wij . For a graph signal f , we define its integral over the graph as a weighted sum, ´ G f = ∑ i Siif(i). We define the volume of\na subset R of vertices of the graph by V ol(R) = ´ R\n1 =∑ i∈R Sii.\nWe assume that a hierarchical partitioning (not necessarily dyadic) of the underlying graph into connected regions is provided. We denote the regions at level ` = 1, ..., `max by R`,k; see the inset where the three coarsest partition levels of a dataset are shown. For each region at levels ` = 1, ..., `max − 1, we designate arbitrarily all except one of its children (i.e. regions at level `+1) as active regions. As will become clear, our wavelet construction yields one approximation coefficient a`,k for each region R`,k, and one detail coefficient d`,k for each active region R`+1,k at level `+ 1. Note that if the partition is not dyadic, at a given level ` the number of scaling coefficients (equal to number of regions at level `) will not be the same as the number of detail coefficients (equal to number of active regions at level `+ 1). We collect all of the coefficients at the same level into vectors denoted by a` and d`; to keep our notation lightweight, we refrain from using boldface for vectors."
    }, {
      "heading" : "4.1 Haar wavelets",
      "text" : "Usually, the (unnormalized) Haar approximation and detail coefficients of a signal f are computed as follows. The coefficient ā`,k corresponding to region R`,k equals to the average of the function f on that region: ā`,k = V ol(R`,k)−1 ´ R`,k\nf . The detail coefficient d̄`,k corresponding to an active region R`+1,k is the difference between averages at the regionR`+1,k and its parent regionR`,par(k), namely d̄`,k = ā`+1,k − ā`,par(k). For perfect reconstruction there is no need to keep detail coefficients for inactive regions, because these can be recovered from the scaling coefficient of the parent region and the detail coefficients of the sibling regions.\nIn our setting, Haar wavelets are a part of the lifting scheme, and so the coefficient vectors ā` and d̄` at level ` need to be computed from the augmented coefficient vector a`+1 at level `+ 1 (c.f. Figure 1(left)). This is equivalent to computing a function’s average at a given region from its averages at the children regions. As a result, we obtain the following formula:\nā`,k = V ol(R`,k) −1 ∑ j,par(j)=k a`+1,jV ol(R`+1,j),\nwhere the summation is over all the children regions of R`,k. As before, the detail coefficient corresponding to an active region R`+1,k is given by d̄`,k = a`+1,k − ā`,par(k). The resulting Haar wavelets are not normalized; when sorting wavelet/scaling coefficients we will multiply coefficients coming from level ` by 2−`/2."
    }, {
      "heading" : "4.2 Auto-encoder setup",
      "text" : "The choice of the update and predict operators and their tying scheme is guided by a number of properties that wavelets need to satisfy. We discuss these requirements under separate headings.\nVanishing moments: The wavelets should have vanishing dual and primal moments – two independent conditions due to biorthogonality of our wavelets. In terms of the approximation and detail\ncoefficients these can be expressed as follows: a) all of the detail coefficients of a constant function should be zero and b) the integral of the approximation at any level of multiresolution should be the same as the integral of the original function.\nSince these conditions are already satisfied by the Haar wavelets, we need to ensure that the update and predict operators preserve them. To be more precise, if a`+1 is a constant vector, then we have for Haar coefficients that ā` = c~1 and d̄` = ~0; here c is some constant and ~1 is a column-vector of all ones. To satisfy a) after lifting, we need to ensure that d` = d̄`−P (ā`+Ud̄`) = −P ā` = −cP~1 = ~0. Therefore, the rows of predict operator should sum to zero: P~1 = ~0. To satisfy b), we need to preserve the first order moment at every level ` by requiring∑ k a`+1,kV ol(R`+1,k) = ∑ k ā`,kV ol(R`,k) = ∑ k a`,kV ol(R`,k). The first equality is already satisfied (due to the use of Haar wavelets), so we need to constrain our update operator. Introducing the diagonal matrix Ac of the region volumes at level `, we can write 0 =∑\nk a`,kV ol(R`,k) − ∑ k ā`,kV ol(R`,k) = ∑ k Ud̄`V ol(R`,k) = ~1tAcUd̄`. Since this should\nbe satisfied for all d̄`, we must have ~1tAcU = ~0t.\nTaking these two requirements into consideration, we impose the following constraints on predict and update weights:\nP~1 = ~0 and U = A−1c P tAf\nwhere Af is the diagonal matrix of the active region volumes at level `+ 1. It is easy to check that ~1tAcU = ~1 tAcA −1 c P tAf = ~1 tP tAf = (P~1) tAf = ~0 tAf = ~0\nt as required. We have introduced the volume matrix Af of regions at the finer level to make the update/predict matrices dimensionless (i.e. insensitive to whether the volume is measured in any particular units).\nLocality: To make our wavelets and scaling functions localized on the graph, we need to constrain update and predict operators in a way that would disallow distant regions from updating or predicting the approximation/detail coefficients of each other.\nSince the update is tied to the predict operator, we can limit ourselves to the latter operator. For a detail coefficient d`,k corresponding to the active region R`+1,k, we only allow predictions that come from the parent region R`,par(k) and the immediate neighbors of this parent region. Two regions of graph are considered neighboring if their union is a connected graph. This can be seen as enforcing a sparsity structure on the matrix P or as limiting the interconnections between the layers of neurons.\nAs a result of this choice, it is not difficult to see that the resulting scaling functions φ`,k and wavelets ψ`,k will be supported in the vicinity of the region R`,k. Larger supports can be obtained by allowing the use of second and higher order neighbors of the parent for prediction."
    }, {
      "heading" : "4.3 Optimization",
      "text" : "A variety of ways for optimizing auto-encoders are available, we refer the reader to the recent paper [15] and references therein. In our setting, due to the relatively small size of the training set and sparse inter-connectivity between the layers, an off-the-shelf L-BFGS1 unconstrained smooth optimization package works very well. In order to make our problem unconstrained, we avoid imposing the equation P~1 = ~0 as a hard constraint, but in each row of P (which corresponds to some active region), the weight corresponding to the parent is eliminated. To obtain a smooth objective, we use L1 norm with soft absolute value s(x) = √ + x2 ≈ |x|, where we set = 10−4. The initialization is done by setting all of the weights equal to zero. This is meaningful, because it corresponds to no lifting at all, and would reproduce the original Haar wavelets."
    }, {
      "heading" : "4.4 Training functions",
      "text" : "When training functions are available we directly use them. However, our construction can be applied even if training functions are not specified. In this case we choose smoothness as our prior, and train the wavelets with a set of smooth functions on the graph – namely, we use scaled eigenvectors of graph Laplacian corresponding to the smallest eigenvalues. More precisely, let D be the diagonal\n1Mark Schmidt, http://www.di.ens.fr/˜mschmidt/Software/minFunc.html\nmatrix with entriesDii = ∑ j Wij . The graph Laplacian L is defined as L = S −1(D−W ).We solve the symmetric generalized eigenvalue problem (D−W )ξ = λSξ to compute the smallest eigen-pairs {λn, ξn}nmaxn=0 .We discard the 0-th eigen-pair which corresponds to the constant eigenvector, and use functions {ξn/λn}nmaxn=1 as our training set. The inverse scaling by the eigenvalue is included because eigenvectors corresponding to larger eigenvalues are less smooth (cf. [1]), and so should be assigned smaller weights to achieve a smooth prior."
    }, {
      "heading" : "4.5 Partitioning",
      "text" : "Since our construction is based on improving upon the Haar wavelets, their quality will have an effect on the final wavelets. As proved in [10], the quality of Haar wavelets depends on the quality (balance) of the graph partitioning. From practical standpoint, it is hard to achieve high quality partitions on all types of graphs using a single algorithm. However, for the datasets presented in this paper we find that the following approach based on spectral clustering algorithm of [18] works well. Namely, we first embed the graph vertices into Rnmax as follows: i → (ξ1(i)/λ1, ξ2(i)/λ2, ..., ξnmax(i)/λnmax),∀i ∈ V , where {λn, ξn} nmax n=0 are the eigen-pairs of the Laplacian as in §4.4, and ξ·(i) is the value of the eigenvector at the i-th vertex of the graph. To obtain a hierarchical tree of partitions, we start with the graph itself as the root. At every step, a given region (a subset of the vertex set) of graph G is split into two children partitions by running the 2-means clustering algorithm (k-means with k = 2) on the above embedding restricted to the vertices of the given partition [24]. This process is continued in recursion at every obtained region. This results in a dyadic partitioning except at the finest level `max."
    }, {
      "heading" : "4.6 Graph construction for point clouds",
      "text" : "Our problem setup started with a weighted graph and arrived to the Laplacian matrix L in §4.4. It is also possible o reverse this process whereby one starts with the Laplacian matrix L and infers from it the weighted graph. This is a natural way of dealing with point clouds sampled from low-dimensional manifolds, a setting common in manifold learning. There is a number of ways for computing Laplacians on point clouds, see [5]; almost all of them fit into the above form L = S−1(D −W ), and so, they can be used to infer a weighted graph that can be plugged into our construction."
    }, {
      "heading" : "5 Experiments",
      "text" : "Our goal is to experimentally investigate the constructed wavelets for multiscale behavior, meaningful adaptation to training signals, and sparse representation that generalizes to testing signals.\nFor the first two objectives we visualize the scaling functions at different levels ` because they provide insight about the signal approximation spaces V`. The generalization performance can be deduced from comparison to Haar wavelets, because during training we modify Haar wavelets so as to achieve a sparser representation of training signals.\nWe start with the case of a periodic interval, which is discretized as a cycle graph; 32 scaled eigenvectors (sines\nand cosines) are used for training. Figure 2 shows the resulting scaling and wavelet functions at level ` = 4. Up to discretization errors, the wavelets and scaling functions at the same level are shifts of each other – showing that our construction is able to learn shift invariance from training functions.\nFigure 3(a) depicts a graph representing the road network of Minnesota, with edges showing the major roads and vertices being their intersections. In our construction we employ unit weights on edges and use 32 scaled eigenvectors of graph Laplacian as training functions. The resulting scaling functions for regions containing the red vertex in Figure 3(a) are shown at different levels in Figure 3(b,c,d,e,f). The function values at graph vertices are color coded from smallest (dark blue) to largest (dark red). Note that the scaling functions are continuous and show multiscale spatial behavior.\nTo test whether the learned wavelets provide a sparse representation of smooth signals, we synthetically generated 100 continuous functions using the xy-coordinates (the coordinates have not been\nseen by the algorithm so far) of the vertices; Figure 3(g) shows one of such functions. Figure 3(h) shows the average error of reconstruction from expansion Eq. (1) with `0 = 1 by keeping a specified fraction of largest detail coefficients. The improvement over the Haar wavelets shows that our model generalizes well to unseen signals.\nNext, we apply our approach to real-world graph signals. We use a dataset of average daily temperature measurements2 from meteorological stations located on the mainland US. The longitudes and latitudes of stations are treated as coordinates of a point cloud, from which a weighted Laplacian is constructed using [5] with 5-nearest neighbors; the resulting graph is shown in Figure 4(a).\nThe daily temperature data for the year of 2012 gives us 366 signals on the graph; Figure 4(b) depicts one such signal. We use the signals from the first half of the year to train the wavelets, and test for sparse reconstruction quality on the second half of the year (and vice versa). Figure 4(c,d,e,f,g) depicts some of the scaling functions at a number of levels; note that the depicted scaling function at level ` = 2 captures the rough temperature distribution pattern of the US. The average reconstruction error from a specified fraction of largest detail coefficients is shown in Figure 4(g).\nAs an application, we employ our wavelets for semi-supervised learning of the temperature distribution for a day from the temperatures at a subset of labeled graph vertices. The sought temperature\n2National Climatic Data Center, ftp://ftp.ncdc.noaa.gov/pub/data/gsod/2012/\ndistribution is expanded as in Eq. (1) with `0 = 1, and the coefficients are found by solving a least squares problem using temperature values at labeled vertices. Since we expect the detail coefficients to be sparse, we impose a lasso penalty on them; to make the problem smaller, all detail coefficients for levels ` ≥ 7 are set to zero. We compare to the Laplacian regularized least squares [1] and harmonic interpolation approach [26]. A hold-out set of 25 random vertices is used to assign all the regularization parameters. The experiment is repeated for each of the days (not used to learn the wavelets) with the number of labeled vertices ranging from 10 to 200. Figure 4(h) shows the errors averaged over all days; our approach achieves lower error rates than the competitors.\nOur final example serves two purposes – showing the benefits of our construction in a standard image processing application and better demonstrating the nature of learned scaling functions. Images can be seen as signals on a graph – pixels are the vertices and each pixel is connected to its 8 nearest neighbors. We consider all of the Extended Yale Face Database B [11] images (cropped and down-sampled to 32 × 32) as a collection of signals on a single underlying graph. We randomly split the collection into half for training our wavelets, and test their reconstruction quality on the remaining half. Figure 5(a) depicts a number of obtained scaling functions at different levels (the rows correspond to levels ` = 4, 5, 6, 7, 8) in various locations (columns). The scaling functions have a face-like appearance at coarser levels, and capture more detailed facial features at finer levels. Note that the scaling functions show controllable multiscale spatial behavior.\nThe quality of reconstruction from a sparse set of detail coefficients is plotted in Figure 5(b,c). Here again we consider the expansion of Eq. (1) with `0 = 1, and reconstruct using a specified proportion of largest detail coefficients. We also make a comparison to reconstruction using the standard separable CDF 9/7 wavelet filterbanks from bottom-most level; for both of quality metrics, our wavelets trained on data perform better than CDF 9/7. The smoothly trained wavelets do not improve over the Haar wavelets, because the smoothness assumption does not hold for face images."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We have introduced an approach to constructing wavelets that take into consideration structural properties of both graph signals and their underlying graphs. An interesting direction for future research would be to randomize the graph partitioning process or to use bagging over training functions in order to obtain a family of wavelet constructions on the same graph – leading to overcomplete dictionaries like in [25]. One can also introduce multiple lifting steps at each level or even add non-linearities as common with neural networks. Our wavelets are obtained by training a structure similar to a deep neural network; interestingly, the recent work of Mallat and collaborators (e.g. [3]) goes in the other direction and provides a wavelet interpretation of deep neural networks. Therefore, we believe that there are ample opportunities for future work in the interface between wavelets and deep neural networks.\nAcknowledgments: We thank Jonathan Huang for discussions and especially for his advice regarding the experimental section. The authors acknowledge the support of NSF grants FODAVA 808515 and DMS 1228304, AFOSR grant FA9550-12-1-0372, ONR grant N00014-13-1-0341, a Google research award, and the Max Plack Center for Visual Computing and Communications."
    } ],
    "references" : [ {
      "title" : "Semi-supervised learning on riemannian manifolds",
      "author" : [ "M. Belkin", "P. Niyogi" ],
      "venue" : "Machine Learning, 56(1- 3):209–239,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Greedy layer-wise training of deep networks",
      "author" : [ "Y. Bengio", "P. Lamblin", "D. Popovici", "H. Larochelle" ],
      "venue" : "B. Schölkopf, J. Platt, and T. Hoffman, editors, Advances in Neural Information Processing Systems 19, pages 153–160. MIT Press, Cambridge, MA,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Invariant scattering convolution networks",
      "author" : [ "J. Bruna", "S. Mallat" ],
      "venue" : "IEEE Transactions on Pattern Analysis and Machine Intelligence, 35(8):1872–1886,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Nonlinear wavelet transforms for image coding via lifting",
      "author" : [ "R.L. Claypoole", "G. Davis", "W. Sweldens", "R.G. Baraniuk" ],
      "venue" : "IEEE Transactions on Image Processing, 12(12):1449–1459, Dec.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Diffusion maps",
      "author" : [ "R.R. Coifman", "S. Lafon" ],
      "venue" : "Applied and Computational Harmonic Analysis, 21(1):5–30, July",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Diffusion wavelets",
      "author" : [ "R.R. Coifman", "M. Maggioni" ],
      "venue" : "Appl. Comput. Harmon. Anal., 21(1):53–94,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Graph wavelets for spatial traffic analysis",
      "author" : [ "M. Crovella", "E.D. Kolaczyk" ],
      "venue" : "INFOCOM,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Factoring wavelet transforms into lifting steps",
      "author" : [ "I. Daubechies", "W. Sweldens" ],
      "venue" : "J. Fourier Anal. Appl., 4(3):245–267,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Multidimensional filter banks and multiscale geometric representations",
      "author" : [ "M.N. Do", "Y.M. Lu" ],
      "venue" : "Foundations and Trends in Signal Processing, 5(3):157–264,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Multiscale wavelets on trees, graphs and high dimensional data: Theory and applications to semi supervised learning",
      "author" : [ "M. Gavish", "B. Nadler", "R.R. Coifman" ],
      "venue" : "ICML, pages 367–374,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "From few to many: Illumination cone models for face recognition under variable lighting and pose",
      "author" : [ "A. Georghiades", "P. Belhumeur", "D. Kriegman" ],
      "venue" : "IEEE Trans. Pattern Anal. Mach. Intelligence, 23(6):643–660,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Wavelets on graphs via spectral graph theory",
      "author" : [ "D.K. Hammond", "P. Vandergheynst", "R. Gribonval" ],
      "venue" : "Appl. Comput. Harmon. Anal., 30(2):129–150,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A fast learning algorithm for deep belief nets",
      "author" : [ "G.E. Hinton", "S. Osindero", "Y.-W. Teh" ],
      "venue" : "Neural Comput., 18(7):1527–1554,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Reducing the Dimensionality of Data with Neural Networks",
      "author" : [ "G.E. Hinton", "R. Salakhutdinov" ],
      "venue" : "Science, 313:504–507, July",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "On optimization methods for deep learning",
      "author" : [ "Q.V. Le", "J. Ngiam", "A. Coates", "A. Lahiri", "B. Prochnow", "A.Y. Ng" ],
      "venue" : "ICML, pages 265–272,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A Wavelet Tour of Signal Processing, Third Edition: The Sparse Way",
      "author" : [ "S. Mallat" ],
      "venue" : "Academic Press, 3rd edition,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Multi-dimensional separable critically sampled wavelet filterbanks on arbitrary graphs",
      "author" : [ "S.K. Narang", "A. Ortega" ],
      "venue" : "ICASSP, pages 3501–3504,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "On spectral clustering: Analysis and an algorithm",
      "author" : [ "A.Y. Ng", "M.I. Jordan", "Y. Weiss" ],
      "venue" : "NIPS, pages 849–856,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Generalized tree-based wavelet transform",
      "author" : [ "I. Ram", "M. Elad", "I. Cohen" ],
      "venue" : "IEEE Transactions on Signal Processing, 59(9):4199–4209,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Efficient learning of sparse representations with an energy-based model",
      "author" : [ "M. Ranzato", "C. Poultney", "S. Chopra", "Y. LeCun" ],
      "venue" : "B. Schölkopf, J. Platt, and T. Hoffman, editors, Advances in Neural Information Processing Systems 19, pages 1137–1144. MIT Press, Cambridge, MA,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Average interpolating wavelets on point clouds and graphs",
      "author" : [ "R.M. Rustamov" ],
      "venue" : "CoRR, abs/1110.2227,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "The emerging field of signal processing on graphs: Extending high-dimensional data analysis to networks and other irregular domains",
      "author" : [ "D.I. Shuman", "S.K. Narang", "P. Frossard", "A. Ortega", "P. Vandergheynst" ],
      "venue" : "IEEE Signal Process. Mag., 30(3):83–98,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "The lifting scheme: A construction of second generation wavelets",
      "author" : [ "W. Sweldens" ],
      "venue" : "SIAM Journal on Mathematical Analysis, 29(2):511–546,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Diffusion-driven multiscale analysis on manifolds and graphs: top-down and bottom-up constructions",
      "author" : [ "A.D. Szlam", "M. Maggioni", "R.R. Coifman", "J.C. Bremer" ],
      "venue" : "SPIE, volume 5914,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Learning of structured graph dictionaries",
      "author" : [ "X. Zhang", "X. Dong", "P. Frossard" ],
      "venue" : "ICASSP, pages 3373–3376,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Semi-supervised learning using gaussian fields and harmonic functions",
      "author" : [ "X. Zhu", "Z. Ghahramani", "J.D. Lafferty" ],
      "venue" : "ICML, pages 912–919,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 21,
      "context" : "Processing of signals on graphs is emerging as a fundamental problem in an increasing number of applications [22].",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 6,
      "context" : "A number of approaches for constructing wavelets on graphs have been proposed, including, but not limited to the CKWT [7], Haar-like wavelets [24, 10], diffusion wavelets [6], spectral wavelets [12], tree-based wavelets [19], average-interpolating wavelets [21], and separable filterbank wavelets [17].",
      "startOffset" : 118,
      "endOffset" : 121
    }, {
      "referenceID" : 23,
      "context" : "A number of approaches for constructing wavelets on graphs have been proposed, including, but not limited to the CKWT [7], Haar-like wavelets [24, 10], diffusion wavelets [6], spectral wavelets [12], tree-based wavelets [19], average-interpolating wavelets [21], and separable filterbank wavelets [17].",
      "startOffset" : 142,
      "endOffset" : 150
    }, {
      "referenceID" : 9,
      "context" : "A number of approaches for constructing wavelets on graphs have been proposed, including, but not limited to the CKWT [7], Haar-like wavelets [24, 10], diffusion wavelets [6], spectral wavelets [12], tree-based wavelets [19], average-interpolating wavelets [21], and separable filterbank wavelets [17].",
      "startOffset" : 142,
      "endOffset" : 150
    }, {
      "referenceID" : 5,
      "context" : "A number of approaches for constructing wavelets on graphs have been proposed, including, but not limited to the CKWT [7], Haar-like wavelets [24, 10], diffusion wavelets [6], spectral wavelets [12], tree-based wavelets [19], average-interpolating wavelets [21], and separable filterbank wavelets [17].",
      "startOffset" : 171,
      "endOffset" : 174
    }, {
      "referenceID" : 11,
      "context" : "A number of approaches for constructing wavelets on graphs have been proposed, including, but not limited to the CKWT [7], Haar-like wavelets [24, 10], diffusion wavelets [6], spectral wavelets [12], tree-based wavelets [19], average-interpolating wavelets [21], and separable filterbank wavelets [17].",
      "startOffset" : 194,
      "endOffset" : 198
    }, {
      "referenceID" : 18,
      "context" : "A number of approaches for constructing wavelets on graphs have been proposed, including, but not limited to the CKWT [7], Haar-like wavelets [24, 10], diffusion wavelets [6], spectral wavelets [12], tree-based wavelets [19], average-interpolating wavelets [21], and separable filterbank wavelets [17].",
      "startOffset" : 220,
      "endOffset" : 224
    }, {
      "referenceID" : 20,
      "context" : "A number of approaches for constructing wavelets on graphs have been proposed, including, but not limited to the CKWT [7], Haar-like wavelets [24, 10], diffusion wavelets [6], spectral wavelets [12], tree-based wavelets [19], average-interpolating wavelets [21], and separable filterbank wavelets [17].",
      "startOffset" : 257,
      "endOffset" : 261
    }, {
      "referenceID" : 16,
      "context" : "A number of approaches for constructing wavelets on graphs have been proposed, including, but not limited to the CKWT [7], Haar-like wavelets [24, 10], diffusion wavelets [6], spectral wavelets [12], tree-based wavelets [19], average-interpolating wavelets [21], and separable filterbank wavelets [17].",
      "startOffset" : 297,
      "endOffset" : 301
    }, {
      "referenceID" : 18,
      "context" : "[19, 17]), such an approach does not fully exploit the degrees of freedom inherent in wavelet design.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 16,
      "context" : "[19, 17]), such an approach does not fully exploit the degrees of freedom inherent in wavelet design.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 8,
      "context" : "In contrast, a variety of signal class specific and adaptive wavelet constructions exist on images and multidimensional regular domains, see [9] and references therein.",
      "startOffset" : 141,
      "endOffset" : 144
    }, {
      "referenceID" : 21,
      "context" : "In addition, theoretical guidance for such adaptive constructions is lacking as it remains largely unknown how the properties of the graph wavelet transforms, such as sparsity, relate to the structural properties of graph signals and their underlying graphs [22].",
      "startOffset" : 258,
      "endOffset" : 262
    }, {
      "referenceID" : 12,
      "context" : "The training is unsupervised, and is conducted similarly to the greedy (pre-)training [13, 14, 2, 20] of a stack of auto-encoders.",
      "startOffset" : 86,
      "endOffset" : 101
    }, {
      "referenceID" : 13,
      "context" : "The training is unsupervised, and is conducted similarly to the greedy (pre-)training [13, 14, 2, 20] of a stack of auto-encoders.",
      "startOffset" : 86,
      "endOffset" : 101
    }, {
      "referenceID" : 1,
      "context" : "The training is unsupervised, and is conducted similarly to the greedy (pre-)training [13, 14, 2, 20] of a stack of auto-encoders.",
      "startOffset" : 86,
      "endOffset" : 101
    }, {
      "referenceID" : 19,
      "context" : "The training is unsupervised, and is conducted similarly to the greedy (pre-)training [13, 14, 2, 20] of a stack of auto-encoders.",
      "startOffset" : 86,
      "endOffset" : 101
    }, {
      "referenceID" : 18,
      "context" : "by modifying the underlying graph [19, 17]) which effectively renders those transforms non-linear.",
      "startOffset" : 34,
      "endOffset" : 42
    }, {
      "referenceID" : 16,
      "context" : "by modifying the underlying graph [19, 17]) which effectively renders those transforms non-linear.",
      "startOffset" : 34,
      "endOffset" : 42
    }, {
      "referenceID" : 15,
      "context" : "The goal of wavelet design is to obtain a multiresolution [16] ofL(2)(G) – the set of all functions/signals on graph G.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 22,
      "context" : "Our construction of wavelets is based on the lifting scheme [23].",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 12,
      "context" : "The training is conducted in a manner similar to the greedy pre-training of a stack of auto-encoders [13, 14, 2, 20].",
      "startOffset" : 101,
      "endOffset" : 116
    }, {
      "referenceID" : 13,
      "context" : "The training is conducted in a manner similar to the greedy pre-training of a stack of auto-encoders [13, 14, 2, 20].",
      "startOffset" : 101,
      "endOffset" : 116
    }, {
      "referenceID" : 1,
      "context" : "The training is conducted in a manner similar to the greedy pre-training of a stack of auto-encoders [13, 14, 2, 20].",
      "startOffset" : 101,
      "endOffset" : 116
    }, {
      "referenceID" : 19,
      "context" : "The training is conducted in a manner similar to the greedy pre-training of a stack of auto-encoders [13, 14, 2, 20].",
      "startOffset" : 101,
      "endOffset" : 116
    }, {
      "referenceID" : 7,
      "context" : "First, every invertible 1D discrete wavelet transform can be factored into lifting steps [8], which makes lifting a universal tool for constructing multiresolutions.",
      "startOffset" : 89,
      "endOffset" : 92
    }, {
      "referenceID" : 23,
      "context" : "We choose to apply lifting to Haar wavelets specifically because Haar wavelets are easy to define on any underlying space provided that it can be hierarchically partitioned [24, 10].",
      "startOffset" : 173,
      "endOffset" : 181
    }, {
      "referenceID" : 9,
      "context" : "We choose to apply lifting to Haar wavelets specifically because Haar wavelets are easy to define on any underlying space provided that it can be hierarchically partitioned [24, 10].",
      "startOffset" : 173,
      "endOffset" : 181
    }, {
      "referenceID" : 3,
      "context" : "common use for adaptive wavelet constructions in image processing literature, which is motivated by its stability; see [4] for a thorough discussion.",
      "startOffset" : 119,
      "endOffset" : 122
    }, {
      "referenceID" : 14,
      "context" : "A variety of ways for optimizing auto-encoders are available, we refer the reader to the recent paper [15] and references therein.",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 0,
      "context" : "[1]), and so should be assigned smaller weights to achieve a smooth prior.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 9,
      "context" : "As proved in [10], the quality of Haar wavelets depends on the quality (balance) of the graph partitioning.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 17,
      "context" : "However, for the datasets presented in this paper we find that the following approach based on spectral clustering algorithm of [18] works well.",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 23,
      "context" : "At every step, a given region (a subset of the vertex set) of graph G is split into two children partitions by running the 2-means clustering algorithm (k-means with k = 2) on the above embedding restricted to the vertices of the given partition [24].",
      "startOffset" : 246,
      "endOffset" : 250
    }, {
      "referenceID" : 4,
      "context" : "There is a number of ways for computing Laplacians on point clouds, see [5]; almost all of them fit into the above form L = S−1(D −W ), and so, they can be used to infer a weighted graph that can be plugged into our construction.",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 4,
      "context" : "The longitudes and latitudes of stations are treated as coordinates of a point cloud, from which a weighted Laplacian is constructed using [5] with 5-nearest neighbors; the resulting graph is shown in Figure 4(a).",
      "startOffset" : 139,
      "endOffset" : 142
    }, {
      "referenceID" : 0,
      "context" : "We compare to the Laplacian regularized least squares [1] and harmonic interpolation approach [26].",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 25,
      "context" : "We compare to the Laplacian regularized least squares [1] and harmonic interpolation approach [26].",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 10,
      "context" : "We consider all of the Extended Yale Face Database B [11] images (cropped and down-sampled to 32 × 32) as a collection of signals on a single underlying graph.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 24,
      "context" : "An interesting direction for future research would be to randomize the graph partitioning process or to use bagging over training functions in order to obtain a family of wavelet constructions on the same graph – leading to overcomplete dictionaries like in [25].",
      "startOffset" : 258,
      "endOffset" : 262
    }, {
      "referenceID" : 2,
      "context" : "[3]) goes in the other direction and provides a wavelet interpretation of deep neural networks.",
      "startOffset" : 0,
      "endOffset" : 3
    } ],
    "year" : 2013,
    "abstractText" : "An increasing number of applications require processing of signals defined on weighted graphs. While wavelets provide a flexible tool for signal processing in the classical setting of regular domains, the existing graph wavelet constructions are less flexible – they are guided solely by the structure of the underlying graph and do not take directly into consideration the particular class of signals to be processed. This paper introduces a machine learning framework for constructing graph wavelets that can sparsely represent a given class of signals. Our construction uses the lifting scheme, and is based on the observation that the recurrent nature of the lifting scheme gives rise to a structure resembling a deep auto-encoder network. Particular properties that the resulting wavelets must satisfy determine the training objective and the structure of the involved neural networks. The training is unsupervised, and is conducted similarly to the greedy pre-training of a stack of auto-encoders. After training is completed, we obtain a linear wavelet transform that can be applied to any graph signal in time and memory linear in the size of the graph. Improved sparsity of our wavelet transform for the test signals is confirmed via experiments both on synthetic and real data.",
    "creator" : null
  }
}