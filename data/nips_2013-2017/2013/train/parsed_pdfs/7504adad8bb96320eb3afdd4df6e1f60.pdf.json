{
  "name" : "7504adad8bb96320eb3afdd4df6e1f60.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Approximate Dynamic Programming Finally Performs Well in the Game of Tetris",
    "authors" : [ "Victor Gabillon", "Mohammad Ghavamzadeh" ],
    "emails" : [ "victor.gabillon@inria.fr", "mohammad.ghavamzadeh@inria.fr", "bruno.scherrer@inria.fr" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Tetris is a popular video game created by Alexey Pajitnov in 1985. The game is played on a grid originally composed of 20 rows and 10 columns, where pieces of 7 different shapes fall from the top – see Figure 1. The player has to choose where to place each falling piece by moving it horizontally and rotating it. When a row is filled, it is removed and all the cells above it move one line down. The goal is to remove as many rows as possible before the game is over, i.e., when there is no space available at the top of the grid for the new piece.\nIn this paper, we consider the variation of the game in which the player knows only the current falling piece, and not the next several coming pieces. This game constitutes an interesting optimization benchmark in which the goal is to find a controller (policy) that maximizes the average (over multiple games) number of lines removed in a game (score).1 This optimization problem is known to be computationally hard. It contains a huge number of board configurations (about 2200 � 1.6 × 1060), and even in the case that the sequence of pieces is known in advance, finding the optimal strategy is an NP hard problem [4].\nApproximate dynamic programming (ADP) and reinforcement learning (RL) algorithms have been used in Tetris. These algorithms formulate Tetris as a Markov decision process (MDP) in which the state is defined by the current board configuration plus the falling piece, the actions are the\n∗Mohammad Ghavamzadeh is currently at Adobe Research, on leave of absence from INRIA. 1Note that this number is finite because it was shown that Tetris is a game that ends with probability one [3].\npossible orientations of the piece and the possible locations that it can be placed on the board,2 and the reward is defined such that maximizing the expected sum of rewards from each state coincides with maximizing the score from that state. Since the state space is large in Tetris, these methods use value function approximation schemes (often linear approximation) and try to tune the value function parameters (weights) from game simulations. The first application of ADP in Tetris seems to be by Tsitsiklis and Van Roy [22]. They used the approximate value iteration algorithm with two state features: the board height and the number of holes in the board, and obtained a low score of 30 to 40. Bertsekas and Ioffe [1] proposed the λ-Policy Iteration (λ-PI) algorithm (a generalization of value and policy iteration) and applied it to Tetris. They approximated the value function as a linear combination of a more elaborate set of 22 features and reported the score of 3, 200 lines. The exact same empirical study was revisited recently by Scherrer [16], who corrected an implementation bug in [1], and reported more stable learning curves and the score of 4, 000 lines. At least three other ADP and RL papers have used the same set of features, we refer to them as the “Bertsekas features”, in the game of Tetris. Kakade [11] applied a natural policy gradient method to Tetris and reported a score of about 6, 800 lines. Farias and Van Roy [6] applied a linear programming algorithm to the game and achieved the score of 4, 700 lines. Furmston and Barber [8] proposed an approximate Newton method to search in a policy space and were able to obtain a score of about 14, 000.\nDespite all the above applications of ADP in Tetris (and possibly more), for a long time, the best Tetris controller was the one designed by Dellacherie [5]. He used a heuristic evaluation function to give a score to each possible strategy (in a way similar to value function in ADP), and eventually returned the one with the highest score. Dellacherie’s evaluation function is made of 6 high-quality features with weights chosen by hand, and achieved a score of about 5, 000, 000 lines [19]. Szita and Lőrincz [18] used the “Bertsekas features” and optimized the weights by running a black box optimizer based on the cross entropy (CE) method [15]. They reported the score of 350, 000 lines averaged over 30 games, outperforming the ADP and RL approaches that used the same features. More recently, Thiery and Scherrer [20] selected a set of 9 features (including those of Dellacherie’s) and optimized the weights with the CE method. This led to the best publicly known controller (to the best of our knowledge) with the score of around 35, 000, 000 lines.\nDue to the high variance of the score and its sensitivity to some implementation details [19], it is difficult to have a precise evaluation of Tetris controllers. However, our brief tour d’horizon of the literature, and in particular the work by Szita and Lőrincz [18] (optimizing the “Bertsekas features” by CE), indicate that ADP algorithms, even with relatively good features, have performed extremely worse than the methods that directly search in the space of policies (such as CE and genetic algorithms). It is important to note that almost all these ADP methods are value function based algorithms that first define a value function representation (space) and then search in this space for a good function, which later gives us a policy.\nThe main motivation of our work comes from the above observation. This observation makes us conjecture that Tetris is a game whose policy space is easier to represent, and as a result to search in, than its value function space. Therefore, in order to obtain a good performance with ADP algorithms in this game, we should use those ADP methods that search in a policy space, instead of the more traditional ones that search in a value function space. Fortunately a class of such ADP algorithms, called classification-based policy iteration (CbPI), have been recently developed and analyzed [12, 7, 13, 9, 17]. These algorithms differ from the standard value function based ADP methods in how the greedy policy is computed. Specifically, at each iteration CbPI algorithms approximate the entire greedy policy as the output of a classifier, while in the standard methods, at every given state, the required action from the greedy policy is individually calculated based on the approximation of the value function of the current policy. Since CbPI methods search in a policy space (defined by a classifier) instead of a value function space, we believe that they should perform better than their value function based counterparts in problems in which good policies are easier to represent than their corresponding value functions. In this paper, we put our conjecture to test by applying an algorithm in this class, called classification-based modified policy iteration (CBMPI) [17], to the game of Tetris, and compare its performance with the CE method and the λ-PI algorithm. The choice of CE and λ-PI is because the former has achieved the best known results in Tetris and the latter’s performance is among the best reported for value function based ADP algorithms. Our extensive experimental results show that for the first time an ADP algorithm, namely CBMPI, obtains the best results reported in the literature for Tetris in both small 10× 10 and large 10× 20 boards. Although\n2The total number of actions at a state depends on the falling piece, with the maximum of 32, i.e. |A| ≤ 32.\nthe CBMPI’s results are similar to those achieved by the CE method in the large board, CBMPI uses considerably fewer (almost 1/6) samples (call to the generative model of the game) than CE. In Section 2, we briefly describe the algorithms used in our experiments. In Section 3, we outline the setting of each algorithm in our experiments and report our results followed by discussion."
    }, {
      "heading" : "2 Algorithms",
      "text" : "In this section, we briefly describe the algorithms used in our experiments: the cross entropy (CE) method, classification-based modified policy iteration (CBMPI) [17] and its slight variation direct policy iteration (DPI) [13], and λ-policy iteration (see [16] for a description of λ-PI). We begin by defining some terms and notations. A state s in Tetris consists of two components: the description of the board b and the type of the falling piece p. All controllers rely on an evaluation function that gives a value to each possible action at a given state. Then, the controller chooses the action with the highest value. In ADP, algorithms aim at tuning the weights such that the evaluation function approximates well the optimal expected future score from each state. Since the total number of states is large in Tetris, the evaluation function f is usually defined as a linear combination of a set of features φ, i.e., f(·) = φ(·)θ. We can think of the parameter vector θ as a policy (controller) whose performance is specified by the corresponding evaluation function f(·) = φ(·)θ. The features used in Tetris for a state-action pair (s, a) may depend on the description of the board b� resulted from taking action a in state s, e.g., the maximum height of b�. Computing such features requires the knowledge of the game’s dynamics, which is known in Tetris."
    }, {
      "heading" : "2.1 Cross Entropy Method",
      "text" : "Cross-entropy (CE) [15] is an iterative method whose goal is to optimize a function f parameterized by a vector θ ∈ Θ by direct search in the parameter space Θ. Figure 2 contains the pseudo-code of the CE algorithm used in our experiments [18, 20]. At each iteration k, we sample n parameter vectors {θi}ni=1 from a multivariate Gaussian distribution N (µ, σ2I). At the beginning, the parameters of this Gaussian have been set to cover a wide region of Θ. For each parameter θi, we play L games and calculate the average number of rows removed by this controller (an estimate of the evaluation function). We then select �ρn� of these parameters with the highest score, θ�1, . . . , θ��ρn�, and use them to update the mean µ and variance σ2 of the Gaussian distribution, as shown in Figure 2. This updated Gaussian is used to sample the n parameters at the next iteration. The goal of this update is to sample more parameters from the promising part of Θ at the next iteration, and eventually converge to a global maximum of f ."
    }, {
      "heading" : "2.2 Classification-based Modified Policy Iteration (CBMPI)",
      "text" : "Modified policy iteration (MPI) [14] is an iterative algorithm to compute the optimal policy of a MDP that starts with initial policy π1 and value v0, and generates a sequence of value-policy pairs\nvk = (Tπk) mvk−1 (evaluation step), πk+1 = G � (Tπk) mvk−1 �\n(greedy step), where Gvk is a greedy policy w.r.t. vk, Tπk is the Bellman operator associated with the policy πk, and m ≥ 1 is a parameter. MPI generalizes the well-known value and policy iteration algorithms for the values m = 1 and m = ∞, respectively. CBMPI [17] is an approximation of MPI that uses an explicit representation for the policies πk, in addition to the one used for the value functions vk. The idea is similar to the classification-based PI algorithms [12, 7, 13] in which we search for the greedy policy in a policy space Π (defined by a classifier) instead of computing it from the estimated value function (as in the standard implementation of MPI). As described in Figure 3, CBMPI begins with an arbitrary initial policy π1 ∈ Π and value function v0 ∈ F .3 At each iteration k, a new value func-\n3Note that the function space F and policy space Π are defined by the choice of the regressor and classifier.\ntion vk is built as the best approximation of the m-step Bellman operator (Tπk) mvk−1 in F (evaluation step). This is done by solving a regression problem whose target function is (Tπk) mvk−1. To set up the regression problem, we build a rollout set Dk by sampling N states i.i.d. from a distribution µ. For each state s(i) ∈ Dk, we generate a rollout � s(i), a (i) 0 , r (i) 0 , s (i) 1 , . . . , a (i) m−1, r (i) m−1, s (i) m � of size m, where a(i)t = πk(s (i) t ), and r (i) t and s (i) t+1 are the reward and next state induced by this choice of\naction. From this rollout, we compute an unbiased estimate �vk(s(i)) of � (Tπk) mvk−1 � (s(i)) as\n�vk(s(i)) = m−1�\nt=0\nγtr (i) t + γ mvk−1(s (i) m ), (γ is the discount factor), (1)\nand use it to build a training set �� s(i), �vk(s(i)) ��N\ni=1 . This training set is then used by the regressor\nto compute vk as an estimate of (Tπk) mvk−1. The regressor finds a function v ∈ F that minimizes the empirical error\n�LFk (�µ; v) = 1\nN\nN�\ni=1\n� �vk(s(i))− v(s(i)) �2 . (2)\nThe greedy step at iteration k computes the policy πk+1 as the best approximation of G � (Tπk) mvk−1 � by minimizing the cost-sensitive empirical error (cost-sensitive classification)\n�LΠk (�µ;π) = 1\nN �\nN ��\ni=1\n� max a∈A �Qk(s(i), a)− �Qk � s(i), π(s(i)) �� . (3)\nTo set up this cost-sensitive classification problem, we build a rollout set D�k by sampling N � states i.i.d. from a distribution µ. For each state s(i) ∈ D�k and each action a ∈ A, we build M independent rollouts of size m+ 1, i.e., � s(i), a, r\n(i,j) 0 , s (i,j) 1 , a (i,j) 1 , . . . , a (i,j) m , r (i,j) m , s (i,j) m+1 �M j=1\n, where for t ≥ 1, a (i,j) t = πk(s (i,j) t ), and r (i,j) t and s (i,j) t+1 are the reward and next state induced by this choice of action. From these rollouts, we compute an unbiased estimate of Qk(s(i), a) as �Qk(s(i), a) = 1 M �M j=1 R j k(s (i), a) where each rollout estimate is defined as\nRjk(s (i), a) =\nm�\nt=0\nγtr (i,j) t + γ m+1vk−1(s (i,j) m+1). (4)\nIf we remove the regressor from CBMPI and only use the m-truncated rollouts Rjk(s (i), a) =�m\nt=0 γ tr (i,j) t to compute �Qk(s(i), a), then CBMPI become the direct policy iteration (DPI) algorithm [13] that we also use in our experiments (see [17] for more details on the CBMPI algorithm).\nIn our implementation of CBMPI (DPI) in Tetris (Section 3), we use the same rollout set (Dk = D�k) and rollouts for the classifier and regressor. This is mainly to be more sample efficient. Fortunately, we observed that this does not affect the overall performance of the algorithm. We set the discount factor γ = 1. Regressor: We use linear function approximation for the value function, i.e., �vk(s(i)) = φ(s(i))w, where φ(·) and w are the feature and weight vectors, and minimize the empirical error �LFk (�µ; v) using the standard least-squares method. Classifier: The training set of the classifier is of size N with s(i) ∈ D�k as input and� maxa �Qk(s(i), a) − �Qk(s(i), a1), . . . ,maxa �Qk(s(i), a) − �Qk(s(i), a|A|) � as output. We use the policies of the form πu(s) = argmaxa ψ(s, a)u, where ψ is the policy feature vector (possibly different from the value function feature vector φ) and u is the policy parameter vector. We compute the next policy πk+1 by minimizing the empirical error �LΠk (�µ;πu), defined by (3), using the covariance matrix adaptation evolution strategy (CMA-ES) algorithm [10]. In order to evaluate a policy u in CMA-ES, we only need to compute �LΠk (�µ;πu), and given the training set, this procedure does not require any simulation of the game. This is in contrary with policy evaluation in CE that requires playing several games, and it is the main reason that we obtain the same performance as CE with CBMPI with almost 1/6 number of samples (see Section 3.2)."
    }, {
      "heading" : "3 Experimental Results",
      "text" : "In this section, we evaluate the performance of CBMPI (DPI) and compare it with CE and λ-PI. CE is the state-of-the-art method in Tetris with huge performance advantage over ADP/RL methods [18, 19, 20]. In our experiments, we show that for a well-selected set of features, CBMPI improves over all the previously reported ADP results. Moreover, its performance is comparable to that of the CE method, while using considerably fewer samples (call to the generative model of the game)."
    }, {
      "heading" : "3.1 Experimental Setup",
      "text" : "In our experiments, the policies learned by the algorithms are evaluated by their score (average number of rows removed in a game) averaged over 200 games in the small 10× 10 board and over 20 games in the large 10×20 board. The performance of each algorithm is represented by a learning curve whose value at each iteration is the average score of the policies learned by the algorithm at that iteration in 100 separate runs of the algorithm. In addition to their score, we also evaluate the algorithms by the number of samples they use. In particular, we show that CBMPI/DPI use 6 times less samples than CE. As discussed in Section 2.2, this is due the fact that although the classifier in CBMPI/DPI uses a direct search in the space of policies (for the greedy policy), it evaluates each candidate policy using the empirical error of Eq. 3, and thus, does not require any simulation of the game (other than those used to estimate the �Qk’s in its training set). In fact, the budget B of CBMPI/DPI is fixed in advance by the number of rollouts NM and the rollout’s length m as B = (m + 1)NM |A|. In contrary, CE evaluates a candidate policy by playing several games, a process that can be extremely costly (sample-wise), especially for good policies in the large board.\nIn our CBMPI/DPI experiments, we set the number of rollouts per state-action pair M = 1, as this value has shown the best performance. Thus, we only study the behavior of CBMPI/DPI as a function of m and N . In CBMPI, the parameter m balances between the errors in evaluating the value function and the policy. For large values of m, the size of the rollout set decreases as N = O(B/m), which in turn decreases the accuracy of both the regressor and classifier. This leads to a trade-off between long rollouts and the number of states in the rollout set. The solution to this trade-off (bias/variance tradeoff in estimation of �Qk’s) strictly depends on the capacity of the value function space F . A rich value function space leads to solve the trade-off for small values of m, while a poor space, or no space in the case of DPI, suggests large values of m, but not too large to still guarantee a large enough N . We sample the rollout states in CBMPI/DPI from the trajectories generated by a very good policy for Tetris, namely the DU controller [20]. Since the DU policy is good, this rollout set is biased towards boards with small height. We noticed from our experiments that the performance can be significantly improved if we use boards with different heights in the rollout sets. This means that better performance can be achieved with more uniform sampling distribution, which is consistent with what we can learn from the CBMPI and DPI performance bounds. We set the initial value function parameter tow = 0̄ and select the initial policy π1 (policy parameter u) randomly. We also set the CMA-ES parameters (classifier parameters) to ρ = 0.5, η = 0, and n equal to 15 times the number of features.\nIn the CE experiments, we set ρ = 0.1 and η = 4, the best parameters reported in [20]. We also set n = 1000 and L = 10 in the small board and n = 100 and L = 1 in the large board.\nSet of Features: We use the following features, plus a constant offset feature, in our experiments:4 (i) Bertsekas features: First introduced by [2], this set of 22 features has been mainly used in the ADP/RL community and consists of: the number of holes in the board, the height of each column, the difference in height between two consecutive columns, and the maximum height of the board. (ii) Dellacherie-Thiery (D-T) features: This set consists of the six features of Dellacherie [5], i.e., the landing height of the falling piece, the number of eroded piece cells, the row transitions, the column transitions, the number of holes, and the number of board wells; plus 3 additional features proposed in [20], i.e., the hole depth, the number of rows with holes, and the pattern diversity feature. Note that the best policies reported in the literature have been learned using this set of features. (iii) RBF height features: These new 5 features are defined as exp(−|c−ih/4| 2\n2(h/5)2 ), i = 0, . . . , 4, where c is the average height of the columns and h = 10 or 20 is the total number of rows in the board."
    }, {
      "heading" : "3.2 Experiments",
      "text" : "We first run the algorithms on the small board to study the role of their parameters and to select the best features and parameters (Section 3.2.1). We then use the selected features and parameters and apply the algorithms to the large board (Figure 5 (d)) Finally, we compare the best policies found in our experiments with the best controllers reported in the literature (Tables 1 and 2).\n3.2.1 Small (10 × 10) Board Here we run the algorithms with two different feature sets: Dellacherie-Thiery (D-T) and Bertsekas.\nD-T features: Figure 4 shows the learning curves of CE, λ-PI, DPI, and CBMPI algorithms. Here we use D-T features for the evaluation function in CE, the value function in λ-PI, and the policy in DPI and CBMPI. We ran CBMPI with different feature sets for the value function and “D-T plus the 5 RBF features” achieved the best performance (Figure 4 (d)).5 The budget of CBMPI and DPI is set to B = 8, 000, 000 per iteration. The CE method reaches the score 3000 after 10 iterations using an average budget B = 65, 000, 000. λ-PI with the best value of λ only manages to score 400. In Figure 4 (c), we report the performance of DPI for different values of m. DPI achieves its best performance for m = 5 and m = 10 by removing 3400 lines on average. As explained in Section 3.1, having short rollouts (m = 1) in DPI leads to poor action-value estimates �Q, while having too long rollouts (m = 20) decreases the size of the training set of the classifier N . CBMPI outperforms the other algorithms, including CE, by reaching the score of 4300 for m = 2. The value of m = 2 corresponds to N = 8000000(2+1)×32 ≈ 84, 000. Note that unlike DPI, CBMPI achieves good performance with very short rollouts m = 1. This indicates that CBMPI is able to approximate the value function well, and as a result, to build a more accurate training set for its classifier than DPI. The results of Figure 4 show that an ADP algorithm, namely CBMPI, outperforms the CE method using a similar budget (80 vs. 65 millions after 10 iterations). Note that CBMPI takes less iterations to converge than CE. More generally Figure 4 confirms the superiority of the policy search and classification-based PI methods to value function based ADP algorithms (λ-PI). This suggests that the D-T features are more suitable to represent the policies than the value functions in Tetris.\nBertsekas features: Figures 5 (a)-(c) show the performance of CE, λ-PI, DPI, and CBMPI algorithms. Here all the approximations in the algorithms are with the Bertsekas features. CE achieves the score of 500 after about 60 iterations and outperforms λ-PI with score of 350. It is clear that the Bertsekas features lead to much weaker results than those obtained by the D-T features in Figure 4 for all the algorithms. We may conclude then that the D-T features are more suitable than the Bertsekas features to represent both value functions and policies in Tetris. In DPI and CBMPI, we managed to obtain results similar to CE, only after multiplying the per iteration budget B used in the D-T experiments by 10. However, CBMPI and CE use the same number of samples, 150, 000, 000, when they converge after 2 and 60 iterations, respectively (see Figure 5). Note that DPI and CBMPI obtain the same performance, which means that the use of a value function approximation by CBMPI\n4For a precise definition of the features, see [19] or the documentation of their code [21]. 5Note that we use D-T+5 features only for the value function of CBMPI, and thus, we have a fair comparison between CBMPI and DPI. To have a fair comparison with λ-PI, we ran this algorithm with D-T+5 features, and it only raised its performance to 800, still far from the CBMPI’s performance.\ndoes not lead to a significant performance improvement over DPI. At the end, we tried several values of m in this setting among which m = 10 achieved the best performance for both DPI and CBMPI.\n3.2.2 Large (10 × 20) Board We now use the best parameters and features in the small board experiments, run CE, DPI, and CBMPI algorithms in the large board, and report their results in Figure 5 (d). The per iteration budget of DPI and CBMPI is set to B = 16, 000, 000. While λ-PI with per iteration budget 620, 000, at its best, achieves the score of 2500 (due to space limitation, we do not report these results here), DPI and CBMPI, with m = 10, reach the scores of 12, 000, 000 and 21, 000, 000 after 3 and 6 iterations, respectively. CE matches the performances of CBMPI with the score of 20, 000, 000 after 8 iterations. However, this is achieved with almost 6 times more samples, i.e., after 8 iterations, CBMPI and CE use 256, 000, 000 and 1, 700, 000, 000 samples, respectively.\nComparison of the best policies: So far the reported scores for each algorithm was averaged over the policies learned in 100 separate runs. Here we select the best policies observed in our all experiments and compute their scores more accurately by averaging over 10, 000 games. We then compare these results with the best policies reported in the literature, i.e., DU and BDU [20] in both small and large boards in Table 1. The DT-10 and DT-20 policies, whose weights and features are given in Table 2, are policies learned by CBMPI with D-T features in the small and large boards, respectively. As shown in Table 1, DT-10 removes 5000 lines and outperforms DU, BDU, and DT-20 in the small board. Note that DT-10 is the only policy among these four that has been learned in the small board. In the large board, DT-20 obtains the score of 51, 000, 000 and not only outperforms the other three policies, but also achieves the best reported result in the literature (to the best of our knowledge)."
    }, {
      "heading" : "4 Conclusions",
      "text" : "The game of Tetris has been always challenging for approximate dynamic programming (ADP) algorithms. Surprisingly, much simpler black box optimization methods, such as cross entropy (CE), have produced controllers far superior to those learned by the ADP algorithms. In this paper, we applied a relatively novel ADP algorithm, called classification-based modified policy iteration (CBMPI), to Tetris. Our results showed that for the first time an ADP algorithm (CBMPI) performed extremely well in both small 10×10 and large 10×20 boards and achieved performance either better (in the small board) or equal with considerably fewer samples (in the large board) than the state-ofthe-art CE methods. In particular, the best policy learned by CBMPI obtained the performance of 51, 000, 000 lines on average, a new record in the large board of Tetris."
    } ],
    "references" : [ {
      "title" : "Temporal differences-based policy iteration and applications in neuro-dynamic programming",
      "author" : [ "D. Bertsekas", "S. Ioffe" ],
      "venue" : "Technical report, MIT",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Neuro-Dynamic Programming",
      "author" : [ "D. Bertsekas", "J. Tsitsiklis" ],
      "venue" : "Athena Scientific",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "How to Lose at Tetris",
      "author" : [ "H. Burgiel" ],
      "venue" : "Mathematical Gazette, 81:194–200",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Tetris is hard",
      "author" : [ "E. Demaine", "S. Hohenberger", "D. Liben-Nowell" ],
      "venue" : "even to approximate. In Proceedings of the Ninth International Computing and Combinatorics Conference, pages 351– 363",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Tetris AI",
      "author" : [ "C. Fahey" ],
      "venue" : "Computer plays Tetris",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Tetris: A study of randomized constraint sampling",
      "author" : [ "V. Farias", "B. van Roy" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2006
    }, {
      "title" : "Approximate Policy Iteration with a Policy Language Bias: Solving Relational Markov Decision Processes",
      "author" : [ "A. Fern", "S. Yoon", "R. Givan" ],
      "venue" : "Journal of Artificial Intelligence Research, 25:75–118",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A unifying perspective of parametric policy search methods for Markov decision processes",
      "author" : [ "T. Furmston", "D. Barber" ],
      "venue" : "Proceedings of the Advances in Neural Information Processing Systems, pages 2726–2734",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Classification-based policy iteration with a critic",
      "author" : [ "V. Gabillon", "A. Lazaric", "M. Ghavamzadeh", "B. Scherrer" ],
      "venue" : "Proceedings of ICML, pages 1049–1056",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Completely derandomized self-adaptation in evolution strategies",
      "author" : [ "N. Hansen", "A. Ostermeier" ],
      "venue" : "Evolutionary Computation, 9:159–195",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "A natural policy gradient",
      "author" : [ "S. Kakade" ],
      "venue" : "Proceedings of the Advances in Neural Information Processing Systems, pages 1531–1538",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Reinforcement Learning as Classification: Leveraging Modern Classifiers",
      "author" : [ "M. Lagoudakis", "R. Parr" ],
      "venue" : "Proceedings of ICML, pages 424–431",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Analysis of a Classification-based Policy Iteration Algorithm",
      "author" : [ "A. Lazaric", "M. Ghavamzadeh", "R. Munos" ],
      "venue" : "Proceedings of ICML, pages 607–614",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Modified policy iteration algorithms for discounted Markov decision problems",
      "author" : [ "M. Puterman", "M. Shin" ],
      "venue" : "Management Science, 24(11)",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "The cross-entropy method: A unified approach to combinatorial optimization",
      "author" : [ "R. Rubinstein", "D. Kroese" ],
      "venue" : "Monte-Carlo simulation, and machine learning. Springer-Verlag",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Performance Bounds for λ-Policy Iteration and Application to the Game of Tetris",
      "author" : [ "B. Scherrer" ],
      "venue" : "Journal of Machine Learning Research, 14:1175–1221",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Approximate modified policy iteration",
      "author" : [ "B. Scherrer", "M. Ghavamzadeh", "V. Gabillon", "M. Geist" ],
      "venue" : "Proceedings of ICML, pages 1207–1214",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Learning Tetris Using the Noisy Cross-Entropy Method",
      "author" : [ "I. Szita", "A. Lőrincz" ],
      "venue" : "Neural Computation, 18(12):2936–2941",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Building Controllers for Tetris",
      "author" : [ "C. Thiery", "B. Scherrer" ],
      "venue" : "International Computer Games Association Journal, 32:3–11",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Improvements on Learning Tetris with Cross Entropy",
      "author" : [ "C. Thiery", "B. Scherrer" ],
      "venue" : "International Computer Games Association Journal, 32",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Feature-based methods for large scale dynamic programming",
      "author" : [ "J. Tsitsiklis", "B Van Roy" ],
      "venue" : "Machine Learning, 22:59–94",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 1996
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : "6 × 10(60)), and even in the case that the sequence of pieces is known in advance, finding the optimal strategy is an NP hard problem [4].",
      "startOffset" : 134,
      "endOffset" : 137
    }, {
      "referenceID" : 2,
      "context" : "(1)Note that this number is finite because it was shown that Tetris is a game that ends with probability one [3].",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 20,
      "context" : "The first application of ADP in Tetris seems to be by Tsitsiklis and Van Roy [22].",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 0,
      "context" : "Bertsekas and Ioffe [1] proposed the λ-Policy Iteration (λ-PI) algorithm (a generalization of value and policy iteration) and applied it to Tetris.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 15,
      "context" : "The exact same empirical study was revisited recently by Scherrer [16], who corrected an implementation bug in [1], and reported more stable learning curves and the score of 4, 000 lines.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 0,
      "context" : "The exact same empirical study was revisited recently by Scherrer [16], who corrected an implementation bug in [1], and reported more stable learning curves and the score of 4, 000 lines.",
      "startOffset" : 111,
      "endOffset" : 114
    }, {
      "referenceID" : 10,
      "context" : "Kakade [11] applied a natural policy gradient method to Tetris and reported a score of about 6, 800 lines.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 5,
      "context" : "Farias and Van Roy [6] applied a linear programming algorithm to the game and achieved the score of 4, 700 lines.",
      "startOffset" : 19,
      "endOffset" : 22
    }, {
      "referenceID" : 7,
      "context" : "Furmston and Barber [8] proposed an approximate Newton method to search in a policy space and were able to obtain a score of about 14, 000.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 4,
      "context" : "Despite all the above applications of ADP in Tetris (and possibly more), for a long time, the best Tetris controller was the one designed by Dellacherie [5].",
      "startOffset" : 153,
      "endOffset" : 156
    }, {
      "referenceID" : 18,
      "context" : "Dellacherie’s evaluation function is made of 6 high-quality features with weights chosen by hand, and achieved a score of about 5, 000, 000 lines [19].",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 17,
      "context" : "Szita and Lőrincz [18] used the “Bertsekas features” and optimized the weights by running a black box optimizer based on the cross entropy (CE) method [15].",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 14,
      "context" : "Szita and Lőrincz [18] used the “Bertsekas features” and optimized the weights by running a black box optimizer based on the cross entropy (CE) method [15].",
      "startOffset" : 151,
      "endOffset" : 155
    }, {
      "referenceID" : 19,
      "context" : "More recently, Thiery and Scherrer [20] selected a set of 9 features (including those of Dellacherie’s) and optimized the weights with the CE method.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 18,
      "context" : "Due to the high variance of the score and its sensitivity to some implementation details [19], it is difficult to have a precise evaluation of Tetris controllers.",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 17,
      "context" : "However, our brief tour d’horizon of the literature, and in particular the work by Szita and Lőrincz [18] (optimizing the “Bertsekas features” by CE), indicate that ADP algorithms, even with relatively good features, have performed extremely worse than the methods that directly search in the space of policies (such as CE and genetic algorithms).",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 11,
      "context" : "Fortunately a class of such ADP algorithms, called classification-based policy iteration (CbPI), have been recently developed and analyzed [12, 7, 13, 9, 17].",
      "startOffset" : 139,
      "endOffset" : 157
    }, {
      "referenceID" : 6,
      "context" : "Fortunately a class of such ADP algorithms, called classification-based policy iteration (CbPI), have been recently developed and analyzed [12, 7, 13, 9, 17].",
      "startOffset" : 139,
      "endOffset" : 157
    }, {
      "referenceID" : 12,
      "context" : "Fortunately a class of such ADP algorithms, called classification-based policy iteration (CbPI), have been recently developed and analyzed [12, 7, 13, 9, 17].",
      "startOffset" : 139,
      "endOffset" : 157
    }, {
      "referenceID" : 8,
      "context" : "Fortunately a class of such ADP algorithms, called classification-based policy iteration (CbPI), have been recently developed and analyzed [12, 7, 13, 9, 17].",
      "startOffset" : 139,
      "endOffset" : 157
    }, {
      "referenceID" : 16,
      "context" : "Fortunately a class of such ADP algorithms, called classification-based policy iteration (CbPI), have been recently developed and analyzed [12, 7, 13, 9, 17].",
      "startOffset" : 139,
      "endOffset" : 157
    }, {
      "referenceID" : 16,
      "context" : "In this paper, we put our conjecture to test by applying an algorithm in this class, called classification-based modified policy iteration (CBMPI) [17], to the game of Tetris, and compare its performance with the CE method and the λ-PI algorithm.",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 16,
      "context" : "In this section, we briefly describe the algorithms used in our experiments: the cross entropy (CE) method, classification-based modified policy iteration (CBMPI) [17] and its slight variation direct policy iteration (DPI) [13], and λ-policy iteration (see [16] for a description of λ-PI).",
      "startOffset" : 163,
      "endOffset" : 167
    }, {
      "referenceID" : 12,
      "context" : "In this section, we briefly describe the algorithms used in our experiments: the cross entropy (CE) method, classification-based modified policy iteration (CBMPI) [17] and its slight variation direct policy iteration (DPI) [13], and λ-policy iteration (see [16] for a description of λ-PI).",
      "startOffset" : 223,
      "endOffset" : 227
    }, {
      "referenceID" : 15,
      "context" : "In this section, we briefly describe the algorithms used in our experiments: the cross entropy (CE) method, classification-based modified policy iteration (CBMPI) [17] and its slight variation direct policy iteration (DPI) [13], and λ-policy iteration (see [16] for a description of λ-PI).",
      "startOffset" : 257,
      "endOffset" : 261
    }, {
      "referenceID" : 14,
      "context" : "Cross-entropy (CE) [15] is an iterative method whose goal is to optimize a function f parameterized by a vector θ ∈ Θ by direct search in the parameter space Θ.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 17,
      "context" : "Figure 2 contains the pseudo-code of the CE algorithm used in our experiments [18, 20].",
      "startOffset" : 78,
      "endOffset" : 86
    }, {
      "referenceID" : 19,
      "context" : "Figure 2 contains the pseudo-code of the CE algorithm used in our experiments [18, 20].",
      "startOffset" : 78,
      "endOffset" : 86
    }, {
      "referenceID" : 13,
      "context" : "Modified policy iteration (MPI) [14] is an iterative algorithm to compute the optimal policy of a MDP that starts with initial policy π1 and value v0, and generates a sequence of value-policy pairs vk = (Tπk) vk−1 (evaluation step), πk+1 = G � (Tπk) vk−1 � (greedy step), where Gvk is a greedy policy w.",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 16,
      "context" : "CBMPI [17] is an approximation of MPI that uses an explicit representation for the policies πk, in addition to the one used for the value functions vk.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 11,
      "context" : "The idea is similar to the classification-based PI algorithms [12, 7, 13] in which we search for the greedy policy in a policy space Π (defined by a classifier) instead of computing it from the estimated value function (as in the standard implementation of MPI).",
      "startOffset" : 62,
      "endOffset" : 73
    }, {
      "referenceID" : 6,
      "context" : "The idea is similar to the classification-based PI algorithms [12, 7, 13] in which we search for the greedy policy in a policy space Π (defined by a classifier) instead of computing it from the estimated value function (as in the standard implementation of MPI).",
      "startOffset" : 62,
      "endOffset" : 73
    }, {
      "referenceID" : 12,
      "context" : "The idea is similar to the classification-based PI algorithms [12, 7, 13] in which we search for the greedy policy in a policy space Π (defined by a classifier) instead of computing it from the estimated value function (as in the standard implementation of MPI).",
      "startOffset" : 62,
      "endOffset" : 73
    }, {
      "referenceID" : 12,
      "context" : "If we remove the regressor from CBMPI and only use the m-truncated rollouts R k(s , a) = �m t=0 γ r (i,j) t to compute � Qk(s, a), then CBMPI become the direct policy iteration (DPI) algorithm [13] that we also use in our experiments (see [17] for more details on the CBMPI algorithm).",
      "startOffset" : 193,
      "endOffset" : 197
    }, {
      "referenceID" : 16,
      "context" : "If we remove the regressor from CBMPI and only use the m-truncated rollouts R k(s , a) = �m t=0 γ r (i,j) t to compute � Qk(s, a), then CBMPI become the direct policy iteration (DPI) algorithm [13] that we also use in our experiments (see [17] for more details on the CBMPI algorithm).",
      "startOffset" : 239,
      "endOffset" : 243
    }, {
      "referenceID" : 9,
      "context" : "We compute the next policy πk+1 by minimizing the empirical error � LΠ k (� μ;πu), defined by (3), using the covariance matrix adaptation evolution strategy (CMA-ES) algorithm [10].",
      "startOffset" : 176,
      "endOffset" : 180
    }, {
      "referenceID" : 17,
      "context" : "CE is the state-of-the-art method in Tetris with huge performance advantage over ADP/RL methods [18, 19, 20].",
      "startOffset" : 96,
      "endOffset" : 108
    }, {
      "referenceID" : 18,
      "context" : "CE is the state-of-the-art method in Tetris with huge performance advantage over ADP/RL methods [18, 19, 20].",
      "startOffset" : 96,
      "endOffset" : 108
    }, {
      "referenceID" : 19,
      "context" : "CE is the state-of-the-art method in Tetris with huge performance advantage over ADP/RL methods [18, 19, 20].",
      "startOffset" : 96,
      "endOffset" : 108
    }, {
      "referenceID" : 19,
      "context" : "We sample the rollout states in CBMPI/DPI from the trajectories generated by a very good policy for Tetris, namely the DU controller [20].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 19,
      "context" : "1 and η = 4, the best parameters reported in [20].",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 1,
      "context" : "Set of Features: We use the following features, plus a constant offset feature, in our experiments:4 (i) Bertsekas features: First introduced by [2], this set of 22 features has been mainly used in the ADP/RL community and consists of: the number of holes in the board, the height of each column, the difference in height between two consecutive columns, and the maximum height of the board.",
      "startOffset" : 145,
      "endOffset" : 148
    }, {
      "referenceID" : 4,
      "context" : "(ii) Dellacherie-Thiery (D-T) features: This set consists of the six features of Dellacherie [5], i.",
      "startOffset" : 93,
      "endOffset" : 96
    }, {
      "referenceID" : 19,
      "context" : ", the landing height of the falling piece, the number of eroded piece cells, the row transitions, the column transitions, the number of holes, and the number of board wells; plus 3 additional features proposed in [20], i.",
      "startOffset" : 213,
      "endOffset" : 217
    }, {
      "referenceID" : 18,
      "context" : "For a precise definition of the features, see [19] or the documentation of their code [21].",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 19,
      "context" : ", DU and BDU [20] in both small and large boards in Table 1.",
      "startOffset" : 13,
      "endOffset" : 17
    } ],
    "year" : 2013,
    "abstractText" : "Tetris is a video game that has been widely used as a benchmark for various optimization techniques including approximate dynamic programming (ADP) algorithms. A look at the literature of this game shows that while ADP algorithms that have been (almost) entirely based on approximating the value function (value function based) have performed poorly in Tetris, the methods that search directly in the space of policies by learning the policy parameters using an optimization black box, such as the cross entropy (CE) method, have achieved the best reported results. This makes us conjecture that Tetris is a game in which good policies are easier to represent, and thus, learn than their corresponding value functions. So, in order to obtain a good performance with ADP, we should use ADP algorithms that search in a policy space, instead of the more traditional ones that search in a value function space. In this paper, we put our conjecture to test by applying such an ADP algorithm, called classification-based modified policy iteration (CBMPI), to the game of Tetris. Our experimental results show that for the first time an ADP algorithm, namely CBMPI, obtains the best results reported in the literature for Tetris in both small 10 × 10 and large 10 × 20 boards. Although the CBMPI’s results are similar to those of the CE method in the large board, CBMPI uses considerably fewer (almost 1/6) samples (calls to the generative model) than CE.",
    "creator" : null
  }
}