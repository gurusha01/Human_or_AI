{
  "name" : "903ce9225fca3e988c2af215d4e544d3.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "More data speeds up training time in learning halfspaces over sparse vectors",
    "authors" : [ "Amit Daniely" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "( n/ 2 ) examples.\nOur main contribution is a novel, non-cryptographic, methodology for establishing computational-statistical gaps, which allows us to show that, under a widely believed assumption that refuting random 3CNF formulas is hard, it is impossible to efficiently learn this class using only O ( n/ 2 ) examples. We further show that\nunder stronger hardness assumptions, even O ( n1.499/ 2 ) examples do not suffice. On the other hand, we show a new algorithm that learns this class efficiently using Ω̃ ( n2/ 2 ) examples. This formally establishes the tradeoff between sample and computational complexity for a natural supervised learning problem."
    }, {
      "heading" : "1 Introduction",
      "text" : "In the modern digital period, we are facing a rapid growth of available datasets in science and technology. In most computing tasks (e.g. storing and searching in such datasets), large datasets are a burden and require more computation. However, for learning tasks the situation is radically different. A simple observation is that more data can never hinder you from performing a task. If you have more data than you need, just ignore it!\nA basic question is how to learn from “big data”. The statistical learning literature classically studies questions like “how much data is needed to perform a learning task?” or “how does accuracy improve as the amount of data grows?” etc. In the modern, “data revolution era”, it is often the case that the amount of data available far exceeds the information theoretic requirements. We can wonder whether this, seemingly redundant data, can be used for other purposes. An intriguing question in this vein, studied recently by several researchers ([Decatur et al., 1998, Servedio., 2000, Shalev-Shwartz et al., 2012, Berthet and Rigollet, 2013, Chandrasekaran and Jordan, 2013]), is the following\nQuestion 1: Are there any learning tasks in which more data, beyond the information theoretic barrier, can provably be leveraged to speed up computation time?\nThe main contributions of this work are:\n• Conditioning on the hardness of refuting random 3CNF formulas, we give the first example of a natural supervised learning problem for which the answer to Question 1 is positive. • To prove this, we present a novel technique to establish computational-statistical tradeoffs\nin supervised learning problems. To the best of our knowledge, this is the first such a result that is not based on cryptographic primitives.\nAdditional contributions are non trivial efficient algorithms for learning halfspaces over 2-sparse and 3-sparse vectors using Õ ( n 2 ) and Õ ( n2 2 ) examples respectively.\nThe natural learning problem we consider is the task of learning the class of halfspaces over k-sparse vectors. Here, the instance space is the space of k-sparse vectors,\nCn,k = {x ∈ {−1, 1, 0}n | |{i | xi 6= 0}| ≤ k} , and the hypothesis class is halfspaces over k-sparse vectors, namely\nHn,k = {hw,b : Cn,k → {±1} | hw,b(x) = sign(〈w, x〉+ b), w ∈ Rn, b ∈ R} , where 〈·, ·〉 denotes the standard inner product in Rn. We consider the standard setting of agnostic PAC learning, which models the realistic scenario where the labels are not necessarily fully determined by some hypothesis from Hn,k. Note that in the realizable case, i.e. when some hypothesis from Hn,k has zero error, the problem of learning halfspaces is easy even over Rn.\nIn addition, we allow improper learning (a.k.a. representation independent learning), namely, the learning algorithm is not restricted to output a hypothesis from Hn,k, but only should output a hypothesis whose error is not much larger than the error of the best hypothesis inHn,k. This gives the learner a lot of flexibility in choosing an appropriate representation of the problem. This additional freedom to the learner makes it much harder to prove lower bounds in this model. Concretely, it is not clear how to use standard reductions from NP hard problems in order to establish lower bounds for improper learning (moreover, Applebaum et al. [2008] give evidence that such simple reductions do not exist).\nThe classesHn,k and similar classes have been studied by several authors (e.g. Long. and Servedio [2013]). They naturally arise in learning scenarios in which the set of all possible features is very large, but each example has only a small number of active features. For example:\n• Predicting an advertisement based on a search query: Here, the possible features of each instance are all English words, whereas the active features are only the set of words given in the query.\n• Learning Preferences [Hazan et al., 2012]: Here, we have n players. A ranking of the players is a permutation σ : [n] → [n] (think of σ(i) as the rank of the i’th player). Each ranking induces a preference hσ over the ordered pairs, such that hσ(i, j) = 1 iff i is ranked higher that j. Namely,\nhσ(i, j) =\n{ 1 σ(i) > σ(j)\n−1 σ(i) < σ(j) The objective here is to learn the class, Pn, of all possible preferences. The problem of learning preferences is related to the problem of learning Hn,2: if we associate each pair (i, j) with the vector in Cn,2 whose i’th coordinate is 1 and whose j’th coordinate is −1, it is not hard to see that Pn ⊂ Hn,2: for every σ, hσ = hw,0 for the vector w ∈ Rn, given by wi = σ(i). Therefore, every upper bound for Hn,2 implies an upper bound for Pn, while every lower bound for Pn implies a lower bound for Hn,2. Since VC(Pn) = n and VC(Hn,2) = n + 1, the information theoretic barrier to learn these classes is Θ ( n 2 ) .\nIn Hazan et al. [2012] it was shown that Pn can be efficiently learnt using O ( n log3(n) 2 ) examples. In section 4, we extend this result toHn,2.\nWe will show a positive answer to Question 1 for the classHn,3. To do so, we show1 the following: 1In fact, similar results hold for every constant k ≥ 3. Indeed, since Hn,3 ⊂ Hn,k for every k ≥ 3, it is trivial that item 3 below holds for every k ≥ 3. The upper bound given in item 1 holds for every k. For item 2,\n1. Ignoring computational issues, it is possible to learn the classHn,3 usingO ( n 2 ) examples.\n2. It is also possible to efficiently learn Hn,3 if we are provided with a larger training set (of size Ω̃ ( n2\n2\n) ). This is formalized in Theorem 3.1.\n3. It is impossible to efficiently learn Hn,3, if we are only provided with a training set of size O ( n 2 ) under Feige’s assumption regarding the hardness of refuting random 3CNF\nformulas [Feige, 2002]. Furthermore, for every α ∈ [0, 0.5), it is impossible to learn efficiently with a training set of sizeO ( n1+α\n2\n) under a stronger hardness assumption. This\nis formalized in Theorem 4.1.\nA graphical illustration of our main results is given below:\nruntime\n2O(n)\n> poly(n)\nnO(1)\nexamples n2n1.5n\nThe proof of item 1 above is easy – simply note that Hn,3 has VC dimension n+ 1.\nItem 2 is proved in section 4, relying on the results of Hazan et al. [2012]. We note, however, that a weaker result, that still suffices for answering Question 1 in the affirmative, can be proven using a naive improper learning algorithm. In particular, we show below how to learn Hn,3 efficiently with a sample of Ω ( n3\n2 ) examples. The idea is to replace the class Hn,3 with the class {±1}Cn,3\ncontaining all functions from Cn,3 to {±1}. Clearly, this class contains Hn,3. In addition, we can efficiently find a function f that minimizes the empirical training error over a training set S as follows: For every x ∈ Cn,k, if x does not appear at all in the training set we will set f(x) arbitrarily to 1. Otherwise, we will set f(x) to be the majority of the labels in the training set that correspond to x. Finally, note that the VC dimension of {±1}Cn,3 is smaller than n3 (since |Cn,3| < n3). Hence, standard generalization results (e.g. Vapnik [1995]) implies that a training set size of Ω ( n3\n2\n) suffices for learning this class.\nItem 3 is shown in section 3 by presenting a novel technique for establishing statisticalcomputational tradeoffs.\nThe class Hn,2. Our main result gives a positive answer to Question 1 for the task of improperly learning Hn,k for k ≥ 3. A natural question is what happens for k = 2 and k = 1. Since VC(Hn,1) = VC(Hn,2) = n + 1, the information theoretic barrier for learning these classes is Θ ( n 2 ) . In section 4, we prove that Hn,2 (and, consequently, Hn,1 ⊂ Hn,2) can be learnt using\nO ( n log3(n)\n2\n) examples, indicating that significant computational-statistical tradeoffs start to mani-\nfest themselves only for k ≥ 3."
    }, {
      "heading" : "1.1 Previous approaches, difficulties, and our techniques",
      "text" : "[Decatur et al., 1998] and [Servedio., 2000] gave positive answers to Question 1 in the realizable PAC learning model. Under cryptographic assumptions, they showed that there exist binary learning problems, in which more data can provably be used to speed up training time. [Shalev-Shwartz et al., 2012] showed a similar result for the agnostic PAC learning model. In all of these papers, the main idea is to construct a hypothesis class based on a one-way function. However, the constructed it is not hard to show thatHn,k can be learnt using a sample of Ω ( nk 2 ) examples by a naive improper learning\nalgorithm, similar to the algorithm we describe in this section for k = 3.\nclasses are of a very synthetic nature, and are of almost no practical interest. This is mainly due to the construction technique which is based on one way functions. In this work, instead of using cryptographic assumptions, we rely on the hardness of refuting random 3CNF formulas. The simplicity and flexibility of 3CNF formulas enable us to derive lower bounds for natural classes such as halfspaces.\nRecently, [Berthet and Rigollet, 2013] gave a positive answer to Question 1 in the context of unsupervised learning. Concretely, they studied the problem of sparse PCA, namely, finding a sparse vector that maximizes the variance of an unsupervised data. Conditioning on the hardness of the planted clique problem, they gave a positive answer to Question 1 for sparse PCA. Our work, as well as the previous work of Decatur et al. [1998], Servedio. [2000], Shalev-Shwartz et al. [2012], studies Question 1 in the supervised learning setup. We emphasize that unsupervised learning problems are radically different than supervised learning problems in the context of deriving lower bounds. The main reason for the difference is that in supervised learning problems, the learner is allowed to employ improper learning, which gives it a lot of power in choosing an adequate representation of the data. For example, the upper bound we have derived for the class of sparse halfspaces switched from representing hypotheses as halfspaces to representation of hypotheses as tables over Cn,3, which made the learning problem easy from the computational perspective. The crux of the difficulty in constructing lower bounds is due to this freedom of the learner in choosing a convenient representation. This difficulty does not arise in the problem of sparse PCA detection, since there the learner must output a good sparse vector. Therefore, it is not clear whether the approach given in [Berthet and Rigollet, 2013] can be used to establish computational-statistical gaps in supervised learning problems."
    }, {
      "heading" : "2 Background and notation",
      "text" : "For hypothesis class H ⊂ {±1}X and a set Y ⊂ X , we define the restriction of H to Y by H|Y = {h|Y | h ∈ H}. We denote by J = Jn the all-ones n× n matrix. We denote the j’th vector in the standard basis of Rn by ej ."
    }, {
      "heading" : "2.1 Learning Algorithms",
      "text" : "For h : Cn,3 → {±1} and a distribution D on Cn,3 × {±1} we denote the error of h w.r.t. D by ErrD(h) = Pr(x,y)∼D (h(x) 6= y). For H ⊂ {±1}Cn,3 we denote the error of H w.r.t. D by ErrD(H) = minh∈H ErrD(h). For a sample S ∈ (Cn,3 × {±1})m we denote by ErrS(h) (resp. ErrS(H)) the error of h (resp. H) w.r.t. the empirical distribution induces by the sample S. A learning algorithm, L, receives a sample S ∈ (Cn,3 × {±1})m and return a hypothesis L(S) : Cn,3 → {±1}. We say that L learns Hn,3 using m(n, ) examples if,2 for every distribution D on Cn,3 × {±1} and a sample S of more than m(n, ) i.i.d. examples drawn from D,\nPr S\n(ErrD(L(S)) > ErrD(H3,n) + ) < 1\n10\nThe algorithm L is efficient if it runs in polynomial time in the sample size and returns a hypothesis that can be evaluated in polynomial time.\n2.2 Refuting random 3SAT formulas\nWe frequently view a boolean assignment to variables x1, . . . , xn as a vector in Rn. It is convenient, therefore, to assume that boolean variables take values in {±1} and to denote negation by “ − ” (instead of the usual “¬”). An n-variables 3CNF clause is a boolean formula of the form\nC(x) = (−1)j1xi1 ∨ (−1)j2xi2 ∨ (−1)j1xi3 , x ∈ {±1}n\nAn n-variables 3CNF formula is a boolean formula of the form\nφ(x) = ∧mi=1Ci(x) , 2For simplicity, we require the algorithm to succeed with probability of at least 9/10. This can be easily amplified to probability of at least 1 − δ, as in the usual definition of agnostic PAC learning, while increasing the sample complexity by a factor of log(1/δ).\nwhere every Ci is a 3CNF clause. Define the value, Val(φ), of φ as the maximal fraction of clauses that can be simultaneously satisfied. If Val(φ) = 1, we say the φ is satisfiable. By 3CNFn,m we denote the set of 3CNF formulas with n variables and m clauses.\nRefuting random 3CNF formulas has been studied extensively (see e.g. a special issue of TCS Dubios et al. [2001]). It is known that for large enough ∆ (∆ = 6 will suffice) a random formula in 3CNFn,∆n is not satisfiable with probability 1− o(1). Moreover, for every 0 ≤ < 14 , and a large enough ∆ = ∆( ), the value of a random formula 3CNFn,∆n is ≤ 1− with probability 1− o(1). The problem of refuting random 3CNF concerns efficient algorithms that provide a proof that a random 3CNF is not satisfiable, or far from being satisfiable. This can be thought of as a game between an adversary and an algorithm. The adversary should produce a 3CNF-formula. It can either produce a satisfiable formula, or, produce a formula uniformly at random. The algorithm should identify whether the produced formula is random or satisfiable.\nFormally, let ∆ : N → N and 0 ≤ < 14 . We say that an efficient algorithm, A, -refutes random 3CNF with ratio ∆ if its input is φ ∈ 3CNFn,n∆(n), its output is either “typical” or “exceptional” and it satisfies:\n• Soundness: If Val(φ) ≥ 1− , then\nPr Rand. coins ofA (A(φ) = “exceptional”) ≥ 3 4\n• Completeness: For every n,\nPr Rand. coins ofA, φ∼Uni(3CNFn,n∆(n))\n(A(φ) = “typical”) ≥ 1− o(1)\nBy a standard repetition argument, the probability of 34 can be amplified to 1−2 −n, while efficiency is preserved. Thus, given such an (amplified) algorithm, if A(φ) = “typical”, then with confidence of 1− 2−n we know that Val(φ) < 1− . Since for random φ ∈ 3CNFn,n∆(n), A(φ) = “typical” with probability 1 − o(1), such an algorithm provides, for most 3CNF formulas a proof that their value is less that 1− . Note that an algorithm that -refutes random 3CNF with ratio ∆ also ′-refutes random 3CNF with ratio ∆ for every 0 ≤ ′ ≤ . Thus, the task of refuting random 3CNF’s gets easier as gets smaller. Most of the research concerns the case = 0. Here, it is not hard to see that the task is getting easier as ∆ grows. The best known algorithm [Feige and Ofek, 2007] 0-refutes random 3CNF with ratio ∆(n) = Ω( √ n). In Feige [2002] it was conjectured that for constant ∆ no efficient algorithm can provide a proof that a random 3CNF is not satisfiable:\nConjecture 2.1 (R3SAT hardness assumption – [Feige, 2002]). For every > 0 and for every large enough integer ∆ > ∆0( ) there exists no efficient algorithm that -refutes random 3CNF formulas with ratio ∆.\nIn fact, for all we know, the following conjecture may be true for every 0 ≤ µ ≤ 0.5. Conjecture 2.2 (µ-R3SAT hardness assumption). For every > 0 and for every integer ∆ > ∆0( ) there exists no efficient algorithm that -refutes random 3CNF with ratio ∆ · nµ.\nNote that Feige’s conjecture is equivalent to the 0-R3SAT hardness assumption.\n3 Lower bounds for learningHn,3\nTheorem 3.1 (main). Let 0 ≤ µ ≤ 0.5. If the µ-R3SAT hardness assumption (conjecture 2.2) is true, then there exists no efficient learning algorithm that learns the class Hn,3 using O\n( n1+µ\n2 ) examples.\nIn the proof of Theorem 3.1 we rely on the validity of a conjecture, similar to conjecture 2.2 for 3- variables majority formulas. Following an argument from [Feige, 2002] (Theorem 3.2) the validity of the conjecture on which we rely for majority formulas follows the validity of conjecture 2.2.\nDefine ∀(x1, x2, x3) ∈ {±1}3, MAJ(x1, x2, x3) := sign(x1 + x2 + x3)\nAn n-variables 3MAJ clause is a boolean formula of the form\nC(x) = MAJ((−1)j1xi1 , (−1)j2xi2 , (−1)j1xi3), x ∈ {±1}n\nAn n-variables 3MAJ formula is a boolean formula of the form\nφ(x) = ∧mi=1Ci(x) where theCi’s are 3MAJ clauses. By 3MAJn,m we denote the set of 3MAJ formulas with n variables and m clauses. Theorem 3.2 ([Feige, 2002]). Let 0 ≤ µ ≤ 0.5. If the µ-R3SAT hardness assumption is true, then for every > 0 and for every large enough integer ∆ > ∆0( ) there exists no efficient algorithm with the following properties.\n• Its input is φ ∈ 3MAJn,∆n1+µ , and its output is either “typical” or “exceptional”.\n• If Val(φ) ≥ 34 − , then\nPr Rand. coins ofA (A(φ) = “exceptional”) ≥ 3 4\n• For every n, Pr\nRand. coins ofA, φ∼Uni(3MAJn,∆n1+µ ) (A(φ) = “typical”) ≥ 1− o(1)\nNext, we prove Theorem 3.1. In fact, we will prove a slightly stronger result. Namely, define the subclass Hdn,3 ⊂ Hn,3, of homogenous halfspaces with binary weights, given by Hdn,3 = {hw,0 | w ∈ {±1}n}. As we show, under the µ-R3SAT hardness assumption, it is impossible to efficiently learn this subclass using only O ( n1+µ\n2\n) examples.\nProof idea: We will reduce the task of refuting random 3MAJ formulas with linear number of clauses to the task of (improperly) learningHdn,3 with linear number of samples. The first step will be to construct a transformation that associates every 3MAJ clause with two examples in Cn,3×{±1}, and every assignment with a hypothesis in Hdn,3. As we will show, the hypothesis corresponding to an assignment ψ is correct on the two examples corresponding to a clause C if and only if ψ satisfies C. With that interpretation at hand, every 3MAJ formula φ can be thought of as a distribution Dφ on Cn,3 × {±1}, which is the empirical distribution induced by ψ’s clauses. It holds furthermore that ErrDφ(Hdn,3) = 1−Val(φ).\nSuppose now that we are given an efficient learning algorithm for Hdn,3, that uses κ n 2 examples, for some κ > 0. To construct an efficient algorithm for refuting 3MAJ-formulas, we simply feed the learning algorithm with κ n0.012 examples drawn from Dφ and answer “exceptional” if the error of the hypothesis returned by the algorithm is small. If φ is (almost) satisfiable, the algorithm is guaranteed to return a hypothesis with a small error. On the other hand, if φ is far from being satisfiable, ErrDφ(Hdn,3) is large. If the learning algorithm is proper, then it must return a hypothesis from Hdn,3 and therefore it would necessarily return a hypothesis with a large error. This argument can be used to show that, unless NP = RP , learning Hdn,3 with a proper efficient algorithm is impossible. However, here we want to rule out improper algorithms as well.\nThe crux of the construction is that if φ is random, no algorithm (even improper and even inefficient) can return a hypothesis with a small error. The reason for that is that since the sample provided to the algorithm consists of only κ n0.012 samples, the algorithm won’t see most of ψ’s clauses, and, consequently, the produced hypothesis h will be independent of them. Since these clauses are random, h is likely to err on about half of them, so that ErrDφ(h) will be close to half!\nTo summarize we constructed an efficient algorithm with the following properties: if φ is almost satisfiable, the algorithm will return a hypothesis with a small error, and then we will declare “exceptional”, while for random φ, the algorithm will return a hypothesis with a large error, and we will declare “typical”.\nOur construction crucially relies on the restriction to learning algorithm with a small sample complexity. Indeed, if the learning algorithm obtains more than n1+µ examples, then it will see most of ψ’s clauses, and therefore it might succeed in “learning” even when the source of the formula is random. Therefore, we will declare “exceptional” even when the source is random.\nProof. (of theorem 3.1) Assume by way of contradiction that the µ-R3SAT hardness assumption is true and yet there exists an efficient learning algorithm that learns the class Hn,3 using O\n( n1+µ\n2 ) examples. Setting = 1100 , we conclude that there exists an efficient algorithm L and a constant κ > 0 such that given a sample S of more than κ · n1+µ examples drawn from a distribution D on Cn,3 × {±1}, returns a classifier L(S) : Cn,3 → {±1} such that\n• L(S) can be evaluated efficiently.\n• W.p. ≥ 34 over the choice of S, ErrD(L(S)) ≤ ErrD(Hn,3) + 1 100 .\nFix ∆ large enough such that ∆ > 100κ and the conclusion of Theorem 3.2 holds with = 1100 . We will construct an algorithm, A, contradicting Theorem 3.2. On input φ ∈ 3MAJn,∆n1+µ consisting of the 3MAJ clauses C1, . . . , C∆n1+µ , the algorithm A proceeds as follows\n1. Generate a sample S consisting of ∆n1+µ examples as follows. For every clause, Ck = MAJ((−1)j1xi1 , (−1)j2xi2 , (−1)j3xi3), generate an example (xk, yk) ∈ Cn,3 × {±1} by choosing b ∈ {±1} at random and letting\n(xk, yk) = b · ( 3∑ l=1 (−1)jleil , 1 ) ∈ Cn,3 × {±1} .\nFor example, if n = 6, the clause is MAJ(−x2, x3, x6) and b = −1, we generate the example\n((0, 1,−1, 0, 0,−1),−1)\n2. Choose a sample S1 consisting of ∆n 1+µ 100 ≥ κ · n 1+µ examples by choosing at random\n(with repetitions) examples from S.\n3. Let h = L(S1). If ErrS(h) ≤ 38 , return “exceptional”. Otherwise, return “typical”.\nWe claim that A contradicts Theorem 3.2. Clearly, A runs in polynomial time. It remains to show that\n• If Val(φ) ≥ 34 − 1 100 , then\nPr Rand. coins ofA (A(φ) = “exceptional”) ≥ 3 4\n• For every n,\nPr Rand. coins ofA, φ∼Uni(3MAJn,∆n1+µ )\n(A(φ) = “typical”) ≥ 1− o(1)\nAssume first that φ ∈ 3MAJn,∆n1+µ is chosen at random. Given the sample S1, the sample S2 := S \\S1 is a sample of |S2| i.i.d. examples which are independent from the sample S1, and hence also from h = L(S1). Moreover, for every example (xk, yk) ∈ S2, yk is a Bernoulli random variable with parameter 12 which is independent of xk. To see that, note that an example whose instance is xk can be generated by exactly two clauses – one corresponds to yk = 1, while the other corresponds to yk = −1 (e.g., the instance (1,−1, 0, 1) can be generated from the clause MAJ(x1,−x2, x4) and b = 1 or the clause MAJ(−x1, x2,−x4) and b = −1). Thus, given the instance xk, the probability that yk = 1 is 12 , independent of xk.\nIt follows that ErrS2(h) is an average of at least ( 1− 1100 ) ∆n1+µ independent Bernoulli random variable. By Chernoff’s bound, with probability ≥ 1− o(1), ErrS2(h) > 12 − 1 100 . Thus,\nErrS(h) ≥ (\n1− 1 100\n) ErrS2(h) ≥ ( 1− 1\n100\n) · ( 1\n2 − 1 100\n) > 3\n8\nAnd the algorithm will output “typical”.\nAssume now that Val(φ) ≥ 34 − 1 100 and let ψ ∈ {±1} n be an assignment that indicates that. Let Ψ ∈ Hn,3 be the hypothesis Ψ(x) = sign (〈ψ, x〉). It can be easily checked that Ψ(xk) = yk if and only if ψ satisfies Ck. Since Val(φ) ≥ 34 − 1 100 , it follows that\nErrS(Ψ) ≤ 1\n4 +\n1\n100 .\nThus,\nErrS(Hn,3) ≤ 1\n4 +\n1\n100 .\nBy the choice of L, with probability ≥ 1− 14 = 3 4 ,\nErrS(h) ≤ 1\n4 +\n1\n100 +\n1\n100 <\n3\n8\nand the algorithm will return “exceptional”.\n4 Upper bounds for learningHn,2 andHn,3\nThe following theorem derives upper bounds for learning Hn,2 and Hn,3. Its proof relies on results from Hazan et al. [2012] about learning β-decomposable matrices, and due to the lack of space is given in the appendix. Theorem 4.1.\n• There exists an efficient algorithm that learnsHn,2 using O ( n log3(n) 2 ) examples\n• There exists an efficient algorithm that learnsHn,3 using O ( n2 log3(n) 2 ) examples"
    }, {
      "heading" : "5 Discussion",
      "text" : "We formally established a computational-sample complexity tradeoff for the task of (agnostically and improperly) PAC learning of halfspaces over 3-sparse vectors. Our proof of the lower bound relies on a novel, non cryptographic, technique for establishing such tradeoffs. We also derive a new non-trivial upper bound for this task.\nOpen questions. An obvious open question is to close the gap between the lower and upper bounds. We conjecture that Hn,3 can be learnt efficiently using a sample of Õ\n( n1.5\n2\n) examples. Also, we\nbelieve that our new proof technique can be used for establishing computational-sample complexity tradeoffs for other natural learning problems.\nAcknowledgements: Amit Daniely is a recipient of the Google Europe Fellowship in Learning Theory, and this research is supported in part by this Google Fellowship. Nati Linial is supported by grants from ISF, BSF and I-Core. Shai Shalev-Shwartz is supported by the Israeli Science Foundation grant number 590-10."
    } ],
    "references" : [ {
      "title" : "On basing lower-bounds for learning on worstcase assumptions",
      "author" : [ "Benny Applebaum", "Boaz Barak", "David Xiao" ],
      "venue" : "In Foundations of Computer Science,",
      "citeRegEx" : "Applebaum et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Applebaum et al\\.",
      "year" : 2008
    }, {
      "title" : "Complexity theoretic lower bounds for sparse principal component detection",
      "author" : [ "Quentin Berthet", "Philippe Rigollet" ],
      "venue" : "In COLT,",
      "citeRegEx" : "Berthet and Rigollet.,? \\Q2013\\E",
      "shortCiteRegEx" : "Berthet and Rigollet.",
      "year" : 2013
    }, {
      "title" : "On the generalization ability of on-line learning algorithms",
      "author" : [ "Nicolo Cesa-Bianchi", "Alex Conconi", "Claudio Gentile" ],
      "venue" : "IEEE Transactions on Information Theory,",
      "citeRegEx" : "Cesa.Bianchi et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Cesa.Bianchi et al\\.",
      "year" : 2001
    }, {
      "title" : "Computational and statistical tradeoffs via convex relaxation",
      "author" : [ "Venkat Chandrasekaran", "Michael I. Jordan" ],
      "venue" : "Proceedings of the National Academy of Sciences,",
      "citeRegEx" : "Chandrasekaran and Jordan.,? \\Q2013\\E",
      "shortCiteRegEx" : "Chandrasekaran and Jordan.",
      "year" : 2013
    }, {
      "title" : "Computational sample complexity",
      "author" : [ "S. Decatur", "O. Goldreich", "D. Ron" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "Decatur et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Decatur et al\\.",
      "year" : 1998
    }, {
      "title" : "Zecchina (Guest Editors)",
      "author" : [ "O. Dubios", "R. Monasson", "B. Selma" ],
      "venue" : "Phase Transitions in Combinatorial Problems. Theoretical Computer Science,",
      "citeRegEx" : "Dubios et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Dubios et al\\.",
      "year" : 2001
    }, {
      "title" : "Relations between average case complexity and approximation complexity",
      "author" : [ "U. Feige" ],
      "venue" : "In STOC, pages 534–543,",
      "citeRegEx" : "Feige.,? \\Q2002\\E",
      "shortCiteRegEx" : "Feige.",
      "year" : 2002
    }, {
      "title" : "Easily refutable subformulas of large random 3cnf formulas",
      "author" : [ "Uriel Feige", "Eran Ofek" ],
      "venue" : "Theory of Computing,",
      "citeRegEx" : "Feige and Ofek.,? \\Q2007\\E",
      "shortCiteRegEx" : "Feige and Ofek.",
      "year" : 2007
    }, {
      "title" : "Near-optimal algorithms for online matrix prediction",
      "author" : [ "E. Hazan", "S. Kale", "S. Shalev-Shwartz" ],
      "venue" : "In COLT,",
      "citeRegEx" : "Hazan et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hazan et al\\.",
      "year" : 2012
    }, {
      "title" : "Low-weight halfspaces for sparse boolean vectors",
      "author" : [ "P. Long", "R. Servedio" ],
      "venue" : "ITCS,",
      "citeRegEx" : "Long. and Servedio.,? \\Q2013\\E",
      "shortCiteRegEx" : "Long. and Servedio.",
      "year" : 2013
    }, {
      "title" : "Computational sample complexity and attribute-efficient learning",
      "author" : [ "R. Servedio" ],
      "venue" : "J. of Comput. Syst. Sci.,",
      "citeRegEx" : "Servedio.,? \\Q2000\\E",
      "shortCiteRegEx" : "Servedio.",
      "year" : 2000
    }, {
      "title" : "Using more data to speed-up training time",
      "author" : [ "Shai Shalev-Shwartz", "Ohad Shamir", "Eran Tromer" ],
      "venue" : "In AISTATS,",
      "citeRegEx" : "Shalev.Shwartz et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Shalev.Shwartz et al\\.",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "• Learning Preferences [Hazan et al., 2012]: Here, we have n players.",
      "startOffset" : 23,
      "endOffset" : 43
    }, {
      "referenceID" : 6,
      "context" : "It is impossible to efficiently learn Hn,3, if we are only provided with a training set of size O ( n 2 ) under Feige’s assumption regarding the hardness of refuting random 3CNF formulas [Feige, 2002].",
      "startOffset" : 187,
      "endOffset" : 200
    }, {
      "referenceID" : 10,
      "context" : ", 1998] and [Servedio., 2000] gave positive answers to Question 1 in the realizable PAC learning model.",
      "startOffset" : 12,
      "endOffset" : 29
    }, {
      "referenceID" : 11,
      "context" : "[Shalev-Shwartz et al., 2012] showed a similar result for the agnostic PAC learning model.",
      "startOffset" : 0,
      "endOffset" : 29
    }, {
      "referenceID" : 1,
      "context" : "Recently, [Berthet and Rigollet, 2013] gave a positive answer to Question 1 in the context of unsupervised learning.",
      "startOffset" : 10,
      "endOffset" : 38
    }, {
      "referenceID" : 1,
      "context" : "Therefore, it is not clear whether the approach given in [Berthet and Rigollet, 2013] can be used to establish computational-statistical gaps in supervised learning problems.",
      "startOffset" : 57,
      "endOffset" : 85
    }, {
      "referenceID" : 7,
      "context" : "The best known algorithm [Feige and Ofek, 2007] 0-refutes random 3CNF with ratio ∆(n) = Ω( √ n).",
      "startOffset" : 25,
      "endOffset" : 47
    }, {
      "referenceID" : 6,
      "context" : "Following an argument from [Feige, 2002] (Theorem 3.",
      "startOffset" : 27,
      "endOffset" : 40
    } ],
    "year" : 2013,
    "abstractText" : "The increased availability of data in recent years has led several authors to ask whether it is possible to use data as a computational resource. That is, if more data is available, beyond the sample complexity limit, is it possible to use the extra examples to speed up the computation time required to perform the learning task? We give the first positive answer to this question for a natural supervised learning problem — we consider agnostic PAC learning of halfspaces over 3-sparse vectors in {−1, 1, 0}. This class is inefficiently learnable using O ( n/ 2 ) examples. Our main contribution is a novel, non-cryptographic, methodology for establishing computational-statistical gaps, which allows us to show that, under a widely believed assumption that refuting random 3CNF formulas is hard, it is impossible to efficiently learn this class using only O ( n/ 2 ) examples. We further show that under stronger hardness assumptions, even O ( n/ 2 ) examples do not suffice. On the other hand, we show a new algorithm that learns this class efficiently using Ω̃ ( n/ 2 ) examples. This formally establishes the tradeoff between sample and computational complexity for a natural supervised learning problem.",
    "creator" : null
  }
}