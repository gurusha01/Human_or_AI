{
  "name" : "e369853df766fa44e1ed0ff613f563bd.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Logarithmic Time Online Multiclass prediction",
    "authors" : [ "Anna Choromanska", "John Langford" ],
    "emails" : [ "achoroma@cims.nyu.edu", "jcl@microsoft.com" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The central problem of this paper is computational complexity in a setting where the number of classes k for multiclass prediction is very large. Such problems occur in natural language (Which translation is best?), search (What result is best?), and detection (Who is that?) tasks. Almost all machine learning algorithms (with the exception of decision trees) have running times for multiclass classification which are O(k) with a canonical example being one-against-all classifiers [1]. In this setting, the most efficient possible accurate approach is given by information theory [2]. In essence, any multiclass classification algorithm must uniquely specify the bits of all labels that it predicts correctly on. Consequently, Kraft’s inequality ([2] equation 5.6) implies that the expected computational complexity of predicting correctly is Ω(H(Y )) per example where H(Y ) is the Shannon entropy of the label. For the worst case distribution on k classes, this implies Ω(log(k)) computation is required.\nHence, our goal is achieving O(log(k)) computational time per example1 for both training and testing, while effectively using online learning algorithms to minimize passes over the data.\nThe goal of logarithmic (in k) complexity naturally motivates approaches that construct a logarithmic depth hierarchy over the labels, with one label per leaf. While this hierarchy is sometimes available through prior knowledge, in many scenarios it needs to be learned as well. This naturally leads to a partition problem which arises at each node in the hierarchy. The partition problem is finding a classifier: c : X → {−1, 1} which divides examples into two subsets with a purer set of labels than the original set. Definitions of purity vary, but canonical examples are the number of labels remaining in each subset, or softer notions such as the average Shannon entropy of the class labels. Despite resulting in a classifier, this problem is fundamentally different from standard binary classification. To see this, note that replacing c(x) with −c(x) is very bad for binary classification, but has no impact on the quality of a partition2. The partition problem is fundamentally non-convex\n1Throughout the paper by logarithmic time we mean logarithmic time per example. 2The problem bears parallels to clustering in this regard.\nfor symmetric classes since the average c(x)−c(x)2 of c(x) and−c(x) is a poor partition (the always-0 function places all points on the same side).\nThe choice of partition matters in problem dependent ways. For example, consider examples on a line with label i at position i and threshold classifiers. In this case, trying to partition class labels {1, 3} from class label 2 results in poor performance. The partition problem is typically solved for decision tree learning via an enumerate-and-test approach amongst a small set of possible classifiers (see e.g. [3]). In the multiclass setting, it is desirable to achieve substantial error reduction for each node in the tree which motivates using a richer set of classifiers in the nodes to minimize the number of nodes, and thereby decrease the computational complexity. The main theoretical contribution of this work is to establish a boosting algorithm for learning trees with O(k) nodes and O(log k) depth, thereby addressing the goal of logarithmic time train and test complexity. Our main theoretical result, presented in Section 2.3, generalizes a binary boosting-by-decision-tree theorem [4] to multiclass boosting. As in all boosting results, performance is critically dependent on the quality of the weak learner, supporting intuition that we need sufficiently rich partitioners at nodes. The approach uses a new objective for decision tree learning, which we optimize at each node of the tree. The objective and its theoretical properties are presented in Section 2.\n26 105 1000 21841 105033 0\n0.2\n0.4\n0.6\n0.8\n1\nnumber of classes\nac cu\nra cy\nLOMtree vs one−against−all\nOAA LOMtree\nfails this test due to its discrete nature, and even natural approximations are challenging to tractably optimize under computational constraints. As a result, we use the theoretical objective as a motivation and construct a new Logarithmic Online Multiclass Tree (LOMtree) algorithm for empirical evaluation.\nCreating a tree in an online fashion creates a new class of problems. What if some node is initially created but eventually proves useless because no examples go to it? At best this results in a wasteful solution, while in practice it starves other parts of the tree which need representational complexity. To deal with this, we design an efficient process for recycling orphan nodes into locations where they are needed, and prove that the number of times a node is recycled is at most logarithmic in the number of examples. The algorithm is described in Section 3 and analyzed in Section 3.1.\nAnd is it effective? Given the inherent non-convexity of the partition problem this is unavoidably an empirical question which we answer on a range of datasets varying from 26 to 105K classes in Section 4. We find that under constrained training times, this approach is quite effective compared to all baselines while dominating other O(log k) train time approaches.\nWhat’s new? To the best of our knowledge, the splitting criterion, the boosting statement, the LOMtree algorithm, the swapping guarantee, and the experimental results are all new here."
    }, {
      "heading" : "1.1 Prior Work",
      "text" : "Only a few authors address logarithmic time training. The Filter tree [5] addresses consistent (and robust) multiclass classification, showing that it is possible in the statistical limit. The Filter tree does not address the partition problem as we do here which as shown in our experimental section is often helpful. The partition finding problem is addressed in the conditional probability tree [6], but that paper addresses conditional probability estimation. Conditional probability estimation can be converted into multiclass prediction [7], but doing so is not a logarithmic time operation.\nQuite a few authors have addressed logarithmic testing time while allowing training time to be O(k) or worse. While these approaches are intractable on our larger scale problems, we describe them here for context. The partition problem can be addressed by recursively applying spectral clustering on a confusion graph [8] (other clustering approaches include [9]). Empirically, this approach has been found to sometimes lead to badly imbalanced splits [10]. In the context of ranking, another approach uses k-means hierarchical clustering to recover the label sets for a given partition [11].\nThe more recent work [12] on the multiclass classification problem addresses it via sparse output coding by tuning high-cardinality multiclass categorization into a bit-by-bit decoding problem. The authors decouple the learning processes of coding matrix and bit predictors and use probabilistic decoding to decode the optimal class label. The authors however specify a class similarity which is O(k2) to compute (see Section 2.1.1 in [12]), and hence this approach is in a different complexity class than ours (this is also born out experimentally). The variant of the popular error correcting output code scheme for solving multi-label prediction problems with large output spaces under the assumption of output sparsity was also considered in [13]. Their approach in general requires O(k) running time to decode since, in essence, the fit of each label to the predictions must be checked and there are O(k) labels. Another approach [14] proposes iterative least-squares-style algorithms for multi-class (and multi-label) prediction with relatively large number of examples and data dimensions, and the work of [15] focusing in particular on the cost-sensitive multiclass classification. Both approaches however have O(k) training time. Decision trees are naturally structured to allow logarithmic time prediction. Traditional decision trees often have difficulties with a large number of classes because their splitting criteria are not well-suited to the large class setting. However, newer approaches [16, 17] have addressed this effectively at significant scales in the context of multilabel classification (multilabel learning, with missing labels, is also addressed in [18]). More specifically, the first work [16] performs brute force optimization of a multilabel variant of the Gini index defined over the set of positive labels in the node and assumes label independence during random forest construction. Their method makes fast predictions, however has high training costs [17]. The second work [17] optimizes a rank sensitive loss function (Discounted Cumulative Gain). Additionally, a well-known problem with hierarchical classification is that the performance significantly deteriorates lower in the hierarchy [19] which some authors solve by biasing the training distribution to reduce error propagation while simultaneously combining bottom-up and top-down approaches during training [20].\nThe reduction approach we use for optimizing partitions implicitly optimizes a differential objective. A non-reductive approach to this has been tried previously [21] on other objectives yielding good results in a different context."
    }, {
      "heading" : "2 Framework and theoretical analysis",
      "text" : "In this section we describe the essential elements of the approach, and outline the theoretical properties of the resulting framework. We begin with high-level ideas."
    }, {
      "heading" : "2.1 Setting",
      "text" : "We employ a hierarchical approach for learning a multiclass decision tree structure, training this structure in a top-down fashion. We assume that we receive examples x ∈ X ⊆ Rd, with labels y ∈ {1, 2, . . . , k}. We also assume access to a hypothesis class H where each h ∈ H is a binary classifier, h : X 7→ {−1, 1}. The overall objective is to learn a tree of depth O(log k), where each node in the tree consists of a classifier from H. The classifiers are trained in such a way that hn(x) = 1 (hn denotes the classifier in node n of the tree3) means that the example x is sent to the right subtree of node n, while hn(x) = −1 sends x to the left subtree. When we reach a leaf, we predict according to the label with the highest frequency amongst the examples reaching that leaf.\n3Further in the paper we skip index n whenever it is clear from the context that we consider a fixed tree node.\nIn the interest of computational complexity, we want to encourage the number of examples going to the left and right to be fairly balanced. For good statistical accuracy, we want to send examples of class i almost exclusively to either the left or the right subtree, thereby refining the purity of the class distributions at subsequent levels in the tree. The purity of a tree node is therefore a measure of whether the examples of each class reaching the node are then mostly sent to its one child node (pure split) or otherwise to both children (impure split). The formal definitions of balancedness and purity are introduced in Section 2.2. An objective expressing both criteria4 and resulting theoretical properties are illustrated in the following sections. A key consideration in picking this objective is that we want to effectively optimize it over hypotheses h ∈ H, while streaming over examples in an online fashion5. This seems unsuitable with some of the more standard decision tree objectives such as Shannon or Gini entropy, which leads us to design a new objective. At the same time, we show in Section 2.3 that under suitable assumptions, optimizing the objective also leads to effective reduction of the average Shannon entropy over the entire tree."
    }, {
      "heading" : "2.2 An objective and analysis of resulting partitions",
      "text" : "We now define a criterion to measure the quality of a hypothesis h ∈ H in creating partitions at a fixed node n in the tree. Let πi denotes the proportion of label i amongst the examples reaching this node. Let P (h(x) > 0) and P (h(x) > 0|i) denote the fraction of examples reaching n for which h(x) > 0, marginally and conditional on class i respectively. Then we define the objective6:\nJ(h) = 2 k∑ i=1 πi |P (h(x) > 0)− P (h(x) > 0|i)| . (1)\nWe aim to maximize the objective J(h) to obtain high quality partitions. Intuitively, the objective encourages the fraction of examples going to the right from class i to be substantially different from the background fraction for each class i. As a concrete simple scenario, if P (h(x) > 0) = 0.5 for some hypothesis h, then the objective prefers P (h(x) > 0|i) to be as close to 0 or 1 as possible for each class i, leading to pure partitions. We now make these intuitions more formal. Definition 1 (Purity). The hypothesis h ∈ H induces a pure split if\nα := k∑ i=1 πi min(P (h(x) > 0|i), P (h(x) < 0|i)) ≤ δ,\nwhere δ ∈ [0, 0.5), and α is called the purity factor.\nIn particular, a partition is called maximally pure if α = 0, meaning that each class is sent exclusively to the left or the right. We now define a similar definition for the balancedness of a split. Definition 2 (Balancedness). The hypothesis h ∈ H induces a balanced split if\nc ≤ P (h(x) > 0)︸ ︷︷ ︸ =β ≤ 1− c,\nwhere c ∈ (0, 0.5], and β is called the balancing factor.\nA partition is called maximally balanced if β = 0.5, meaning that an equal number of examples are sent to the left and right children of the partition. The balancing factor and the purity factor are related as shown in Lemma 1 (the proofs of Lemma 1 and the following lemma (Lemma 2) are deferred to the Supplementary material). Lemma 1. For any hypothesis h, and any distribution over examples (x, y), the purity factor α and the balancing factor β satisfy α ≤ min{(2− J(h))/(4β)− β, 0.5}.\nA partition is called maximally pure and balanced if it satisfies both α = 0 and β = 0.5. We see that J(h) = 1 for a hypothesis h inducing a maximally pure and balanced partition as captured in the next lemma. Of course we do not expect to have hypotheses producing maximally pure and balanced splits in practice. Lemma 2. For any hypothesis h : X 7→ {−1, 1}, the objective J(h) satisfies J(h) ∈ [0, 1]. Furthermore, if h induces a maximally pure and balanced partition then J(h) = 1.\n4We want an objective to achieve its optimum for simultaneously pure and balanced split. The standard entropy-based criteria, such as Shannon or Gini entropy, as well as the criterion we will propose, posed in Equation 1, satisfy this requirement (for the entropy-based criteria see [4], for our criterion see Lemma 2).\n5Our algorithm could also be implemented as batch or streaming, where in case of the latter one can for example make one pass through the data per every tree level, however for massive datasets making multiple passes through the data is computationally costly, further justifying the need for an online approach.\n6The proposed objective function exhibits some similarities with the so-called Carnap’s measure [22, 23] used in probability and inductive logic."
    }, {
      "heading" : "2.3 Quality of the entire tree",
      "text" : "The above section helps us understand the quality of an individual split produced by effectively maximizing J(h). We next reason about the quality of the entire tree as we add more and more nodes. We measure the quality of trees using the average entropy over all the leaves in the tree, and track the decrease of this entropy as a function of the number of nodes. Our analysis extends the theoretical analysis in [4], originally developed to show the boosting properties of the decision trees for binary classification problems, to the multiclass classification setting.\nGiven a tree T , we consider the entropy function Gt as the measure of the quality of tree: Gt = ∑ l∈L wl k∑ i=1 πl,i ln ( 1 πl,i ) where πl,i’s are the probabilities that a randomly chosen data point x drawn from P , where P is a fixed target distribution over X , has label i given that x reaches node l, L denotes the set of all tree leaves, t denotes the number of internal tree nodes, and wl is the weight of leaf l defined as the probability a randomly chosen x drawn from P reaches leaf l (note that ∑ l∈L wl = 1).\nWe next state the main theoretical result of this paper (it is captured in Theorem 1). We adopt the weak learning framework. The weak hypothesis assumption, captured in Definition 3, posits that each node of the tree T has a hypothesis h in its hypothesis classHwhich guarantees simultaneously a ”weak” purity and a ”weak” balancedness of the split on any distribution P over X . Under this assumption, one can use the new decision tree approach to drive the error below any threshold. Definition 3 (Weak Hypothesis Assumption). Let m denote any node of the tree T , and let βm = P (hm(x) > 0) and Pm,i = P (hm(x) > 0|i). Furthermore, let γ ∈ R+ be such that for all m, γ ∈ (0,min(βm, 1 − βm)]. We say that the weak hypothesis assumption is satisfied when for any distribution P over X at each node m of the tree T there exists a hypothesis hm ∈ H such that J(hm)/2 = ∑k i=1 πm,i|Pm,i − βm| ≥ γ.\nTheorem 1. Under the Weak Hypothesis Assumption, for any α ∈ [0, 1], to obtainGt ≤ α it suffices to make t ≥ (1/α) 4(1−γ)2 ln k γ2 splits.\nWe defer the proof of Theorem 1 to the Supplementary material and provide its sketch now. The analysis studies a tree construction algorithm where we recursively find the leaf node with the highest weight, and choose to split it into two children. Let n be the heaviest leaf at time t. Consider splitting it to two children. The contribution of node n to the tree entropy changes after it splits. This change (entropy reduction) corresponds to a gap in the Jensen’s inequality applied to the concave function, and thus can further be lower-bounded (we use the fact that Shannon entropy is strongly concave with respect to `1-norm (see e.g., Example 2.5 in Shalev-Shwartz [24])). The obtained lower-bound turns out to depend proportionally on J(hn)2. This implies that the larger the objective J(hn) is at time t, the larger the entropy reduction ends up being, which further reinforces intuitions to maximize J . In general, it might not be possible to find any hypothesis with a large enough objective J(hn) to guarantee sufficient progress at this point so we appeal to a weak learning assumption. This assumption can be used to further lower-bound the entropy reduction and prove Theorem 1."
    }, {
      "heading" : "3 The LOMtree Algorithm",
      "text" : "The objective function of Section 2 has another convenient form which yields a simple online algorithm for tree construction and training. Note that Equation 1 can be written (details are shown in Section 12 in the Supplementary material) as\nJ(h) = 2Ei[|Ex[1(h(x) > 0)]− Ex[1(h(x) > 0|i)]|]. Maximizing this objective is a discrete optimization problem that can be relaxed as follows\nJ(h) = 2Ei[|Ex[h(x)]− Ex[h(x)|i]|], where Ex[h(x)|i] is the expected score of class i. We next explain our empirical approach for maximizing the relaxed objective. The empirical estimates of the expectations can be easily stored and updated online in every tree node. The decision whether to send an example reaching a node to its left or right child node is based on the sign of the difference between the two expectations: Ex[h(x)] and Ex[h(x)|y], where y is a label of the data point, i.e. when Ex[h(x)]−Ex[h(x)|y] > 0 the data point is sent to the left, else it is sent to the right. This procedure is conveniently demonstrated on a toy example in Section 13 in the Supplement.\nDuring training, the algorithm assigns a unique label to each node of the tree which is currently a leaf. This is the label with the highest frequency amongst the examples reaching that leaf. While\nAlgorithm 1 LOMtree algorithm (online tree training) Input: regression algorithm R, max number of tree non-leaf nodes T , swap resistance RS Subroutine SetNode (v) mv = ∅ (mv(y) - sum of the scores for class y) lv = ∅ (lv(y) - number of points of class y reaching v) nv = ∅ (nv(y) - number of points of class y which are used to train regressor in v) ev = ∅ (ev(y) - expected score for class y) Ev = 0 (expected total score) Cv = 0 (the size of the smallest leaf7 in the subtree with root v) Subroutine UpdateC (v) While (v 6= r AND CPARENT(v) 6= Cv)\nv = PARENT(v); Cv = min(CLEFT(v), CRIGHT(v))8\nSubroutine Swap (v) Find a leaf s for which (Cs = Cr) sPA=PARENT(s); sGPA=GRANDPA(s); sSIB=SIBLING(s)9 If (sPA = LEFT(sGPA)) LEFT(sGPA) = sSIB Else RIGHT(sGPA) = sSIB UpdateC (sSIB); SetNode (s); LEFT(v) = s; SetNode (sPA); RIGHT(v) = sPA Create root r = 0: SetNode (r); t = 1 For each example (x, y) do\nSet j = r While j is not a leaf do\nIf (lj(y) = ∅) mj(y) = 0; lj(y) = 0; nj(y) = 0; ej(y) = 0 If (Ej > ej(y)) c=−1 Else c=1 Train hj with example (x, c): R(x, c) lj(y)++; nj(y) ++; mj(y) += hj(x); ej(y) = mj(y)/nj(y); Ej = ∑k i=1 mj(i)∑k i=1 nj(i) 10 Set j to the child of j corresponding to hj If(j is a leaf) lj(y)++ If(lj has at least 2 non-zero entries)\nIf(t<T OR Cj−maxi lj(i)>RS(Cr+1)) If (t<T )\nSetNode (LEFT(j)); SetNode (RIGHT(j)); t++ Else Swap(j) CLEFT(j)=bCj/2c; CRIGHT(j)=Cj−CLEFT(j); UpdateC (LEFT(j))\nCj++\ntesting, a test example is pushed down the tree along the path from the root to the leaf, where in each non-leaf node of the path its regressor directs the example either to the left or right child node. The test example is then labeled with the label assigned to the leaf that this example descended to.\nThe training algorithm is detailed in Algorithm 1 where each tree node contains a classifier (we use linear classifiers), i.e. hj is the regressor stored in node j and hj(x) is the value of the prediction of hj on example x11. The stopping criterion for expanding the tree is when the number of non-leaf nodes reaches a threshold T ."
    }, {
      "heading" : "3.1 Swapping",
      "text" : "Consider a scenario where the current training example descends to leaf j. The leaf can split (create two children) if the examples that reached it in the past were coming from at least two different classes. However, if the number of non-leaf nodes of the tree reaches threshold T , no more nodes can be expanded and thus j cannot create children. Since the tree construction is done online, some nodes created at early stages of training may end up useless because no examples reach them later\n7The smallest leaf is the one with the smallest total number of data points reaching it in the past. 8PARENT(v), LEFT(v) and RIGHT(v) denote resp. the parent, and the left and right child of node v. 9GRANDPA(v) and SIBLING(v) denote respectively the grandparent of node v and the sibling of node v, i.e.\nthe node which has the same parent as v. 10In the implementation both sums are stored as variables thus updating Ev takes O(1) computations. 11We also refer to this prediction value as the ’score’ in this section.\non. This prevents potentially useful splits such as at leaf j. This problem can be solved by recycling orphan nodes (subroutine Swap in Algorithm 1). The general idea behind node recycling is to allow nodes to split if a certain condition is met. In particular, node j splits if the following holds:\nCj − max i∈{1,2,...,k} lj(i) > RS(Cr + 1), (2)\nwhere r denotes the root of the entire tree, Cj is the size of the smallest leaf in the subtree with root j, where the smallest leaf is the one with the smallest total number of data points reaching it in the past, lj is a k-dimensional vector of non-negative integers where the ith element is the count of the number of data points with label i reaching leaf j in the past, and finally RS is a “swap resistance”. The subtraction of maxi∈{1,2,...,k} lj(i) in Equation 2 ensures that a pure node will not be recycled.\nIf the condition in Inequality 2 is satisfied, the swap of the nodes is performed where an orphan leaf s, which was reached by the smallest number of examples in the past, and its parent sPA are detached from the tree and become children of node j whereas the old sibling sSIB of an orphan node s becomes a direct child of the old grandparent sGPA. The swapping procedure is shown in Figure 2. The condition captured in the Inequality 2 allows us to prove that the number of times any given node is recycled is upper-bounded by the logarithm of the number of examples whenever the swap resistance is 4 or more (Lemma 3). Lemma 3. Let the swap resistanceRS be greater or equal to 4. Then for all sequences of examples, the number of times Algorithm 1 recycles any given node is upper-bounded by the logarithm (with base 2) of the sequence length."
    }, {
      "heading" : "4 Experiments",
      "text" : "We address several hypotheses experimentally.\nIsolet Sector Aloi ImNet ODP size 52.3MB19MB17.7MB104GB12 3GB\n# features 617 54K 128 6144 0.5M # examples 7797 9619 108K 14.2M 1577418 # classes 26 105 1000 ∼22K ∼105K\nducted experiments on a variety of benchmark multiclass datasets: Isolet, Sector, Aloi, ImageNet (ImNet) and ODP13. The details of the datasets are provided in Table 1. The datasets were divided into training (90%) and testing (10%). Furthermore, 10% of the training dataset was\nused as a validation set.\nThe baselines we compared LOMtree with are a balanced random tree of logarithmic depth (Rtree) and the Filter tree [5]. Where computationally feasible, we also compared with a one-against-all classifier (OAA) as a representative O(k) approach. All methods were implemented in the Vowpal Wabbit [25] learning system and have similar levels of optimization. The regressors in the tree nodes for LOMtree, Rtree, and Filter tree as well as the OAA regressors were trained by online gradient descent for which we explored step sizes chosen from the set {0.25, 0.5, 0.75, 1, 2, 4, 8}. We used linear regressors. For each method we investigated training with up to 20 passes through the data and we selected the best setting of the parameters (step size and number of passes) as the one minimizing the validation error. Additionally, for the LOMtree we investigated different settings of the stopping\n12compressed 13The details of the source of each dataset are provided in the Supplementary material.\ncriterion for the tree expansion: T = {k − 1, 2k − 1, 4k − 1, 8k − 1, 16k − 1, 32k − 1, 64k − 1}, and swap resistance RS = {4, 8, 16, 32, 64, 128, 256}. In Table 2 and 3 we report respectively train time and per-example test time (the best performer is indicated in bold). Training time (and later reported test error) is not provided for OAA on ImageNet and ODP due to intractability14-both are petabyte scale computations15.\nTable 2: Training time on selected problems.\nIsolet Sector Aloi LOMtree 16.27s 12.77s 51.86s\nOAA 19.58s 18.37s 11m2.43s\nThe first hypothesis is consistent with the experimental results. Time-wise LOMtree significantly outperforms OAA due to building only close-to logarithmic depth trees. The improvement in the training time increases with the number of classes in the classification problem. For instance on Aloi training with LOMtree is 12.8 times faster than withOAA. The same can be said about the test time, where the per-example test time for Aloi, ImageNet and ODP are respectively 5.5, 403.8 and 4038.5 times faster than OAA. The significant advantage of LOMtree over OAA is also captured in Figure 3.\n6 8 10 12 14 16\n2\n4\n6\n8\n10\n12\nlog 2 (number of classes)\nlo g\n2( ti\nm e\nra ti\no )\nLOMtree vs one−against−all\nThe third hypothesis is weakly consistent with the empirical results. The time advantage of LOMtree comes with some loss of statistical accuracy with respect to OAA where OAA is tractable. We conclude that LOMtree significantly closes the gap between other logarithmic time methods and OAA, making it a plausible approach in computationally constrained large-k applications."
    }, {
      "heading" : "5 Conclusion",
      "text" : "The LOMtree algorithm reduces the multiclass problem to a set of binary problems organized in a tree structure where the partition in every tree node is done by optimizing a new partition criterion online. The criterion guarantees pure and balanced splits leading to logarithmic training and testing time for the tree classifier. We provide theoretical justification for our approach via a boosting statement and empirically evaluate it on multiple multiclass datasets. Empirically, we find that this is the best available logarithmic time approach for multiclass classification problems."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We would like to thank Alekh Agarwal, Dean Foster, Robert Schapire and Matus Telgarsky for valuable discussions.\n14Note however that the mechanics of testing datastes are much easier - one can simply test with effectively untrained parameters on a few examples to measure the test speed thus the per-example test time for OAA on ImageNet and ODP is provided.\n15Also to the best of our knowledge there exist no state-of-the-art results of the OAA performance on these datasets published in the literature."
    } ],
    "references" : [ {
      "title" : "In defense of one-vs-all classification",
      "author" : [ "R. Rifkin", "A. Klautau" ],
      "venue" : "J. Mach. Learn. Res., 5:101–141",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Elements of Information Theory",
      "author" : [ "T.M. Cover", "J.A. Thomas" ],
      "venue" : "John Wiley & Sons, Inc.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Classification and Regression Trees",
      "author" : [ "L. Breiman", "J.H. Friedman", "R.A. Olshen", "C.J. Stone" ],
      "venue" : "CRC Press LLC, Boca Raton, Florida",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1984
    }, {
      "title" : "On the boosting ability of top-down decision tree learning algorithms",
      "author" : [ "M. Kearns", "Y. Mansour" ],
      "venue" : "Journal of Computer and Systems Sciences, 58(1):109–128, 1999 ",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Error-correcting tournaments",
      "author" : [ "A. Beygelzimer", "J. Langford", "P.D. Ravikumar" ],
      "venue" : "ALT",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Conditional probability tree estimation analysis and algorithms",
      "author" : [ "A. Beygelzimer", "J. Langford", "Y. Lifshits", "G.B. Sorkin", "A.L. Strehl" ],
      "venue" : "UAI",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Pattern Recognition and Machine Learning",
      "author" : [ "C.M. Bishop" ],
      "venue" : "Springer",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Label embedding trees for large multi-class tasks",
      "author" : [ "S. Bengio", "J. Weston", "D. Grangier" ],
      "venue" : "NIPS",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A multi-class svm classifier utilizing binary decision tree",
      "author" : [ "G. Madzarov", "D. Gjorgjevikj", "I. Chorbev" ],
      "venue" : "Informatica, 33(2):225–233",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Fast and balanced: Efficient label tree learning for large scale object recognition",
      "author" : [ "J. Deng", "S. Satheesh", "A.C. Berg", "L. Fei-Fei" ],
      "venue" : "NIPS",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Label partitioning for sublinear ranking",
      "author" : [ "J. Weston", "A. Makadia", "H. Yee" ],
      "venue" : "ICML",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Sparse output coding for large-scale visual recognition",
      "author" : [ "B. Zhao", "E.P. Xing" ],
      "venue" : "CVPR",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Multi-label prediction via compressed sensing",
      "author" : [ "D. Hsu", "S. Kakade", "J. Langford", "T. Zhang" ],
      "venue" : "NIPS",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Least squares revisited: Scalable approaches for multi-class prediction",
      "author" : [ "A. Agarwal", "S.M. Kakade", "N. Karampatziakis", "L. Song", "G. Valiant" ],
      "venue" : "ICML",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Guess-averse loss functions for costsensitive multiclass boosting",
      "author" : [ "O. Beijbom", "M. Saberian", "D. Kriegman", "N. Vasconcelos" ],
      "venue" : "ICML",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Multi-label learning with millions of labels: Recommending advertiser bid phrases for web pages",
      "author" : [ "R. Agarwal", "A. Gupta", "Y. Prabhu", "M. Varma" ],
      "venue" : "WWW",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Fastxml: A fast",
      "author" : [ "Y. Prabhu", "M. Varma" ],
      "venue" : "accurate and stable tree-classifier for extreme multi-label learning. In ACM SIGKDD",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Large-scale multi-label learning with missing labels",
      "author" : [ "H.-F. Yu", "P. Jain", "P. Kar", "I.S. Dhillon" ],
      "venue" : "ICML",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Support vector machines classification with a very large-scale taxonomy",
      "author" : [ "T.-Y. Liu", "Y. Yang", "H. Wan", "H.-J. Zeng", "Z. Chen", "W.-Y. Ma" ],
      "venue" : "SIGKDD Explorations",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Refined experts: improving classification in large taxonomies",
      "author" : [ "P.N. Bennett", "N. Nguyen" ],
      "venue" : "SIGIR",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Entanglement and differentiable information gain maximization",
      "author" : [ "A. Montillo", "J. Tu", "J. Shotton", "J. Winn", "J.E. Iglesias", "D.N. Metaxas", "A. Criminisi" ],
      "venue" : "Decision Forests for Computer Vision and Medical Image Analysis",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Comparison of confirmation measures",
      "author" : [ "K. Tentori", "V. Crupi", "N. Bonini", "D. Osherson" ],
      "venue" : "Cognition, 103(1):107 – 119",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Logical Foundations of Probability",
      "author" : [ "R. Carnap" ],
      "venue" : "2nd ed. Chicago: University of Chicago Press. Par. 87 (pp. 468-478)",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 1962
    }, {
      "title" : "Online learning and online convex optimization",
      "author" : [ "S. Shalev-Shwartz" ],
      "venue" : "Found. Trends Mach. Learn., 4(2):107–194",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "and A",
      "author" : [ "J. Langford", "L. Li" ],
      "venue" : "Strehl. http://hunch.net/ ̃vw",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Introductory lectures on convex optimization : a basic course",
      "author" : [ "Y. Nesterov" ],
      "venue" : "Applied optimization, Kluwer Academic Publ.",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Imagenet: A large-scale hierarchical image database",
      "author" : [ "J. Deng", "W. Dong", "R. Socher", "L.-J. Li", "K. Li", "L. Fei-Fei" ],
      "venue" : "CVPR",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Almost all machine learning algorithms (with the exception of decision trees) have running times for multiclass classification which are O(k) with a canonical example being one-against-all classifiers [1].",
      "startOffset" : 201,
      "endOffset" : 204
    }, {
      "referenceID" : 1,
      "context" : "In this setting, the most efficient possible accurate approach is given by information theory [2].",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 1,
      "context" : "Consequently, Kraft’s inequality ([2] equation 5.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 3,
      "context" : "3, generalizes a binary boosting-by-decision-tree theorem [4] to multiclass boosting.",
      "startOffset" : 58,
      "endOffset" : 61
    }, {
      "referenceID" : 4,
      "context" : "A complete system with multiple partitions could be constructed top down (as the boosting theorem) or bottom up (as Filter tree [5]).",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 4,
      "context" : "The Filter tree [5] addresses consistent (and robust) multiclass classification, showing that it is possible in the statistical limit.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 5,
      "context" : "The partition finding problem is addressed in the conditional probability tree [6], but that paper addresses conditional probability estimation.",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 6,
      "context" : "Conditional probability estimation can be converted into multiclass prediction [7], but doing so is not a logarithmic time operation.",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 7,
      "context" : "The partition problem can be addressed by recursively applying spectral clustering on a confusion graph [8] (other clustering approaches include [9]).",
      "startOffset" : 104,
      "endOffset" : 107
    }, {
      "referenceID" : 8,
      "context" : "The partition problem can be addressed by recursively applying spectral clustering on a confusion graph [8] (other clustering approaches include [9]).",
      "startOffset" : 145,
      "endOffset" : 148
    }, {
      "referenceID" : 9,
      "context" : "Empirically, this approach has been found to sometimes lead to badly imbalanced splits [10].",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 10,
      "context" : "In the context of ranking, another approach uses k-means hierarchical clustering to recover the label sets for a given partition [11].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 11,
      "context" : "The more recent work [12] on the multiclass classification problem addresses it via sparse output coding by tuning high-cardinality multiclass categorization into a bit-by-bit decoding problem.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 11,
      "context" : "1 in [12]), and hence this approach is in a different complexity class than ours (this is also born out experimentally).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 12,
      "context" : "The variant of the popular error correcting output code scheme for solving multi-label prediction problems with large output spaces under the assumption of output sparsity was also considered in [13].",
      "startOffset" : 195,
      "endOffset" : 199
    }, {
      "referenceID" : 13,
      "context" : "Another approach [14] proposes iterative least-squares-style algorithms for multi-class (and multi-label) prediction with relatively large number of examples and data dimensions, and the work of [15] focusing in particular on the cost-sensitive multiclass classification.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 14,
      "context" : "Another approach [14] proposes iterative least-squares-style algorithms for multi-class (and multi-label) prediction with relatively large number of examples and data dimensions, and the work of [15] focusing in particular on the cost-sensitive multiclass classification.",
      "startOffset" : 195,
      "endOffset" : 199
    }, {
      "referenceID" : 15,
      "context" : "However, newer approaches [16, 17] have addressed this effectively at significant scales in the context of multilabel classification (multilabel learning, with missing labels, is also addressed in [18]).",
      "startOffset" : 26,
      "endOffset" : 34
    }, {
      "referenceID" : 16,
      "context" : "However, newer approaches [16, 17] have addressed this effectively at significant scales in the context of multilabel classification (multilabel learning, with missing labels, is also addressed in [18]).",
      "startOffset" : 26,
      "endOffset" : 34
    }, {
      "referenceID" : 17,
      "context" : "However, newer approaches [16, 17] have addressed this effectively at significant scales in the context of multilabel classification (multilabel learning, with missing labels, is also addressed in [18]).",
      "startOffset" : 197,
      "endOffset" : 201
    }, {
      "referenceID" : 15,
      "context" : "More specifically, the first work [16] performs brute force optimization of a multilabel variant of the Gini index defined over the set of positive labels in the node and assumes label independence during random forest construction.",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 16,
      "context" : "Their method makes fast predictions, however has high training costs [17].",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 16,
      "context" : "The second work [17] optimizes a rank sensitive loss function (Discounted Cumulative Gain).",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 18,
      "context" : "Additionally, a well-known problem with hierarchical classification is that the performance significantly deteriorates lower in the hierarchy [19] which some authors solve by biasing the training distribution to reduce error propagation while simultaneously combining bottom-up and top-down approaches during training [20].",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 19,
      "context" : "Additionally, a well-known problem with hierarchical classification is that the performance significantly deteriorates lower in the hierarchy [19] which some authors solve by biasing the training distribution to reduce error propagation while simultaneously combining bottom-up and top-down approaches during training [20].",
      "startOffset" : 318,
      "endOffset" : 322
    }, {
      "referenceID" : 20,
      "context" : "A non-reductive approach to this has been tried previously [21] on other objectives yielding good results in a different context.",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 3,
      "context" : "The standard entropy-based criteria, such as Shannon or Gini entropy, as well as the criterion we will propose, posed in Equation 1, satisfy this requirement (for the entropy-based criteria see [4], for our criterion see Lemma 2).",
      "startOffset" : 194,
      "endOffset" : 197
    }, {
      "referenceID" : 21,
      "context" : "(6)The proposed objective function exhibits some similarities with the so-called Carnap’s measure [22, 23] used in probability and inductive logic.",
      "startOffset" : 98,
      "endOffset" : 106
    }, {
      "referenceID" : 22,
      "context" : "(6)The proposed objective function exhibits some similarities with the so-called Carnap’s measure [22, 23] used in probability and inductive logic.",
      "startOffset" : 98,
      "endOffset" : 106
    }, {
      "referenceID" : 3,
      "context" : "Our analysis extends the theoretical analysis in [4], originally developed to show the boosting properties of the decision trees for binary classification problems, to the multiclass classification setting.",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 4,
      "context" : "The baselines we compared LOMtree with are a balanced random tree of logarithmic depth (Rtree) and the Filter tree [5].",
      "startOffset" : 115,
      "endOffset" : 118
    }, {
      "referenceID" : 24,
      "context" : "All methods were implemented in the Vowpal Wabbit [25] learning system and have similar levels of optimization.",
      "startOffset" : 50,
      "endOffset" : 54
    } ],
    "year" : 2015,
    "abstractText" : "We study the problem of multiclass classification with an extremely large number of classes (k), with the goal of obtaining train and test time complexity logarithmic in the number of classes. We develop top-down tree construction approaches for constructing logarithmic depth trees. On the theoretical front, we formulate a new objective function, which is optimized at each node of the tree and creates dynamic partitions of the data which are both pure (in terms of class labels) and balanced. We demonstrate that under favorable conditions, we can construct logarithmic depth trees that have leaves with low label entropy. However, the objective function at the nodes is challenging to optimize computationally. We address the empirical problem with a new online decision tree construction procedure. Experiments demonstrate that this online algorithm quickly achieves improvement in test error compared to more common logarithmic training time approaches, which makes it a plausible method in computationally constrained large-k applications.",
    "creator" : null
  }
}