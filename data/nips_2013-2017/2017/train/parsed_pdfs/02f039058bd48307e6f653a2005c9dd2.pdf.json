{
  "name" : "02f039058bd48307e6f653a2005c9dd2.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Model-Powered Conditional Independence Test",
    "authors" : [ "Rajat Sen", "Ananda Theertha Suresh", "Karthikeyan Shanmugam", "Alexandros G. Dimakis", "Sanjay Shakkottai" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Testing datasets for Conditional Independence (CI) have significant applications in several statistical/learning problems; among others, examples include discovering/testing for edges in Bayesian networks [15, 27, 7, 9], causal inference [23, 14, 29, 5] and feature selection through Markov Blankets [16, 31]. Given a triplet of random variables/vectors (X, Y, Z), we say that X is conditionally independent of Y given Z (denoted by X ? Y |Z), if the joint distribution f\nX,Y,Z (x, y, z) factorizes as f\nX,Y,Z (x, y, z) = f X|Z(x|z)fY |Z(y|z)fZ(z). The problem of Conditional Independence Testing\n(CI Testing) can be defined as follows: Given n i.i.d samples from f X,Y,Z (x, y, z), distinguish between the two hypothesis H0 : X ? Y |Z and H1 : X 6? Y |Z. In this paper we propose a data-driven Model-Powered CI test. The central idea in a model-driven approach is to convert a statistical testing or estimation problem into a pipeline that utilizes the power of supervised learning models like classifiers and regressors; such pipelines can then leverage recent advances in classification/regression in high-dimensional settings. In this paper, we take such a model-powered approach (illustrated in Fig. 1), which reduces the problem of CI testing to Binary Classification. Specifically, the key steps of our procedure are as follows:\n* Equal Contribution\n31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, USA.\n(i) Suppose we are provided 3n i.i.d samples from f X,Y,Z (x, y, z). We keep aside n of these original samples in a set U1 (refer to Fig. 1). The remaining 2n of the original samples are processed through our first module, the nearest-neighbor bootstrap (Algorithm 1 in our paper), which produces n simulated samples stored in U 02. In Section 3, we show that these generated samples in U 02 are in fact close in total variational distance (defined in Section 3) to the conditionally independent distribution fCI(x, y, z) , f\nX|Z(x|z)fY |Z(y|z)fZ(z). (Note that only under H0 does the equality fCI(.) = f\nX,Y,Z\n(.) hold; our method generates samples close to fCI(x, y, z) under both hypotheses).\n(ii) Subsequently, the original samples kept aside in U1 are labeled 1 while the new samples simulated from the nearest-neighbor bootstrap (in U 02) are labeled 0. The labeled samples (U1 with label 1 and U 02 labeled 0) are aggregated into a data-set D. This set D is then broken into training and test sets D\nr and D e each containing n samples each.\n(iii) Given the labeled training data-set (from step (ii)), we train powerful classifiers such as gradient boosted trees [6] or deep neural networks [17] which attempt to learn the classes of the samples. If the trained classifier has good accuracy over the test set, then intuitively it means that the joint distribution f\nX,Y,Z (.) is distinguishable from fCI (note that the generated samples labeled 0 are close in distribution to fCI ). Therefore, we reject H0. On the other hand, if the classifier has accuracy close to random guessing, then f\nX,Y,Z (.) is in fact close to fCI , and we fail to reject H0. For independence testing (i.e whether X ? Y ), classifiers were recently used in [19]. Their key observation was that given i.i.d samples (X, Y ) from f\nX,Y (x, y), if the Y coordinates are randomly permuted then the resulting samples exactly emulate the distribution f\nX (x)f Y (y). Thus the problem can be converted to a two sample test between a subset of the original samples and the other subset which is permuted - Binary classifiers were then harnessed for this two-sample testing; for details see [19]. However, in the case of CI testing we need to emulate samples from fCI . This is harder because the permutation of the samples needs to be Z dependent (which can be high-dimensional). One of our key technical contributions is in proving that our nearest-neighbor bootstrap in step (i) achieves this task.\nThe advantage of this modular approach is that we can harness the power of classifiers (in step (iii) above), which have good accuracies in high-dimensions. Thus, any improvements in the field of binary classification imply an advancement in our CI test. Moreover, there is added flexibility in choosing the best classifier based on domain knowledge about the data-generation process. Finally, our bootstrap is also efficient owing to fast algorithms for identifying nearest-neighbors [24]."
    }, {
      "heading" : "1.1 Main Contributions",
      "text" : "(i) (Classification based CI testing) We reduce the problem of CI testing to Binary Classification as detailed in steps (i)-(iii) above and in Fig. 1. We simulate samples that are close to fCI through a novel nearest-neighbor bootstrap (Algorithm 1) given access to i.i.d samples from the joint distribution.\nThe problem of CI testing then reduces to a two-sample test between the original samples in U1 and U 02, which can be effectively done by binary classifiers. (ii) (Guarantees on Bootstrapped Samples) As mentioned in steps (i)-(iii), if the samples generated by the bootstrap (in U 02) are close to fCI , then the CI testing problem reduces to testing whether the data-sets U1 and U 02 are distinguishable from each other. We theoretically justify that this is indeed true. Let\nX,Y,Z (x, y, z) denote the distribution of a sample produced by Algorithm 1, when it is supplied with 2n i.i.d samples from f\nX,Y,Z (.). In Theorem 1, we prove that d TV ( , fCI) = O(1/n1/dz ) under appropriate smoothness assumptions. Here d\nz is the dimension of Z and d TV denotes total variational distance (Def. 1).\n(iii) (Generalization Bounds for Classification under near-independence) The samples generated from the nearest-neighbor bootstrap do not remain i.i.d but they are close to i.i.d. We quantify this property and go on to show generalization risk bounds for the classifier. Let us denote the class of function encoded by the classifier as G. Let ˆR denote the probability of error of the optimal classifier ĝ 2 G trained on the training set (Fig. 1). We prove that under appropriate assumptions, we have\nr0 O(1/n1/dz )  ˆR  r0 + O(1/n1/dz ) + O ✓p V ✓ n 1/3 + q 2 d z/n ◆◆\nwith high probability, upto log factors. Here r0 = 0.5(1 dTV (f, fCI)), V is the VC dimension [30] of the class G. Thus when f is equivalent to fCI (H0 holds) then the error rate of the classifier is close to 0.5. But when H1 holds the loss is much lower. We provide a novel analysis of Rademacher complexity bounds [4] under near-independence which is of independent interest.\n(iv) (Empirical Evaluation) We perform extensive numerical experiments where our algorithm outperforms the state of the art [32, 28]. We also apply our algorithm for analyzing CI relations in the protein signaling network data from the flow cytometry data-set [26]. In practice we observe that the performance with respect to dimension of Z scales much better than expected from our worst case theoretical analysis. This is because powerful binary classifiers perform well in high-dimensions."
    }, {
      "heading" : "1.2 Related Work",
      "text" : "In this paper we address the problem of non-parametric CI testing when the underlying random variables are continuous. The literature on non-parametric CI testing is vast. We will review some of the recent work in this field that is most relevant to our paper.\nMost of the recent work in CI testing are kernel based [28, 32, 10]. Many of these works build on the study in [11], where non-parametric CI relations are characterized using covariance operators for Reproducing Kernel Hilbert Spaces (RKHS) [11]. KCIT [32] uses the partial association of regression functions relating X , Y , and Z. RCIT [28] is an approximate version of KCIT that attempts to improve running times when the number of samples are large. KCIPT [10] is perhaps most relevant to our work. In [10], a specific permutation of the samples is used to simulate data from fCI . An expensive linear program needs to be solved in order to calculate the permutation. On the other hand, we use a simple nearest-neighbor bootstrap and further we provide theoretical guarantees about the closeness of the samples to fCI in terms of total variational distance. Finally the two-sample test in [10] is based on a kernel method [3], while we use binary classifiers for the same purpose. There has also been recent work on entropy estimation [13] using nearest neighbor techniques (used for density estimation); this can subsequently be used for CI testing by estimating the conditional mutual information I(X; Y |Z). Binary classification has been recently used for two-sample testing, in particular for independence testing [19]. Our analysis of generalization guarantees of classification are aimed at recovering guarantees similar to [4], but in a non-i.i.d setting. In this regard (non-i.i.d generalization guarantees), there has been recent work in proving Rademacher complexity bounds for -mixing stationary processes [21]. This work also falls in the category of machine learning reductions, where the general philosophy is to reduce various machine learning settings like multi-class regression [2], ranking [1], reinforcement learning [18], structured prediction [8] to that of binary classification."
    }, {
      "heading" : "2 Problem Setting and Algorithms",
      "text" : "In this section we describe the algorithmic details of our CI testing procedure. We first formally define our problem. Then we describe our bootstrap algorithm for generating the data-set that mimics samples from fCI . We give a detailed pseudo-code for our CI testing process which reduces the problem to that of binary classification. Finally, we suggest further improvements to our algorithm.\nProblem Setting: The problem setting is that of non-parametric Conditional Independence (CI) testing given i.i.d samples from the joint distributions of random variables/vectors [32, 10, 28]. We are given 3n i.i.d samples from a continuous joint distribution f\nX,Y,Z (x, y, z) where x 2 Rdx , y 2 Rdy and z 2 Rdz . The goal is to test whether X ? Y |Z i.e whether f\nX,Y,Z (x, y, z) factorizes as, f\nX,Y,Z (x, y, z) = f X|Z(x|z)fY |Z(y|z)fZ(z) , fCI(x, y, z)\nThis is essentially a hypothesis testing problem where: H0 : X ? Y |Z and H1 : X 6? Y |Z. Note: For notational convenience, we will drop the subscripts when the context is evident. For instance we may use f(x|z) in place of f\nX|Z(x|z). Nearest-Neighbor Bootstrap: Algorithm 1 is a procedure to generate a data-set U 0 consisting of n samples given a data-set U of 2n i.i.d samples from the distribution f\nX,Y,Z (x, y, z). The data-set U is broken into two equally sized partitions U1 and U2. Then for each sample in U1, we find the nearest neighbor in U2 in terms of the Z coordinates. The Y -coordinates of the sample from U1 are exchanged with the Y -coordinates of its nearest neighbor (in U2); the modified sample is added to U 0.\nAlgorithm 1 DataGen - Given data-set U = U1 [ U2 of 2n i.i.d samples from f(x, y, z) (|U1| = |U2| = n ), returns a new data-set U 0 having n samples.\n1: function DATAGEN(U1, U2, 2n) 2: U 0 = ; 3: for u in U1 do 4: Let v = (x0, y0, z0) 2 U2 be the sample such that z0 is the 1-Nearest Neighbor (1-NN) of z (in `2 norm) in the whole data-set U2, where u = (x, y, z) 5: Let u0 = (x, y0, z) and U 0 = U 0 [ {u0}. 6: end for 7: end function\nOne of our main results is that the samples in U 0, generated in Algorithm 1 mimic samples coming from the distribution fCI . Suppose u = (x, y, z) 2 U1 be a sample such that fZ(z) is not too small. In this case z0 (the 1-NN sample from U2) will not be far from z. Therefore given a fixed z, under appropriate smoothness assumptions, y0 will be close to an independent sample coming from f\nY |Z(y|z0) ⇠ fY |Z(y|z). On the other hand if fZ(z) is small, then z is a rare occurrence and will not contribute adversely.\nCI Testing Algorithm: Now we introduce our CI testing algorithm, which uses Algorithm 1 along with binary classifiers. The psuedo-code is in Algorithm 2 (Classifier CI Test -CCIT).\nAlgorithm 2 CCITv1 - Given data-set U of 3n i.i.d samples from f(x, y, z), returns if X ? Y |Z. 1: function CCIT(U , 3n, ⌧, G) 2: Partition U into three disjoint partitions U1, U2 and U3 of size n each, randomly. 3: Let U 02 = DataGen(U2, U3, 2n) (Algorithm 1). Note that |U 02| = n. 4: Create Labeled data-set D := {(u, ` = 1)}\nu2U1 [ {(u0, `0 = 0)}u02U 02 5: Divide data-set D into train and test set D\nr and D e respectively. Note that |D r | = |D e | = n. 6: Let ĝ = argmin\ng2G ˆL(g, D r ) := 1 |D\nr\n| P (u,`)2D r\n1{g(u) 6= l}. This is Empirical Risk Minimization for training the classifier (finding the best function in the class G).\n7: If ˆL(ĝ, D e ) > 0.5 ⌧ , then conclude X ? Y |Z, otherwise, conclude X 6? Y |Z. 8: end function\nIn Algorithm 2, the original samples in U1 and the nearest-neighbor bootstrapped samples in U 02 should be almost indistinguishable if H0 holds. However, if H1 holds, then the classifier trained in Line 6 should be able to easily distinguish between the samples corresponding to different labels. In Line 6, G denotes the space of functions over which risk minimization is performed in the classifier. We will show (in Theorem 1) that the variational distance between the distribution of one of the samples in U 02 and fCI(x, y, z) is very small for large n. However, the samples in U 02 are not exactly i.i.d but close to i.i.d. Therefore, in practice for finite n, there is a small bias b > 0 i.e. ˆL(ĝ, D\ne ) ⇠ 0.5 b, even when H0 holds. The threshold ⌧ needs to be greater than b in order for Algorithm 2 to function. In the next section, we present an algorithm where this bias is corrected.\nAlgorithm with Bias Correction: We present an improved bias-corrected version of our algorithm as Algorithm 3. As mentioned in the previous section, in Algorithm 2, the optimal classifier may be able to achieve a loss slightly less that 0.5 in the case of finite n, even when H0 is true. However, the classifier is expected to distinguish between the two data-sets only based on the Y, Z coordinates, as the joint distribution of X and Z remains the same in the nearest-neighbor bootstrap. The key idea in Algorithm 3 is to train a classifier only using the Y and Z coordinates, denoted by ĝ0. As before we also train another classier using all the coordinates, which is denoted by ĝ. The test loss of ĝ0 is expected to be roughly 0.5 b, where b is the bias mentioned in the previous section. Therefore, we can just subtract this bias. Thus, when H0 is true ˆL(ĝ0, D0\ne\n) ˆL(ĝ, D e ) will be close to 0. However, when H1 holds, then ˆL(ĝ, De) will be much lower, as the classifier ĝ has been trained leveraging the information encoded in all the coordinates.\nAlgorithm 3 CCITv2 - Given data-set U of 3n i.i.d samples, returns whether X ? Y |Z. 1: function CCIT(U , 3n, ⌧, G) 2: Perform Steps 1-5 as in Algorithm 2. 3: Let D0\nr = {((y, z), `)}(u=(x,y,z),`)2D r . Similarly, let D0 e = {((y, z), `)}(u=(x,y,z),`)2D e . These are the training and test sets without the X-coordinates.\n4: Let ĝ = argmin g2G ˆL(g, D r ) := 1 |D\nr\n| P (u,`)2D r\n1{g(u) 6= l}. Compute test loss: ˆL(ĝ, D\ne ). 5: Let ĝ0 = argmin\ng2G ˆL(g, D0\nr\n) := 1 |D0\nr\n| P\n(u,`)2D0 r 1{g(u) 6= l}. Compute test loss: ˆL(ĝ0, D0\ne ). 6: If ˆL(ĝ, D\ne ) < ˆL(ĝ0, D0 e ) ⌧ , then conclude X 6? Y |Z, otherwise, conclude X ? Y |Z. 7: end function"
    }, {
      "heading" : "3 Theoretical Results",
      "text" : "In this section, we provide our main theoretical results. We first show that the distribution of any one of the samples generated in Algorithm 1 closely resemble that of a sample coming from fCI . This result holds for a broad class of distributions f\nX,Y,Z (x, y, z) which satisfy some smoothness assumptions. However, the samples generated by Algorithm 1 (U2 in the algorithm) are not exactly i.i.d but close to i.i.d. We quantify this and go on to show that empirical risk minimization over a class of classifier functions generalizes well using these samples. Before, we formally state our results we provide some useful definitions.\nDefinition 1. The total variational distance between two continuous probability distributions f(.) and g(.) defined over a domain X is, d\nTV (f, g) = sup p2B|Ef [p(X)] Eg[p(X)]| where B is the set\nof all measurable functions from X ! [0, 1]. Here, E f [.] denotes expectation under distribution f .\nWe first prove that the distribution of any one of the samples generated in Algorithm 1 is close to fCI in terms of total variational distance. We make the following assumptions on the joint distribution of the original samples i.e. f\nX,Y,Z\n(x, y, z):\nSmoothness assumption on f(y|z): We assume a smoothness condition on f(y|z), that is a generalization of boundedness of the max. eigenvalue of Fisher Information matrix of y w.r.t z.\nAssumption 1. For z 2 Rdz , a such that ka zk2  ✏1, the generalized curvature matrix Ia(z) is,\nI a (z) ij =\n@2\n@z0 i @z0 j\nZ log\nf(y|z) f(y|z0)f(y|z)dy ! z 0=a = E \" 2 log f(y|z0) z0 i z0 j z 0=a Z = z # (1)\nWe require that for all z 2 Rdz and all a such that ka zk2  ✏1, max (Ia(z))  . Analogous assumptions have been made on the Hessian of the density in the context of entropy estimation [12].\nSmoothness assumptions on f(z): We assume some smoothness properties of the probability density function f(z). The smoothness assumptions (in Assumption 2) is a subset of the assumptions made in [13] (Assumption 1, Page 5) for entropy estimation. Definition 2. For any > 0, we define G( ) = P (f(Z)  ). This is the probability mass of the distribution of Z in the areas where the p.d.f is less than . Definition 3. (Hessian Matrix) Let H\nf (z) denote the Hessian Matrix of the p.d.f f(z) with respect to z i.e H\nf (z) ij = @2f(z)/@z i @z j , provided it is twice continuously differentiable at z. Assumption 2. The probability density function f(z) satisfies the following: (1) f(z) is twice continuously differentiable and the Hessian matrix H\nf satisfies kH f (z)k2  cd z\nalmost everywhere, where c d\nz\nis only dependent on the dimension.\n(2) R\nf(z)1 1/ddz  c3, 8d 2 where c3 is a constant. Theorem 1. Let (X,Y 0, Z) denote a sample in U 02 produced by Algorithm 1 by modifying the original sample (X, Y, Z) in U1, when supplied with 2n i.i.d samples from the original joint distribution f\nX,Y,Z (x, y, z). Let X,Y,Z (x, y, z) be the distribution of (X, Y 0, Z). Under smoothness assumptions (1) and (2), for any ✏ < ✏1, n large enough, we have:\nd TV\n( , fCI)  b(n)\n, 1 2\ns\n4 c3 ⇤ 21/dz (1/dz) (n\nd\nz\n) 1/d zd\nz\n+\n✏G (2c d\nz\n✏2)\n4\n+ exp\n✓ 1\n2\nn d\nz\nc d\nz\n✏dz+2 ◆ + G 2c\nd\nz\n✏2 .\nHere, d is the volume of the unit radius `2 ball in Rd.\nTheorem 1 characterizes the variational distance of the distribution of a sample generated in Algorithm 1 with that of the conditionally independent distribution fCI . We defer the proof of Theorem 1 to Appendix A. Now, our goal is to characterize the misclassification error of the trained classifier in Algorithm 2 under both H0 and H1. Consider the distribution of the samples in the data-set Dr used for classification in Algorithm 2. Let q(x, y, z|` = 1) be the marginal distribution of each sample with label 1. Similarly, let q(x, y, z|` = 0) denote the marginal distribution of the label 0 samples. Note that under our construction,\nq(x, y, z|` = 1) = f X,Y,Z (x, y, z) = ⇢ fCI(x, y, z) if H0 holds 6= fCI(x, y, z) if H1 holds\nq(x, y, z|` = 0) = X,Y,Z (x, y, z) (2)\nwhere X,Y,Z (x, y, z) is as defined in Theorem 1.\nNote that even though the marginal of each sample with label 0 is X,Y,Z (x, y, z) (Equation (2)), they are not exactly i.i.d owing to the nearest neighbor bootstrap. We will go on to show that they are actually close to i.i.d and therefore classification risk minimization generalizes similar to the i.i.d results for classification [4]. First, we review standard definitions and results from classification theory [4].\nIdeal Classification Setting: We consider an ideal classification scenario for CI testing and in the process define standard quantities in learning theory. Recall that G is the set of classifiers under consideration. Let q̃ be our ideal distribution for q given by q̃(x, y, z|` = 1) = f\nX,Y,Z (x, y, z), q̃(x, y, z|` = 0) = fCI\nX,Y,Z (x, y, z) and q̃(` = 1) = q̃(` = 0) = 0.5. In other words this is the ideal classification scenario for testing CI. Let L(g(u), `) be our loss function for a classifying function g 2 G, for a sample u , (x, y, z) with true label `. In our algorithms the loss function is the 0 1 loss, but our results hold for any bounded loss function s.t. |L(g(u), `)|  |L|. For a distribution q̃\nand a classifier g let R q̃ (g) , E u,`⇠q̃[L(g(u), `)] be the expected risk of the function g. The risk optimal classifier g⇤ q̃ under q̃ is given by g⇤ q̃ , arg min g2G Rq̃(g). Similarly for a set of samples S\nand a classifier g, let R S (g) , 1|S| P\nu,`2S L(g(u), `) be the empirical risk on the set of samples. We define g\nS as the classifier that minimizes the empirical loss on the observed set of samples S that is, g\nS , arg min g2G RS(g).\nIf the samples in S are generated independently from q̃, then standard results from the learning theory states that with probability 1 ,\nR q̃ (g S )  R q̃ (g⇤ q̃ ) + C\nr V\nn +\nr 2 log(1/ )\nn , (3)\nwhere V is the VC dimension [30] of the classification model, C is an universal constant and n = |S|. Guarantees under near-independent samples: Our goal is to prove a result like (3), for the classification problem in Algorithm 2. However, in this case we do not have access to i.i.d samples because the samples in U 02 do not remain independent. We will see that they are close to independent in some sense. This brings us to one of our main results in Theorem 2.\nTheorem 2. Assume that the joint distribution f(x, y, z) satisfies the conditions in Theorem 1. Further assume that f(z) has a bounded Lipschitz constant. Consider the classifier ĝ in Algorithm 2 trained on the set D\nr . Let S = D r . Then according to our definition g S = ĝ. For ✏ > 0 we have:\n(i) R q (g S ) R q (g⇤ q )  n\n, C|L|\np V + r log 1 ! ✓ log(n/ )\nn\n◆1/3 + r 4 d z log(n/ ) + o n (1/✏)\nn\n! + G(✏) ! ,\nwith probability at least 1 8 . Here V is the V.C. dimension of the classification function class, G is as defined in Def. 2, C is an universal constant and |L| is the bound on the absolute value of the loss. (ii) Suppose the loss is L(g(u), `) = 1\ng(u) 6=` (s.t |L|  1). Further suppose the class of classifying functions is such that R\nq (g⇤ q )  r0 + ⌘. Here, r0 , 0.5(1 dTV (q(x, y, z|1), q(x, y, z|0))) is the risk of the Bayes optimal classifier when q(` = 1) = q(` = 0). This is the best loss that any classifier can achieve for this classification problem [4]. Under this setting, w.p at least 1 8 we have:\n1\n2\n1 d\nTV\n(f, fCI)\nb(n) 2  R q (g S )  1 2 1 d TV (f, fCI) + b(n) 2 + ⌘ + n\nwhere b(n) is as defined in Theorem 1.\nWe prove Theorem 2 as Theorem 3 and Theorem 4 in the appendix. In part (i) of the theorem we prove that generalization bounds hold even when the samples are not exactly i.i.d. Intuitively, consider two sample inputs u\ni , u j 2 U1, such that corresponding Z coordinates zi and zj are far away. Then we expect the resulting samples u0\ni and u0 j (in U 02) to be nearly-independent. By carefully capturing this notion of spatial near-independence, we prove generalization errors in Theorem 3. Part (ii) of the theorem essentially implies that the error of the trained classifier will be close to 0.5 (l.h.s) when f ⇠ fCI (under H0). On the other hand under H1 if dTV (f, fCI) > 1 , the error will be less than 0.5( + b(n)) +\nn\nwhich is small."
    }, {
      "heading" : "4 Empirical Results",
      "text" : "In this section we provide empirical results comparing our proposed algorithm and other state of the art algorithms. The algorithms under comparison are: (i) CCIT - Algorithm 3 in our paper where we use XGBoost [6] as the classifier. In our experiments, for each data-set we boot-strap the samples and run our algorithm B times. The results are averaged over B bootstrap runs1. (ii) KCIT - Kernel CI test from [32]. We use the Matlab code available online. (iii) RCIT - Randomized CI Test from [28]. We use the R package that is publicly available.\n1The python package for our implementation can be found here (https://github.com/rajatsen91/CCIT)."
    }, {
      "heading" : "4.1 Synthetic Experiments",
      "text" : "We perform the synthetic experiments in the regime of post-nonlinear noise similar to [32]. In our experiments X and Y are dimension 1, and the dimension of Z scales (motivated by causal settings and also used in [32, 28]). X and Y are generated according to the relation G(F (Z) + ⌘) where ⌘ is a noise term and G is a non-linear function, when the H0 holds. In our experiments, the data is generated as follows: (i) when X ? Y |Z, then each coordinate of Z is a Gaussian with unit mean and variance, X = cos(aT Z + ⌘1) and Y = cos(bT Z + ⌘2). Here, a, b 2 Rdz and kak = kbk = 1. a,b are fixed while generating a single dataset. ⌘1 and ⌘2 are zero-mean Gaussian noise variables, which are independent of everything else. We set V ar(⌘1) = V ar(⌘2) = 0.25. (ii) when X 6? Y |Z, then everything is identical to (i) except that Y = cos(bT Z + cX + ⌘2) for a randomly chosen constant c 2 [0, 2]. In Fig. 2a, we plot the performance of the algorithms when the dimension of Z scales. For generating each point in the plot, 300 data-sets were generated with the appropriate dimensions. Half of them are according to H0 and the other half are from H1 Then each of the algorithms are run on these data-sets, and the ROC AUC (Area Under the Receiver Operating Characteristic curve) score is calculated from the true labels (CI or not CI) for each data-set and the predicted scores. We observe that the accuracy of CCIT is close to 1 for dimensions upto 70, while all the other algorithms do not scale as well. In these experiments the number of bootstraps per data-set for CCIT was set to B = 50. We set the threshold in Algorithm 3 to ⌧ = 1/ p n, which is an upper-bound on the expected variance of the test-statistic when H0 holds."
    }, {
      "heading" : "4.2 Flow-Cytometry Dataset",
      "text" : "We use our CI testing algorithm to verify CI relations in the protein network data from the flowcytometry dataset [26], which gives expression levels of 11 proteins under various experimental conditions. The ground truth causal graph is not known with absolute certainty in this data-set, however this dataset has been widely used in the causal structure learning literature. We take three popular learned causal structures that are recovered by causal discovery algorithms, and we verify CI relations assuming these graphs to be the ground truth. The three graph are: (i) consensus graph from [26] (Fig. 1(a) in [22]) (ii) reconstructed graph by Sachs et al. [26] (Fig. 1(b) in [22]) (iii) reconstructed graph in [22] (Fig. 1(c) in [22]).\nFor each graph we generate CI relations as follows: for each node X in the graph, identify the set Z consisting of its parents, children and parents of children in the causal graph. Conditioned on this set Z, X is independent of every other node Y in the graph (apart from the ones in Z). We use this to create all CI conditions of these types from each of the three graphs. In this process we generate over 60 CI relations for each of the graphs. In order to evaluate false positives of our algorithms, we also need relations such that X 6? Y |Z. For, this we observe that if there is an edge between two nodes, they are never CI given any other conditioning set. For each graph we generate 50 such non-CI relations, where an edge X $ Y is selected at random and a conditioning set of size 3 is randomly selected from the remaining nodes. We construct 50 such negative examples for each graph. In Fig. 2, we display the performance of all three algorithms based on considering each of the three graphs as ground-truth. The algorithms are given access to observational data for verifying CI and non-CI relations. In Fig. 2b we display the ROC plot for all three algorithms for the data-set generated by considering graph (ii). In Table 2c we display the ROC AUC score for the algorithms for the three graphs. It can be seen that our algorithm outperforms the others in all three cases, even when the dimensionality of Z is fairly low (less than 10 in all cases). An interesting thing to note is that the edges (pkc-raf), (pkc-mek) and (pka-p38) are there in all the three graphs. However, all three CI testers CCIT, KCIT and RCIT are fairly confident that these edges should be absent. These edges may be discrepancies in the ground-truth graphs and therefore the ROC AUC of the algorithms are lower than expected."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In this paper we present a model-powered approach for CI tests by converting it into binary classification, thus empowering CI testing with powerful supervised learning tools like gradient boosted trees. We provide an efficient nearest-neighbor bootstrap which makes the reduction to classification possible. We provide theoretical guarantees on the bootstrapped samples, and also risk generalization bounds for our classification problem, under non-i.i.d near independent samples. In conclusion we believe that model-driven data dependent approaches can be extremely useful in general statistical testing and estimation problems as they enable us to use powerful supervised learning tools."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work is partially supported by NSF grants CNS 1320175, NSF SaTC 1704778, ARO grants W911NF-17-1-0359, W911NF-16-1-0377 and the US DoT supported D-STOP Tier 1 University Transportation Center."
    } ],
    "references" : [ {
      "title" : "Robust reductions from ranking to classification",
      "author" : [ "Maria-Florina Balcan", "Nikhil Bansal", "Alina Beygelzimer", "Don Coppersmith", "John Langford", "Gregory Sorkin" ],
      "venue" : "Learning Theory,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2007
    }, {
      "title" : "Conditional probability tree estimation analysis and algorithms",
      "author" : [ "Alina Beygelzimer", "John Langford", "Yuri Lifshits", "Gregory Sorkin", "Alex Strehl" ],
      "venue" : "In Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2009
    }, {
      "title" : "Integrating structured biological data by kernel maximum mean discrepancy",
      "author" : [ "Karsten M Borgwardt", "Arthur Gretton", "Malte J Rasch", "Hans-Peter Kriegel", "Bernhard Schölkopf", "Alex J Smola" ],
      "venue" : "Bioinformatics, 22(14):e49–e57,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2006
    }, {
      "title" : "Theory of classification: A survey of some recent advances",
      "author" : [ "Stéphane Boucheron", "Olivier Bousquet", "Gábor Lugosi" ],
      "venue" : "ESAIM: probability and statistics,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2005
    }, {
      "title" : "Sparsityboost: A new scoring function for learning bayesian network structure",
      "author" : [ "Eliot Brenner", "David Sontag" ],
      "venue" : "arXiv preprint arXiv:1309.6820,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2013
    }, {
      "title" : "Xgboost: A scalable tree boosting system",
      "author" : [ "Tianqi Chen", "Carlos Guestrin" ],
      "venue" : "In Proceedings of the 22Nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2016
    }, {
      "title" : "Learning bayesian networks from data: An efficient approach based on information theory",
      "author" : [ "Jie Cheng", "David Bell", "Weiru Liu" ],
      "venue" : "On World Wide Web at http://www. cs. ualberta. ca/ ̃ jcheng/bnpc. htm,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1998
    }, {
      "title" : "Search-based structured prediction",
      "author" : [ "Hal Daumé", "John Langford", "Daniel Marcu" ],
      "venue" : "Machine learning,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "A new approach for learning belief networks using independence criteria",
      "author" : [ "Luis M De Campos", "Juan F Huete" ],
      "venue" : "International Journal of Approximate Reasoning,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2000
    }, {
      "title" : "A permutation-based kernel conditional independence test",
      "author" : [ "Gary Doran", "Krikamol Muandet", "Kun Zhang", "Bernhard Schölkopf" ],
      "venue" : "In UAI,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2014
    }, {
      "title" : "Dimensionality reduction for supervised learning with reproducing kernel hilbert spaces",
      "author" : [ "Kenji Fukumizu", "Francis R Bach", "Michael I Jordan" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2004
    }, {
      "title" : "Breaking the bandwidth barrier: Geometrical adaptive entropy estimation",
      "author" : [ "Weihao Gao", "Sewoong Oh", "Pramod Viswanath" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2016
    }, {
      "title" : "Demystifying fixed k-nearest neighbor information estimators",
      "author" : [ "Weihao Gao", "Sewoong Oh", "Pramod Viswanath" ],
      "venue" : "arXiv preprint arXiv:1604.03006,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2016
    }, {
      "title" : "Estimating high-dimensional directed acyclic graphs with the pc-algorithm",
      "author" : [ "Markus Kalisch", "Peter Bühlmann" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2007
    }, {
      "title" : "Probabilistic graphical models: principles and techniques",
      "author" : [ "Daphne Koller", "Nir Friedman" ],
      "venue" : "MIT press,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2009
    }, {
      "title" : "Toward optimal feature selection",
      "author" : [ "Daphne Koller", "Mehran Sahami" ],
      "venue" : "Technical report, Stanford InfoLab,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1996
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks. In Advances in neural information processing",
      "author" : [ "Alex Krizhevsky", "Ilya Sutskever", "Geoffrey E Hinton" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2012
    }, {
      "title" : "Reducing t-step reinforcement learning to classification",
      "author" : [ "John Langford", "Bianca Zadrozny" ],
      "venue" : "In Proc. of the Machine Learning Reductions Workshop,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2003
    }, {
      "title" : "Revisiting classifier two-sample tests",
      "author" : [ "David Lopez-Paz", "Maxime Oquab" ],
      "venue" : "arXiv preprint arXiv:1610.06545,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2016
    }, {
      "title" : "On the method of bounded differences",
      "author" : [ "Colin McDiarmid" ],
      "venue" : "Surveys in combinatorics,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1989
    }, {
      "title" : "Rademacher complexity bounds for non-iid processes",
      "author" : [ "Mehryar Mohri", "Afshin Rostamizadeh" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2009
    }, {
      "title" : "Cyclic causal discovery from continuous equilibrium data",
      "author" : [ "Joris Mooij", "Tom Heskes" ],
      "venue" : "arXiv preprint arXiv:1309.6849,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2013
    }, {
      "title" : "Fast k-dimensional tree algorithms for nearest neighbor search with application to vector quantization encoding",
      "author" : [ "V Ramasubramanian", "Kuldip K Paliwal" ],
      "venue" : "IEEE Transactions on Signal Processing,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1992
    }, {
      "title" : "On the rate of multivariate poisson convergence",
      "author" : [ "Bero Roos" ],
      "venue" : "Journal of Multivariate Analysis,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1999
    }, {
      "title" : "Causal protein-signaling networks derived from multiparameter single-cell data",
      "author" : [ "Karen Sachs", "Omar Perez", "Dana Pe’er", "Douglas A Lauffenburger", "Garry P Nolan" ],
      "venue" : null,
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2005
    }, {
      "title" : "Causation, prediction, and search",
      "author" : [ "Peter Spirtes", "Clark N Glymour", "Richard Scheines" ],
      "venue" : "MIT press,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2000
    }, {
      "title" : "Approximate kernel-based conditional independence tests for fast non-parametric causal discovery",
      "author" : [ "Eric V Strobl", "Kun Zhang", "Shyam Visweswaran" ],
      "venue" : "arXiv preprint arXiv:1702.03877,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2017
    }, {
      "title" : "The max-min hill-climbing bayesian network structure learning algorithm",
      "author" : [ "Ioannis Tsamardinos", "Laura E Brown", "Constantin F Aliferis" ],
      "venue" : "Machine learning,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2006
    }, {
      "title" : "On the uniform convergence of relative frequencies of events to their probabilities",
      "author" : [ "Vladimir N Vapnik", "A Ya Chervonenkis" ],
      "venue" : "In Measures of Complexity,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2015
    }, {
      "title" : "Feature selection for high-dimensional genomic microarray data",
      "author" : [ "Eric P Xing", "Michael I Jordan", "Richard M Karp" ],
      "venue" : "In ICML,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2001
    }, {
      "title" : "Kernel-based conditional independence test and application in causal discovery",
      "author" : [ "Kun Zhang", "Jonas Peters", "Dominik Janzing", "Bernhard Schölkopf" ],
      "venue" : "arXiv preprint arXiv:1202.3775,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 14,
      "context" : "1 Introduction Testing datasets for Conditional Independence (CI) have significant applications in several statistical/learning problems; among others, examples include discovering/testing for edges in Bayesian networks [15, 27, 7, 9], causal inference [23, 14, 29, 5] and feature selection through Markov Blankets [16, 31].",
      "startOffset" : 220,
      "endOffset" : 234
    }, {
      "referenceID" : 25,
      "context" : "1 Introduction Testing datasets for Conditional Independence (CI) have significant applications in several statistical/learning problems; among others, examples include discovering/testing for edges in Bayesian networks [15, 27, 7, 9], causal inference [23, 14, 29, 5] and feature selection through Markov Blankets [16, 31].",
      "startOffset" : 220,
      "endOffset" : 234
    }, {
      "referenceID" : 6,
      "context" : "1 Introduction Testing datasets for Conditional Independence (CI) have significant applications in several statistical/learning problems; among others, examples include discovering/testing for edges in Bayesian networks [15, 27, 7, 9], causal inference [23, 14, 29, 5] and feature selection through Markov Blankets [16, 31].",
      "startOffset" : 220,
      "endOffset" : 234
    }, {
      "referenceID" : 8,
      "context" : "1 Introduction Testing datasets for Conditional Independence (CI) have significant applications in several statistical/learning problems; among others, examples include discovering/testing for edges in Bayesian networks [15, 27, 7, 9], causal inference [23, 14, 29, 5] and feature selection through Markov Blankets [16, 31].",
      "startOffset" : 220,
      "endOffset" : 234
    }, {
      "referenceID" : 13,
      "context" : "1 Introduction Testing datasets for Conditional Independence (CI) have significant applications in several statistical/learning problems; among others, examples include discovering/testing for edges in Bayesian networks [15, 27, 7, 9], causal inference [23, 14, 29, 5] and feature selection through Markov Blankets [16, 31].",
      "startOffset" : 253,
      "endOffset" : 268
    }, {
      "referenceID" : 27,
      "context" : "1 Introduction Testing datasets for Conditional Independence (CI) have significant applications in several statistical/learning problems; among others, examples include discovering/testing for edges in Bayesian networks [15, 27, 7, 9], causal inference [23, 14, 29, 5] and feature selection through Markov Blankets [16, 31].",
      "startOffset" : 253,
      "endOffset" : 268
    }, {
      "referenceID" : 4,
      "context" : "1 Introduction Testing datasets for Conditional Independence (CI) have significant applications in several statistical/learning problems; among others, examples include discovering/testing for edges in Bayesian networks [15, 27, 7, 9], causal inference [23, 14, 29, 5] and feature selection through Markov Blankets [16, 31].",
      "startOffset" : 253,
      "endOffset" : 268
    }, {
      "referenceID" : 15,
      "context" : "1 Introduction Testing datasets for Conditional Independence (CI) have significant applications in several statistical/learning problems; among others, examples include discovering/testing for edges in Bayesian networks [15, 27, 7, 9], causal inference [23, 14, 29, 5] and feature selection through Markov Blankets [16, 31].",
      "startOffset" : 315,
      "endOffset" : 323
    }, {
      "referenceID" : 29,
      "context" : "1 Introduction Testing datasets for Conditional Independence (CI) have significant applications in several statistical/learning problems; among others, examples include discovering/testing for edges in Bayesian networks [15, 27, 7, 9], causal inference [23, 14, 29, 5] and feature selection through Markov Blankets [16, 31].",
      "startOffset" : 315,
      "endOffset" : 323
    }, {
      "referenceID" : 5,
      "context" : "(iii) Given the labeled training data-set (from step (ii)), we train powerful classifiers such as gradient boosted trees [6] or deep neural networks [17] which attempt to learn the classes of the samples.",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 16,
      "context" : "(iii) Given the labeled training data-set (from step (ii)), we train powerful classifiers such as gradient boosted trees [6] or deep neural networks [17] which attempt to learn the classes of the samples.",
      "startOffset" : 149,
      "endOffset" : 153
    }, {
      "referenceID" : 18,
      "context" : "e whether X ? Y ), classifiers were recently used in [19].",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 18,
      "context" : "Thus the problem can be converted to a two sample test between a subset of the original samples and the other subset which is permuted - Binary classifiers were then harnessed for this two-sample testing; for details see [19].",
      "startOffset" : 221,
      "endOffset" : 225
    }, {
      "referenceID" : 22,
      "context" : "Finally, our bootstrap is also efficient owing to fast algorithms for identifying nearest-neighbors [24].",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 28,
      "context" : "5(1 dTV (f, f)), V is the VC dimension [30] of the class G.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 3,
      "context" : "We provide a novel analysis of Rademacher complexity bounds [4] under near-independence which is of independent interest.",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 30,
      "context" : "(iv) (Empirical Evaluation) We perform extensive numerical experiments where our algorithm outperforms the state of the art [32, 28].",
      "startOffset" : 124,
      "endOffset" : 132
    }, {
      "referenceID" : 26,
      "context" : "(iv) (Empirical Evaluation) We perform extensive numerical experiments where our algorithm outperforms the state of the art [32, 28].",
      "startOffset" : 124,
      "endOffset" : 132
    }, {
      "referenceID" : 24,
      "context" : "We also apply our algorithm for analyzing CI relations in the protein signaling network data from the flow cytometry data-set [26].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 26,
      "context" : "Most of the recent work in CI testing are kernel based [28, 32, 10].",
      "startOffset" : 55,
      "endOffset" : 67
    }, {
      "referenceID" : 30,
      "context" : "Most of the recent work in CI testing are kernel based [28, 32, 10].",
      "startOffset" : 55,
      "endOffset" : 67
    }, {
      "referenceID" : 9,
      "context" : "Most of the recent work in CI testing are kernel based [28, 32, 10].",
      "startOffset" : 55,
      "endOffset" : 67
    }, {
      "referenceID" : 10,
      "context" : "Many of these works build on the study in [11], where non-parametric CI relations are characterized using covariance operators for Reproducing Kernel Hilbert Spaces (RKHS) [11].",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 10,
      "context" : "Many of these works build on the study in [11], where non-parametric CI relations are characterized using covariance operators for Reproducing Kernel Hilbert Spaces (RKHS) [11].",
      "startOffset" : 172,
      "endOffset" : 176
    }, {
      "referenceID" : 30,
      "context" : "KCIT [32] uses the partial association of regression functions relating X , Y , and Z.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 26,
      "context" : "RCIT [28] is an approximate version of KCIT that attempts to improve running times when the number of samples are large.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 9,
      "context" : "KCIPT [10] is perhaps most relevant to our work.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 9,
      "context" : "In [10], a specific permutation of the samples is used to simulate data from fCI .",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 9,
      "context" : "Finally the two-sample test in [10] is based on a kernel method [3], while we use binary classifiers for the same purpose.",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 2,
      "context" : "Finally the two-sample test in [10] is based on a kernel method [3], while we use binary classifiers for the same purpose.",
      "startOffset" : 64,
      "endOffset" : 67
    }, {
      "referenceID" : 12,
      "context" : "There has also been recent work on entropy estimation [13] using nearest neighbor techniques (used for density estimation); this can subsequently be used for CI testing by estimating the conditional mutual information I(X; Y |Z).",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 18,
      "context" : "Binary classification has been recently used for two-sample testing, in particular for independence testing [19].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 3,
      "context" : "Our analysis of generalization guarantees of classification are aimed at recovering guarantees similar to [4], but in a non-i.",
      "startOffset" : 106,
      "endOffset" : 109
    }, {
      "referenceID" : 20,
      "context" : "d generalization guarantees), there has been recent work in proving Rademacher complexity bounds for -mixing stationary processes [21].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 1,
      "context" : "This work also falls in the category of machine learning reductions, where the general philosophy is to reduce various machine learning settings like multi-class regression [2], ranking [1], reinforcement learning [18], structured prediction [8] to that of binary classification.",
      "startOffset" : 173,
      "endOffset" : 176
    }, {
      "referenceID" : 0,
      "context" : "This work also falls in the category of machine learning reductions, where the general philosophy is to reduce various machine learning settings like multi-class regression [2], ranking [1], reinforcement learning [18], structured prediction [8] to that of binary classification.",
      "startOffset" : 186,
      "endOffset" : 189
    }, {
      "referenceID" : 17,
      "context" : "This work also falls in the category of machine learning reductions, where the general philosophy is to reduce various machine learning settings like multi-class regression [2], ranking [1], reinforcement learning [18], structured prediction [8] to that of binary classification.",
      "startOffset" : 214,
      "endOffset" : 218
    }, {
      "referenceID" : 7,
      "context" : "This work also falls in the category of machine learning reductions, where the general philosophy is to reduce various machine learning settings like multi-class regression [2], ranking [1], reinforcement learning [18], structured prediction [8] to that of binary classification.",
      "startOffset" : 242,
      "endOffset" : 245
    }, {
      "referenceID" : 30,
      "context" : "d samples from the joint distributions of random variables/vectors [32, 10, 28].",
      "startOffset" : 67,
      "endOffset" : 79
    }, {
      "referenceID" : 9,
      "context" : "d samples from the joint distributions of random variables/vectors [32, 10, 28].",
      "startOffset" : 67,
      "endOffset" : 79
    }, {
      "referenceID" : 26,
      "context" : "d samples from the joint distributions of random variables/vectors [32, 10, 28].",
      "startOffset" : 67,
      "endOffset" : 79
    }, {
      "referenceID" : 11,
      "context" : "Analogous assumptions have been made on the Hessian of the density in the context of entropy estimation [12].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 12,
      "context" : "The smoothness assumptions (in Assumption 2) is a subset of the assumptions made in [13] (Assumption 1, Page 5) for entropy estimation.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 3,
      "context" : "First, we review standard definitions and results from classification theory [4].",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 28,
      "context" : "q̃ ) + C r V n + r 2 log(1/ ) n , (3) where V is the VC dimension [30] of the classification model, C is an universal constant and n = |S|.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 3,
      "context" : "This is the best loss that any classifier can achieve for this classification problem [4].",
      "startOffset" : 86,
      "endOffset" : 89
    }, {
      "referenceID" : 5,
      "context" : "The algorithms under comparison are: (i) CCIT - Algorithm 3 in our paper where we use XGBoost [6] as the classifier.",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 26,
      "context" : "(iii) RCIT - Randomized CI Test from [28].",
      "startOffset" : 37,
      "endOffset" : 41
    } ],
    "year" : 2017,
    "abstractText" : "We consider the problem of non-parametric Conditional Independence testing (CI testing) for continuous random variables. Given i.i.d samples from the joint distribution f(x, y, z) of continuous random vectors X, Y and Z, we determine whether X ? Y |Z. We approach this by converting the conditional independence test into a classification problem. This allows us to harness very powerful classifiers like gradient-boosted trees and deep neural networks. These models can handle complex probability distributions and allow us to perform significantly better compared to the prior state of the art, for high-dimensional CI testing. The main technical challenge in the classification problem is the need for samples from the conditional product distribution fCI(x, y, z) = f(x|z)f(y|z)f(z) – the joint distribution if and only if X ? Y |Z. – when given access only to i.i.d. samples from the true joint distribution f(x, y, z). To tackle this problem we propose a novel nearest neighbor bootstrap procedure and theoretically show that our generated samples are indeed close to fCI in terms of total variational distance. We then develop theoretical results regarding the generalization bounds for classification for our problem, which translate into error bounds for CI testing. We provide a novel analysis of Rademacher type classification bounds in the presence of non-i.i.d nearindependent samples. We empirically validate the performance of our algorithm on simulated and real datasets and show performance gains over previous methods.",
    "creator" : "LaTeX with hyperref package"
  }
}