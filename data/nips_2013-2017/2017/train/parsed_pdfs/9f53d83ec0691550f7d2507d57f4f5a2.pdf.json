{
  "name" : "9f53d83ec0691550f7d2507d57f4f5a2.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Translation Synchronization via Truncated Least Squares",
    "authors" : [ "Xiangru Huang", "Zhenxiao Liang" ],
    "emails" : [ "xrhuang@cs.utexas.edu", "liangzx14@mails.tsinghua.edu.cn", "bajaj@cs.utexas.edu", "huangqx@cs.utexas.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "In this paper, we introduce a robust algorithm, TranSync, for the 1D translation synchronization problem, in which the aim is to recover the global coordinates of a set of nodes from noisy measurements of relative coordinates along an observation graph. The basic idea of TranSync is to apply truncated least squares, where the solution at each step is used to gradually prune out noisy measurements. We analyze TranSync under both deterministic and randomized noisy models, demonstrating its robustness and stability. Experimental results on synthetic and real datasets show that TranSync is superior to state-of-the-art convex formulations in terms of both efficiency and accuracy."
    }, {
      "heading" : "1 Introduction",
      "text" : "In this paper, we are interested in solving the 1D translation synchronization problem, where the input is encoded as an observation graph G = (V, E) with n nodes (i.e. V = {1, · · · , n}). Each node is associated with a latent coordinate x?i ∈ R, 1 ≤ i ≤ n, and each edge (i, j) ∈ E is associated with a noisy measurement tij = x?i − x?j +N ( ij) of the coordinate difference xi − xj under some noise model N ( ij). The goal of translation synchronization is to recover the latent coordinates (up to a global shift) from these noisy pairwise measurements. Translation synchronization is a fundamental problem that arises in many application domains, including joint alignment of point clouds [7] and ranking from relative comparisons [8, 16].\nA standard approach to translation synchronization is to solve the following linear program:\nminimize ∑\n(i,j)∈E |tij − (xi − xj)|, subject to n∑ i=1 xi = 0, (1)\nWhere the constraint ensures that the solution is unique. The major drawback of the linear programming formulation is that it can only tolerate up to 50% of measurements coming from biased noise models (e.g., uniform samples with non-zero mean). Moreover, it is challenging to solve (1) efficiently at scale. Solving (1) using interior point method becomes impractical for large-scale datasets, while more scalable methods such as coordinate descent usually exhibit slow convergence.\n31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, USA.\nIn this paper, we introduce a robust and scalable algorithm, TranSync, for translation synchronization. The algorithm is rather simple, we solve a truncated least squares at each iteration k:\n{x(k)i } = argmin {xi} ∑ (i,j)∈E wij |tij − (xi − xj)|2, subject to n∑ i=1 √ dixi = 0, di := ∑ j∈N (i) wij . (2) where the weights wij = Id(|tij − (x(k−1)i − x (k−1) j )| < δk) are obtained from the solution at the previous iteration using a geometrically decaying truncation parameter δk. Although TranSync requires solving a linear system at each step, these linear systems are fairly similar to each other, meaning that the solution at the previous iteration provides an excellent warm-start for solving the linear system at the current iteration. As a result, the computational efficiency of TranSync is superior to state-of-the-art methods for solving the linear programming formulation. We analyze TranSync under both deterministic and randomized noise models, demonstrating its robustness and stability. In particular, we show that TranSync is able to handle biased noisy measurements.\nWe have evaluated TranSync on both synthetic datasets and real datasets used in the applications of joint alignment of point clouds and ranking from pair-wise measurements. Experimental results show that TranSync is superior to state-of-the-art solvers for the linear programming formulation in terms of both computational efficiency and accuracy."
    }, {
      "heading" : "1.1 Related Work",
      "text" : "Translation synchronization falls into the general problem of map synchronization, which takes maps computed between pairs of objects as input, and outputs consistent maps across all the objects. Map synchronization appears as a crucial step in many scientific problems, including fusing partially overlapping range scans [15], assembling fractured surfaces [14], solving jigsaw puzzles [5, 11], multi-view structure from motion [25], data-driven shape analysis and processing [17], and structure from motion [27].\nEarly methods for map synchronization focused on applying greedy algorithms [14, 15, 18] or combinatorial optimization [20, 23, 27]. Although these methods exhibit certain empirical success, they lack theoretical understanding (e.g. we do not know under what conditions can the underlying ground-truth maps be exactly recovered).\nRecent methods for map synchronization apply modern optimization techniques such as convex optimization and non-convex optimization. In [13], Huang and Guibas introduce a semidefinite programming formulation for permutation synchronization and its variants. Chen et al. [4] generalize the method to partial maps. In [26], Wang and Singer introduce a method for rotation synchronization. Although these methods provide tight, exact recovery conditions, the computational cost of the convex optimizations provide an obstruction for applying these methods to large-scale data sets.\nIn contrast to convex optimization, very recent map synchronization methods leverage non-convex optimization approaches such as spectral techniques and gradient-based optimization. In [21, 22], Pachauri et al. study map synchronization from the perspective of spectral decomposition. Recently, Shen et al. [24] provide an analysis of spectral techniques for permutation synchronization. Beyond spectral techniques, Zhou et al. [28] apply alternating minimization for permutation synchronization. Finally, Chen and Candes [3] introduce a method for the generalized permutation synchronization problem using the projected power method. To the best of our knowledge, we are the first to develop and analyze continuous map synchronizations (e.g., translations or rotations) beyond convex optimization.\nOur approach can be considered as a special case of reweighted least squares (or RLS) [9, 12], which is a powerful method for solving convex and non-convex optimizations. The general RLS framework has been applied for map synchronization (e.g. see [1, 2]). Despite the empirical success of these approaches, the theoretical understanding of RLS remains rather limited. The analysis in this paper provides a first step towards the understanding of RLS for map synchronization."
    }, {
      "heading" : "1.2 Notation",
      "text" : "Before proceeding to the technical part of this paper, we introduce some notation that will be used later. The unnormalized graph Laplacian of a graph G is denoted as LG. If it is obvious from the\nAlgorithm 1 TranSync(c, kmax)\n1. x(−1) ← 0. δ−1 ←∞. for k = 0, 1, 2, kmax do\n2. Obtain the truncated graph G(k) using x(k−1) and δk−1. 3. Break if G(k) is disconnected 4. Solve (2) using (4) to obtain x(k). 5. δk = min ( max (i,j)∈E |tij − (x(0)i − x (0) j )|, cδk−1 ) .\nend for Output: x(k).\ncontext, we will always shorten LG as L to make the notation uncluttered. Similarly, we will use D = diag(d1, · · · , dn) to collect the vertex degrees and denote the vertex adjacency and vertex-edge adjacency matrices as A and B respectively. The peusdo-inverse of a matrix X is given by X+. In addition, we always sort the eigenvalues of a symmetric matrix X ∈ Rn×n in increasing order (i.e. λ1(X) ≤ λ2(X) ≤ · · · ≤ λn(X)). Moreover, we will consider several matrix norms ‖ · ‖, ‖ · ‖1,∞ and ‖ · ‖F , which are defined as follows:\n‖X‖ = σmax(X), ‖X‖1,∞ = max 1≤i≤n n∑ j=1 |xij |, ‖X‖F = (∑ i,j x2ij ) 1 2 .\nNote that ‖X‖1,∞ is consistent with the L∞-norm of vectors."
    }, {
      "heading" : "2 Algorithm",
      "text" : "In this section, we provide the algorithmic details of TranSync. The iterative scheme (1) requires an initial solution x(0), an initial truncation parameter δ0, and a stopping condition. The initial solution can be determined by solving for x(0) from (2) w.r.t. wij = 1. We set the initial truncation parameter δ0 = max\n(i,j)∈E |tij − (x(0)i − x (0) j )|, so that the edge with the biggest residual is removed. We stop\nTranSync either after the maximum number of iterations is reached, or the truncated graph becomes disconnected. Algorithm 1 provides the pseudo code of TranSync.\nClearly, the performance of TranSync is driven by the efficiency of solving (2) at each iteration. TranSync takes an iterative approach, in which we utilize a warm-start x(k−1) provided by the solution obtained at the previous iteration. When the truncated graph is non-bipartite, we find a simple weighted average scheme delivers satisfactory computational efficiency. Specifically, it generates a series of vectors xk,0 = x(k−1), xk,1, · · · , xk,nmax via the following recursion:\nxk,l+1i = (1− ) ∑\nj∈N (i)\nwij(x k,l j + tij)/ ∑ j∈N (i) wij + x k,l i (3)\nxk,l+1i = x k,l+1 i − 1∑n i′=1 √ di n∑ i′=1 √ di′x k,l+1 i′ , (4)\nwhich may be written in the following matrix form:\nxk,l+1 = (In − 1\nn D− 1 2 11TD 1 2 )[(1− )D−1\n( Axk,l +Bt(k) ) + xk,l], (5)\nHere we add the parameter to create a small perturbation to avoid the special case of bipartite graphs. For non-bipartite graphs, can be set to zero.\nRemark 2.1 The corresponding normalization constraint in (4), i.e., ∑ i √ dixi = 0, only changes the solution to (2) by a constant factor. We utilize this modification for the purpose of obtaining a concise convergence property of the iterative scheme detailed below.\nThe following proposition states that (4) admits a geometric convergence rate:\nProposition 2.1 xk,l geometrically converges to x(k+1). Specifically, ∀l ≥ 0,\n‖D 12 ( xk,l − x(k)shift ) ‖ ≤ (1− (1− )ρ)l‖D 12 ( xk,0 − x(k)shift ) ‖, x(k)shift = x (k) − ∑ i √ dix (k) i∑\ni\n√ di 1.\nwhere ρ < 1 is the spectral gap of the normalized Graph Laplacian of the truncated graph.\nProof. See Appendix A.\nSince the intermediate solutions are mainly used to prune outlier observations, it is clear that O(log(n)) iterations of (5), which induce a O(1/n) error for solving (2), are sufficient. The complexity of checking if the graph is non-bapriatite is O(|E|). The total running time for solving (2) is thus O ( |E| log(n) ) . This means the total running time of TranSync is O(|E| log(n)kmax), making it scalable to large-scale datasets."
    }, {
      "heading" : "3 Analysis of TranSync",
      "text" : "In this section, we provide exact recovery conditions of TranSync. We begin with describing an exact recovery condition under a deterministic noise model in Section 3.1. We then study an exact recovery condition to demonstrate that TranSync can handle biased noisy samples in Section 3.2."
    }, {
      "heading" : "3.1 Deterministic Exact Recovery Condition",
      "text" : "We consider the following deterministic noisy model: We are given the ground-truth location xgt . Then, for each correct measurement tij , (i, j) ∈ G, |tij − (xgti − x gt j )| ≤ σ for a threshold σ. In contrast, each incorrect measurement tij , (i, j) ∈ G could take any real number. The following theorem provides an exact recovery condition under this noisy model.\nTheorem 3.1 Let dbad be the maximum number of incorrect measurements per node. Define\nα = max k L†G,kk + max i 6=j L†G,ij + n 2 max i,j,k\npairwisely different\n|L†G,ki − L † G,kj |,\nand\nh = αdbad, p = dbadα\n1− 2h , q = (n− dbad)α 1− 2h .\nSuppose h < 16 (or p < 1 4 ), then starting from any initial solution x (0), and for any large enough initial truncation threshold ≥ 2‖x(0)‖∞ + σ and iterative step size c satisfying 4p < c < 1, we have ‖x(k) − xgt‖∞ ≤ qσ + 2p ck−1, where\nk ≤ − log ( (c− 4p) (1 + 2q)σ ) / log c+ 1.\nMoreover, we can eventually reach an x(k) such that\n‖x(k)‖∞ ≤ 2p+ cq\nc− 4p σ\nwhich is independent of the initial solution x(0), initial truncation threshold , and values of all wrong measurements tG\\Ggood .\nProof: See Appendix B.\nTheorem 3.1 essentially says that TransSync can tolerate a constant fraction of arbitrary noise. To understand how strong this condition is, we consider the case where G = Kn is given by a clique. Moreover, we assume the nodes are divided into two clusters of equal size, where all the measurements within each cluster are correct. For measurements between different clusters, half of them are correct and the other half are wrong. In this case, 25% of all measurements are wrong. However, we cannot recover the original xgt in this case. In fact, we can set the wrong measurements in a consistent\nmanner, i.e tij = x gt i − x gt j + b for a constant b 6= 0, leading to two competing clusters (one correct and the other one incorrect) with equal strength. Hence, in the worst case, any algorithm can only tolerate at most 25% of measurements being wrong.\nWe now try to use Theorem 3.1 to analyze the case where the observation graph is a clique. In this case, it is clear that α = 1n , and p = dbad n , i.e the fraction of wrong measurements out of all measurements. Hence, in the clique case, we have shown that TranSync converges to a neighborhood of the ground truth from any initial solution if the fraction of wrong measurements is less that 16 (i.e., 2/3 of the upper bound)."
    }, {
      "heading" : "3.2 Biased Random Noisy Model",
      "text" : "We proceed to provide an exact recovery condition of TranSync under a biased random noisy model. To simplify the discussion, we assume the observation graph G = Kn is a clique. However, our analysis framework can be extended to handle arbitrary graphs.\nAssume σ << a + b. We consider the following noise model, where the noisy measurements are independent, and they follow\ntij =\n{ xgti − x gt j + U [−σ, σ] with probability p\nxgti − x gt j + U [−a, b] with probability 1− p\n(6)\nIt is easy to check that the linear programming formulation is unable to recover the ground-truth solution if ba+b (1− p) > 1 2 . The following theorem shows that TranSync achieves a sub-constant recovery rate instead.\nTheorem 3.2 There exists a constant c so that if p > c/ √ log(n), then w.h.p,\n‖x(k) − xgt‖∞ ≤ (1− p/2)k(b− a), ∀ k = 0, · · · , [− log( b+ a\n2σ )/log(1− p/2)].\nThe major difficulty of proving Theorem 3.2 is that x(k) is dependent on tk, making it hard to control x(k) using existing concentration bounds. We address this issue by showing that the solutions x(k), k = 0, · · · , stay close to the segment between xgt and xgt + (1 − p)a+b2 1. Specifically, for points on this segment, we can leverage the independence of tij to derive the following concentration bound for one step of TranSync:\nLemma 3.1 Consider a fixed observation graph G. Let r = (a+b)p(a+b)p+2(1−p)δ and dmin be the minimum degree of G. Suppose dmin = Ω(log2(n)), and p + r(1 − p) = Ω(log2(n)/dmin) . Consider an initial point x(0) (independent from tij) and a threshold parameter δ such that −a+ δ ≤ mini x (0) i ≤ maxi x (0) i ≤ b− δ. Then w.h.p., one step of TranSync outputs x(1) which satisfies\n‖x(1) − (1− r)x(0) + rxgt)‖∞\n= O\n(√ log(n)\n(p+ r(1− p))dminλ2(LG) )\n) · √\nmax(‖x(0)‖2d,∞, r 2) +O (p r σ2 ) ,\nwhere ‖x(0)‖d,∞ = max 1≤i,j≤n |x(0)i − x (0) j |, and LG is the normalized graph Laplacian of G.\nProof: See Appendix C.1.\nRemark 3.1 Note that when G is a clique or a graph sampled from the standard Erdős-Rényi model G(n, q), then O(\n√ ρ log(n) (p+r(1−p))λ2(LG) ) = O( √ log(n) (p+r(1−p))n ).\nTo prove Theorem 3.2, we show that when k = O(log 3 4 (n)), the L∞ distance between x(k) to the line segment between xgt and xgt + (1− p)a+b2 1 only grows geometrically, and this distance is in the order of o(p). On the other hand, (1− p/2)k = o(p). So when k ≥ k, that distance decays with a geometrical rate that is small than c. The details are deferred to Appendix C.2.\nImproving recovery rate via sample splitting. Note that Lemma 3.1 enables us to apply standard sampling tricks to improve the recovery rate. To simplify the discussion, we will assume σ is sufficiently small. First of all, it is clear that if re-sampling is allowed at each iteration, then TranSync admits a recovery rate of O( log(n)√\ndmin ). When re-sampling is not allowed, we can improve the recovery\nrate by dividing the observations into O( log(n)√ n ) independent sets, and apply one set of observations at each iteration. In this case, the recovery rate is O( log 2(n)√ n\n). These recovery rates suggest that the recovery rate in Theorem 3.2 could potentially be improved. Nevertheless, Theorem 3.2 still shows that TranSync can tolerate a sub-constant recovery rate, which is superior to the linear programming formulation."
    }, {
      "heading" : "4 Experimental Results",
      "text" : "In this section, we provide a detailed experimental evaluation of the proposed translation synchronization (TranSync) method. We begin with describing the experimental setup in Section 4.1. We then perform evaluations on synthetic and real datasets in Section 4.2 and Section 4.3 respectively."
    }, {
      "heading" : "4.1 Experimental Setup",
      "text" : "Datasets. We employ both synthetic datasets and real datasets for evaluation. The synthetic data is generated following the noisy model described in (6). In the following, we encode the noisy model asM(G, p, σ), where G is the observation graph, p is the fraction of correct measurements, and σ describes the interval of correct measurements. Besides the synthetic data, we also consider two real datasets coming from the applications of joint alignment of point clouds and global ranking from relative rankings.\nBaseline comparison. We choose coordinate descent for solving (1) as the baseline algorithm. Specifically, denote the solution of xi, 1 ≤ i ≤ n at iteration k as x(k)i . Then {x (k) i } are given by the following recursion:\nx (k) i = arg min\nxi\n∑ j∈N (i) |xi − (x(k−1)j − tij)|\n= median j∈N (i)\n{x(k−1)j − tij}, 1 ≤ i ≤ n, k = 1, 2, · · · , (7)\nWe use the same initial starting point as TranSync. We also tested interior point methods, and all the datasets used in our experiments are beyond their reach.\nEvaluation protocol. We report the min, median, and max of the coordinate-wise difference between the solution of each algorithm and the underlying ground-truth. We also report the total running time of each algorithm on each dataset (See Table 1)."
    }, {
      "heading" : "4.2 Experimental Evaluation on Synthetic Datasets",
      "text" : "We generate the synthetic datasets by sampling from four kinds of observation graphs and two values of σ, i.e. σ ∈ {0.01, 0.04}. The graphs are generated according to two modes: 1) dense graphs versus sparse graphs, and 2) regular graphs versus irregular graphs. To illustrate the strength of TranSync, we choose p ∈ {0.4, 0.8} for dense graphs and p ∈ {0.8, 1.0} for sparse graphs. Below is a detailed descriptions for all kinds of observation graphs generated.\n• Gdr (dense, regular): The first graph contains n = 2000 nodes. Independently, we connect an edge between a pair of vertices vi, vj with a fixed probability p = 0.1. The expected degree of each vertex is 200.\n• Gdi (dense, irregular): The second graph contains n = 2000 nodes. Independently, we connect an edge between a pair of vertices vi, vj with probability p = 0.4sisj , where si = 0.2+0.6 i−1 n−1 , 1 ≤ i ≤ n are scalar values associated the vertices. The expected degree\nof each vertex is about 200.\n• Gsr (sparse, regular): The third graph is generated in a similar fashion as the first graph, except that the number of nodes n = 20K, and the connecting probability is set to p = 0.003. The expected degree of each vertex is 60. • Gsi (sparse, irregular): The fourth graph is generated in a similar fashion as the second\ngraph, except that the number of nodes n = 20K, and the connecting probability between a pair of vertices is p = 0.1sisj , where si = 0.07 + 0.21 i−1n−1 , 1 ≤ i ≤ n are scalar values associated the vertices. The expected degree of each vertex is about 60.\nFor this experiment, instead of using kmax as stopping condition as in Algorithm 1, we stop when we observe δk < δmin. Here δmin does not need to be close to σ. In fact, we choose δmin = 0.05, 0.1 for σ = 0.01, 0.04, respectively. We also claim that if a small validation set (with size significantly less than n) of correct observations is available, our performance could be further improved.\nAs illustrated in Table 1, TranSync dominates coordinate descent in terms of both accuracy and prediction. In particular, TranSync is significantly better than coordinate descent on dense graphs in terms of accuracy. In particular, on dense but irregular graphs, coordinate descent did not converge at all when p = 0.8. The main advantage of TranSync on sparse graphs is the computational cost, although the accuracy is still considerably better than coordinate descent."
    }, {
      "heading" : "4.3 Experimental Evaluation on Real Datasets",
      "text" : "Translation synchronization for joint alignment of point clouds. In the first application, we consider the problem of joint alignment of point clouds from pair-wise alignment [10]. To this end, we utilize the Patriot Circle Lidar dataset1. We uniformly subsampled the dataset to 6K scans. We applied Super4PCS [19] to match each scan to 300 randomly selected scans, where each match returns a pair-wise rigid transformation and a score. We then pick the top-30 matches for each scan, this results in a graph with 140K edges. To create the input data for translation synchronization, we run the state-of-the-art rotation synchronization algorithm described in [2] to estimate a global pose Ri for each scan. The pair-wise measurement tij from node i to node j is then given by RTi t local ij , where tlocalij is the translation vector obtained in pair-wise matching. The average outlier ratio of the pair-wise matches per node is 35%, which is relatively high since the observation graph is fairly sparse. Since tij is a 3D vector, we run TranSync three times, one for each coordinate. As illustrated in Figure 1, TranSync is able to recover the the global shape of the underlying scanning trajectory. In contrast, coordinate descent completely fails on this dataset.\n1http://masc.cs.gmu.edu/wiki/MapGMU\nRanking from relative comparisons. In the second application, we apply TranSync to predict global rankings of Netflix movies from their relative comparisons provided by users. The Netflix dataset contains 17070 movies that were rated between October, 1998 and December, 2005. We adapt the procedure described in [16] to generate the input data. Specifically, for each pair of movies, we average the relative ratings from the same users within the same month. We only consider a relative measurement if we collect more than 10 such relative ratings. We then apply TranSync to predict the global rankings of all the movies. We report the initial prediction obtained by the first step of TranSync (i.e., all the relative comparisons are used) and the final prediction suggested by TranSync (i.e., after removing inconsistent relative comparisons).\nTable 2 compares TranSync with HodgeRank [16] on six representative movies that are studied in [16]. The experimental results show that both predictions appear to be more consistent with MRQE2 (the largest online directory of movie reviews on the internet) than HodgeRank [16] and its variants, which were only applied on these six movies in isolation. Moreover, the final prediction is superior to the initial prediction. These observations indicate two key advantages of TranSync, i.e., scalability on large-scale datasets and robustness to noisy relative comparisons."
    }, {
      "heading" : "5 Conclusions and Future Work",
      "text" : "In this paper, we have introduced an iterative algorithm for solving the translation synchronization problem, which estimates the global locations of objects from noisy measurements of relative locations. We have justified the performance of our approach both experimentally and theoretically under both deterministic and randomized conditions. Our approach is more scalable and accurate than the standard linear programming formulation. In particular, when the pair-wise measurement\n2http://www.mrqe.com\nis biased, our approach can still achieve sub-constant recovery rate, while the linear programming approach can tolerate no more than 50% of the measurements being biased.\nIn the future, we plan to extend this iterative scheme to other synchronization problems, such as synchronizing rotations and point-based maps. Moreover, it would also be interesting to study variants of the iterative scheme such as re-weighted least squares. We would also like to close the gap between the current recovery rate and the lower bound, which exhibits a poly-log factor. This requires developing new tools for analyzing the iterative algorithm.\nAcknowledgement. Qixing Huang would like to acknowledge support this research from NSF DMS1700234. Chandrajit Bajaj would like to acknowledge support for this research from the National Institute of Health grants #R41 GM116300 and #R01 GM117594."
    } ],
    "references" : [ {
      "title" : "Robust rotation synchronization via low-rank and sparse matrix decomposition",
      "author" : [ "F. Arrigoni", "A. Fusiello", "B. Rossi", "P. Fragneto" ],
      "venue" : "CoRR, abs/1505.06079,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Efficient and robust large-scale rotation averaging",
      "author" : [ "A. Chatterjee", "V.M. Govindu" ],
      "venue" : "2013 IEEE International Conference on Computer Vision (ICCV). IEEE,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "The projected power method: An efficient algorithm for joint alignment from pairwise differences",
      "author" : [ "Y. Chen", "E.J. Candès" ],
      "venue" : "CoRR, abs/1609.05820,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Near-optimal joint object matching via convex relaxation",
      "author" : [ "Y. Chen", "L.J. Guibas", "Q. Huang" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2014
    }, {
      "title" : "A probabilistic image jigsaw puzzle solver",
      "author" : [ "T.S. Cho", "S. Avidan", "W.T. Freeman" ],
      "venue" : "IEEE Conference on Computer Vision and Pattern Recognition (CVPR),",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "The spectral gap of a random subgraph of a graph",
      "author" : [ "F.R.K. Chung", "P. Horn" ],
      "venue" : "Internet Mathematics, 4(2):225–244,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Discrete-continuous optimization for large-scale structure from motion",
      "author" : [ "D. Crandall", "A. Owens", "N. Snavely", "D. Huttenlocher" ],
      "venue" : "Proceedings of the 2011 IEEE Conference on Computer Vision and Pattern Recognition, CVPR ’11, pages 3001–3008,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Tackling class imbalance with ranking",
      "author" : [ "R. Cruz", "K. Fernandes", "J.S. Cardoso", "J.F.P. da Costa" ],
      "venue" : "In 2016 International Joint Conference on Neural Networks,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2016
    }, {
      "title" : "Robust global registration",
      "author" : [ "N. Gelfand", "N.J. Mitra", "L.J. Guibas", "H. Pottmann" ],
      "venue" : "Proceedings of the Third Eurographics Symposium on Geometry Processing, SGP ’05, Aire-la-Ville, Switzerland, Switzerland,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "A global approach to automatic solution of jigsaw puzzles",
      "author" : [ "D. Goldberg", "C. Malon", "M. Bern" ],
      "venue" : "Proceedings of the Eighteenth Annual Symposium on Computational Geometry, SCG ’02, pages 82–87,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Design of an s function for robust regression using iteratively reweighted least squares",
      "author" : [ "R.M. Heiberger", "R.A. Becker" ],
      "venue" : "pages 112–116,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "Consistent shape maps via semidefinite programming",
      "author" : [ "Q. Huang", "L. Guibas" ],
      "venue" : "Computer Graphics Forum, Proc. Eurographics Symposium on Geometry Processing (SGP), 32(5):177–186,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Reassembling fractured objects by geometric matching",
      "author" : [ "Q.-X. Huang", "S. Flöry", "N. Gelfand", "M. Hofer", "H. Pottmann" ],
      "venue" : "ACM SIGGRAPH 2006 Papers, SIGGRAPH ’06, pages 569–578,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Automatic Three-dimensional Modeling from Reality",
      "author" : [ "D. Huber" ],
      "venue" : "PhD thesis, Robotics Institute, Carnegie Mellon University, Pittsburgh, PA, December",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Statistical ranking and combinatorial hodge theory",
      "author" : [ "X. Jiang", "L. Lim", "Y. Yao", "Y. Ye" ],
      "venue" : "Math. Program., 127(1):203–244,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Exploring collections of 3D models using fuzzy correspondences",
      "author" : [ "V.G. Kim", "W. Li", "N. Mitra", "S. DiVerdi", "T. Funkhouser" ],
      "venue" : "Transactions on Graphics (Proc. of SIGGRAPH 2012), 31(4), Aug.",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Mitochondrial dna as a genomic jigsaw puzzle",
      "author" : [ "W. Marande", "G. Burger" ],
      "venue" : "Science, 318:5849, July",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Super 4pcs fast global pointcloud registration via smart indexing",
      "author" : [ "N. Mellado", "D. Aiger", "N.J. Mitra" ],
      "venue" : "Computer Graphics Forum, 33(5):205–215,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "An optimization approach to improving collections of shape maps",
      "author" : [ "A. Nguyen", "M. Ben-Chen", "K. Welnicka", "Y. Ye", "L. Guibas" ],
      "venue" : "Eurographics Symposium on Geometry Processing (SGP), pages 1481–1491,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Permutation diffusion maps (pdm) with application to the image association problem in computer vision",
      "author" : [ "D. Pachauri", "R. Kondor", "G. Sargur", "V. Singh" ],
      "venue" : "Z. Ghahramani, M. Welling, C. Cortes, N. D. Lawrence, and K. Q. Weinberger, editors, Advances in Neural Information Processing Systems 27, pages 541–549. Curran Associates, Inc.,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Solving the multi-way matching problem by permutation synchronization",
      "author" : [ "D. Pachauri", "R. Kondor", "V. Singh" ],
      "venue" : "C. Burges, L. Bottou, M. Welling, Z. Ghahramani, and K. Weinberger, editors, Advances in Neural Information Processing Systems 26, pages 1860–1868. Curran Associates, Inc.,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Structure from motion for scenes with large duplicate structures",
      "author" : [ "R. Roberts", "S.N. Sinha", "R. Szeliski", "D. Steedly" ],
      "venue" : "pages 3137–3144. Computer Vision and Patter Recognition, June",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Normalized spectral map synchronization",
      "author" : [ "Y. Shen", "Q. Huang", "N. Srebro", "S. Sanghavi" ],
      "venue" : "D. D. Lee, M. Sugiyama, U. V. Luxburg, I. Guyon, and R. Garnett, editors, Advances in Neural Information Processing Systems 29, pages 4925–4933.",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Photo tourism: Exploring photo collections in 3d",
      "author" : [ "N. Snavely", "S.M. Seitz", "R. Szeliski" ],
      "venue" : "ACM Trans. Graph., 25(3):835–846, July",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Exact and stable recovery of rotations for robust synchronization",
      "author" : [ "L. Wang", "A. Singer" ],
      "venue" : "CoRR, abs/1211.2441,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Disambiguating visual relations using loop constraints",
      "author" : [ "C. Zach", "M. Klopschitz", "M. Pollefeys" ],
      "venue" : "CVPR, pages 1426–1433,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Multi-image matching via fast alternating minimization",
      "author" : [ "X. Zhou", "M. Zhu", "K. Daniilidis" ],
      "venue" : "2015 IEEE International Conference on Computer Vision, ICCV 2015, Santiago, Chile, December 7-13, 2015, pages 4032–4040,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "Translation synchronization is a fundamental problem that arises in many application domains, including joint alignment of point clouds [7] and ranking from relative comparisons [8, 16].",
      "startOffset" : 136,
      "endOffset" : 139
    }, {
      "referenceID" : 7,
      "context" : "Translation synchronization is a fundamental problem that arises in many application domains, including joint alignment of point clouds [7] and ranking from relative comparisons [8, 16].",
      "startOffset" : 178,
      "endOffset" : 185
    }, {
      "referenceID" : 14,
      "context" : "Translation synchronization is a fundamental problem that arises in many application domains, including joint alignment of point clouds [7] and ranking from relative comparisons [8, 16].",
      "startOffset" : 178,
      "endOffset" : 185
    }, {
      "referenceID" : 13,
      "context" : "Map synchronization appears as a crucial step in many scientific problems, including fusing partially overlapping range scans [15], assembling fractured surfaces [14], solving jigsaw puzzles [5, 11], multi-view structure from motion [25], data-driven shape analysis and processing [17], and structure from motion [27].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 12,
      "context" : "Map synchronization appears as a crucial step in many scientific problems, including fusing partially overlapping range scans [15], assembling fractured surfaces [14], solving jigsaw puzzles [5, 11], multi-view structure from motion [25], data-driven shape analysis and processing [17], and structure from motion [27].",
      "startOffset" : 162,
      "endOffset" : 166
    }, {
      "referenceID" : 4,
      "context" : "Map synchronization appears as a crucial step in many scientific problems, including fusing partially overlapping range scans [15], assembling fractured surfaces [14], solving jigsaw puzzles [5, 11], multi-view structure from motion [25], data-driven shape analysis and processing [17], and structure from motion [27].",
      "startOffset" : 191,
      "endOffset" : 198
    }, {
      "referenceID" : 9,
      "context" : "Map synchronization appears as a crucial step in many scientific problems, including fusing partially overlapping range scans [15], assembling fractured surfaces [14], solving jigsaw puzzles [5, 11], multi-view structure from motion [25], data-driven shape analysis and processing [17], and structure from motion [27].",
      "startOffset" : 191,
      "endOffset" : 198
    }, {
      "referenceID" : 23,
      "context" : "Map synchronization appears as a crucial step in many scientific problems, including fusing partially overlapping range scans [15], assembling fractured surfaces [14], solving jigsaw puzzles [5, 11], multi-view structure from motion [25], data-driven shape analysis and processing [17], and structure from motion [27].",
      "startOffset" : 233,
      "endOffset" : 237
    }, {
      "referenceID" : 15,
      "context" : "Map synchronization appears as a crucial step in many scientific problems, including fusing partially overlapping range scans [15], assembling fractured surfaces [14], solving jigsaw puzzles [5, 11], multi-view structure from motion [25], data-driven shape analysis and processing [17], and structure from motion [27].",
      "startOffset" : 281,
      "endOffset" : 285
    }, {
      "referenceID" : 25,
      "context" : "Map synchronization appears as a crucial step in many scientific problems, including fusing partially overlapping range scans [15], assembling fractured surfaces [14], solving jigsaw puzzles [5, 11], multi-view structure from motion [25], data-driven shape analysis and processing [17], and structure from motion [27].",
      "startOffset" : 313,
      "endOffset" : 317
    }, {
      "referenceID" : 12,
      "context" : "Early methods for map synchronization focused on applying greedy algorithms [14, 15, 18] or combinatorial optimization [20, 23, 27].",
      "startOffset" : 76,
      "endOffset" : 88
    }, {
      "referenceID" : 13,
      "context" : "Early methods for map synchronization focused on applying greedy algorithms [14, 15, 18] or combinatorial optimization [20, 23, 27].",
      "startOffset" : 76,
      "endOffset" : 88
    }, {
      "referenceID" : 16,
      "context" : "Early methods for map synchronization focused on applying greedy algorithms [14, 15, 18] or combinatorial optimization [20, 23, 27].",
      "startOffset" : 76,
      "endOffset" : 88
    }, {
      "referenceID" : 18,
      "context" : "Early methods for map synchronization focused on applying greedy algorithms [14, 15, 18] or combinatorial optimization [20, 23, 27].",
      "startOffset" : 119,
      "endOffset" : 131
    }, {
      "referenceID" : 21,
      "context" : "Early methods for map synchronization focused on applying greedy algorithms [14, 15, 18] or combinatorial optimization [20, 23, 27].",
      "startOffset" : 119,
      "endOffset" : 131
    }, {
      "referenceID" : 25,
      "context" : "Early methods for map synchronization focused on applying greedy algorithms [14, 15, 18] or combinatorial optimization [20, 23, 27].",
      "startOffset" : 119,
      "endOffset" : 131
    }, {
      "referenceID" : 11,
      "context" : "In [13], Huang and Guibas introduce a semidefinite programming formulation for permutation synchronization and its variants.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 3,
      "context" : "[4] generalize the method to partial maps.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 24,
      "context" : "In [26], Wang and Singer introduce a method for rotation synchronization.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 22,
      "context" : "[24] provide an analysis of spectral techniques for permutation synchronization.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 26,
      "context" : "[28] apply alternating minimization for permutation synchronization.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 2,
      "context" : "Finally, Chen and Candes [3] introduce a method for the generalized permutation synchronization problem using the projected power method.",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 10,
      "context" : "Our approach can be considered as a special case of reweighted least squares (or RLS) [9, 12], which is a powerful method for solving convex and non-convex optimizations.",
      "startOffset" : 86,
      "endOffset" : 93
    }, {
      "referenceID" : 8,
      "context" : "In the first application, we consider the problem of joint alignment of point clouds from pair-wise alignment [10].",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 17,
      "context" : "We applied Super4PCS [19] to match each scan to 300 randomly selected scans, where each match returns a pair-wise rigid transformation and a score.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 1,
      "context" : "To create the input data for translation synchronization, we run the state-of-the-art rotation synchronization algorithm described in [2] to estimate a global pose Ri for each scan.",
      "startOffset" : 134,
      "endOffset" : 137
    }, {
      "referenceID" : 14,
      "context" : "Table 2: Global ranking of selected six movies via different methods: MRQE, HodgeRank[16] with 1) arithmetic mean score difference, 2) geometric mean score ratio and 3) and binary comparisons, and the initial and final predictions of TranSync.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 14,
      "context" : "We adapt the procedure described in [16] to generate the input data.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 14,
      "context" : "Table 2 compares TranSync with HodgeRank [16] on six representative movies that are studied in [16].",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 14,
      "context" : "Table 2 compares TranSync with HodgeRank [16] on six representative movies that are studied in [16].",
      "startOffset" : 95,
      "endOffset" : 99
    }, {
      "referenceID" : 14,
      "context" : "The experimental results show that both predictions appear to be more consistent with MRQE2 (the largest online directory of movie reviews on the internet) than HodgeRank [16] and its variants, which were only applied on these six movies in isolation.",
      "startOffset" : 171,
      "endOffset" : 175
    } ],
    "year" : 2018,
    "abstractText" : "In this paper, we introduce a robust algorithm, TranSync, for the 1D translation synchronization problem, in which the aim is to recover the global coordinates of a set of nodes from noisy measurements of relative coordinates along an observation graph. The basic idea of TranSync is to apply truncated least squares, where the solution at each step is used to gradually prune out noisy measurements. We analyze TranSync under both deterministic and randomized noisy models, demonstrating its robustness and stability. Experimental results on synthetic and real datasets show that TranSync is superior to state-of-the-art convex formulations in terms of both efficiency and accuracy.",
    "creator" : "pdftk 2.01 - www.pdftk.com"
  }
}