{
  "name" : "a6d259bfbfa2062843ef543e21d7ec8e.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Monte-Carlo Tree Search by Best Arm Identification",
    "authors" : [ "Emilie Kaufmann", "Wouter M. Koolen" ],
    "emails" : [ "emilie.kaufmann@univ-lille1.fr", "wmkoolen@cwi.nl" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "We consider two-player zero-sum turn-based interactions, in which the sequence of possible successive moves is represented by a maximin game tree T . This tree models the possible actions sequences by a collection of MAX nodes, that correspond to states in the game in which player A should take action, MIN nodes, for states in the game in which player B should take action, and leaves which specify the payoff for player A. The goal is to determine the best action at the root for player A. For deterministic payoffs this search problem is primarily algorithmic, with several powerful pruning strategies available [20]. We look at problems with stochastic payoffs, which in addition present a major statistical challenge.\nSequential identification questions in game trees with stochastic payoffs arise naturally as robust versions of bandit problems. They are also a core component of Monte Carlo tree search (MCTS) approaches for solving intractably large deterministic tree search problems, where an entire sub-tree is represented by a stochastic leaf in which randomized play-out and/or evaluations are performed [4]. A play-out consists in finishing the game with some simple, typically random, policy and observing the outcome for player A.\nFor example, MCTS is used within the AlphaGo system [21], and the evaluation of a leaf position combines supervised learning and (smart) play-outs. While MCTS algorithms for Go have now reached expert human level, such algorithms remain very costly, in that many (expensive) leaf evaluations or play-outs are necessary to output the next action to be taken by the player. In this paper, we focus on the sample complexity of Monte-Carlo Tree Search methods, about which very little is known. For this purpose, we work under a simplified model for MCTS already studied by [22], and that generalizes the depth-two framework of [10].\n31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, USA."
    }, {
      "heading" : "1.1 A simple model for Monte-Carlo Tree Search",
      "text" : "We start by fixing a game tree T , in which the root is a MAX node. Letting L be the set of leaves of this tree, for each ` ∈ L we introduce a stochastic oracle O` that represents the leaf evaluation or play-out performed when this leaf is reached by an MCTS algorithm. In this model, we do not try to optimize the evaluation or play-out strategy, but we rather assume that the oracle O` produces i.i.d. samples from an unknown distribution whose mean µ` is the value of the position `. To ease the presentation, we focus on binary oracles (indicating the win or loss of a play-out), in which the oracle O` is a Bernoulli distribution with unknown mean µ` (the probability of player A winning the game in the corresponding state). Our algorithms can be used without modification in case the oracle is a distribution bounded in [0,1].\nFor each node s in the tree, we denote by C(s) the set of its children and by P(s) its parent. The root is denoted by s0. The value (for player A) of any node s is recursively defined by V` = µ` if ` ∈ L and\nVs = { maxc∈C(s) Vc if s is a MAX node, minc∈C(s) Vc if s is a MIN node.\nThe best move is the action at the root with highest value,\ns∗ = argmax s∈C(s0) Vs.\nTo identify s∗ (or an -close move), an MCTS algorithm sequentially selects paths in the game tree and calls the corresponding leaf oracle. At round t, a leaf Lt ∈ L is chosen by this adaptive sampling rule, after which a sampleXt ∼ OLt is collected. We consider here the same PAC learning framework as [22, 10], in which the strategy also requires a stopping rule, after which leaves are no longer evaluated, and a recommendation rule that outputs upon stopping a guess ŝτ ∈ C(s0) for the best move of player A.\nGiven a risk level δ and some accuracy parameter ≥ 0 our goal is have a recommendation ŝτ ∈ C(s0) whose value is within of the value of the best move, with probability larger than 1 − δ, that is\nP (V (s0) − V (ŝτ) ≤ ) ≥ 1 − δ. An algorithm satisfying this property is called ( , δ)-correct. The main challenge is to design ( , δ)-correct algorithms that use as few leaf evaluations τ as possible.\nRelated work The model we introduce for Monte-Carlo Tree Search is very reminiscent of a stochastic bandit model. In those, an agent repeatedly selects one out of several probability distributions, called arms, and draws a sample from the chosen distribution. Bandits models have been studied since the 1930s [23], mostly with a focus on regret minimization, where the agent aims to maximize the sum of the samples collected, which are viewed as rewards [18]. In the context of MCTS, a sample corresponds to a win or a loss in one play-out, and maximizing the number of successful play-outs (that correspond to simulated games) may be at odds with identifying quickly the next best action to take at the root. In that, our best action identification problem is closer to a so-called Best Arm Identification (BAI) problem.\nThe goal in the standard BAI problem is to find quickly and accurately the arm with highest mean. The BAI problem in the fixed-confidence setting [7] is the special case of our simple model for a tree of depth one. For deeper trees, rather than finding the best arm (i.e. leaf), we are interested in finding the best action at the root. As the best root action is a function of the means of all leaves, this is a more structured problem.\nBandit algorithms, and more recently BAI algorithms have been successfully adapted to tree search. Building on the UCB algorithm [2], a regret minimizing algorithm, variants of the UCT algorithm [17] have been used for MCTS in growing trees, leading to successful AIs for games. However, there are only very weak theoretical guarantees for UCT. Moreover, observing that maximizing the number of successful play-outs is not the target, recent work rather tried to leverage tools from the BAI literature. In [19, 6] Sequential Halving [14] is used for exploring game trees. The latter algorithm is a state-of-the-art algorithm for the fixed-budget BAI problem [1], in which the goal is to identify the best arm with the smallest probability of error based on a given budget of draws. The proposed SHOT (Sequential Halving applied tO Trees) algorithm [6] is compared empirically to the UCT approach of [17], showing improvements in some cases. A hybrid approach mixing SHOT and UCT is also studied [19], still without sample complexity guarantees.\nIn the fixed-confidence setting, [22] develop the first sample complexity guarantees in the model we consider. The proposed algorithm, FindTopWinner is based on uniform sampling and eliminations, an approach that may be related to the Successive Eliminations algorithm [7] for fixed-confidence BAI in bandit models. FindTopWinner proceeds in rounds, in which the leaves that have not been eliminated are sampled repeatedly until the precision of their estimates doubled. Then the tree is pruned of every node whose estimated value differs significantly from the estimated value of its parent, which leads to the possible elimination of several leaves. For depth-two trees, [10] propose an elimination procedure that is not round-based. In this simpler setting, an algorithm that exploits confidence intervals is also developed, inspired by the LUCB algorithm for fixed-confidence BAI [13]. Some variants of the proposed M-LUCB algorithm appear to perform better in simulations than elimination based algorithms. We now investigate this trend further in deeper trees, both in theory and in practice.\nOur Contribution. In this paper, we propose a generic architecture, called BAI-MCTS, that builds on a Best Arm Identification (BAI) algorithm and on confidence intervals on the node values in order to solve the best action identification problem in a tree of arbitrary depth. In particular, we study two specific instances, UGapE-MCTS and LUCB-MCTS, that rely on confidence-based BAI algorithms [8, 13]. We prove that these are ( , δ)-correct and give a high-probability upper bound on their sample complexity. Both our theoretical and empirical results improve over the elimination-based state-of-the-art algorithm, FindTopWinner [22]."
    }, {
      "heading" : "2 BAI-MCTS algorithms",
      "text" : "We present a generic class of algorithms, called BAI-MCTS, that combines a BAI algorithm with an exploration of the tree based on confidence intervals on the node values. Before introducing the algorithm and two particular instances, we first explain how to build such confidence intervals, and also introduce the central notion of representative child and representative leaf."
    }, {
      "heading" : "2.1 Confidence intervals and representative nodes",
      "text" : "For each leaf ` ∈ L, using the past observations from this leaf we may build a confidence interval I`(t) = [L`(t),U`(t)],\nwhere U`(t) (resp. L`(t)) is an Upper Confidence Bound (resp. a Lower Confidence Bound) on the value V (`) = µ`. The specific confidence interval we shall use will be discussed later.\nThese confidence intervals are then propagated upwards in the tree using the following construction. For each internal node s, we recursively define Is(t) = [Ls(t),Us(t)] with\nLs(t) = { maxc∈C(s) Lc(t) for a MAX node s, minc∈C(s) Lc(t) for a MIN node s, Us(t) = { maxc∈C(s) Uc(t) for a MAX node s, minc∈C(s) Uc(t) for a MIN node s.\nNote that these intervals are the tightest possible on the parent under the sole assumption that the child confidence intervals are all valid. A similar construction was used in the OMS algorithm of [3] in a different context. It is easy to convince oneself (or prove by induction, see Appendix B.1) that the accuracy of the confidence intervals is preserved under this construction, as stated below. Proposition 1. Let t ∈ N. One has ⋂`∈L (µ` ∈ I`(t)) ⇒ ⋂s∈T (Vs ∈ Is(t)).\nWe now define the representative child cs(t) of an internal node s as\ncs(t) = { argmaxc∈C(s) Uc(t) if s is a MAX node, argminc∈C(s) Lc(t) if s is a MIN node,\nand the representative leaf `s(t) of a node s ∈ T , which is the leaf obtained when going down the tree by always selecting the representative child:\n`s(t) = s if s ∈ L, `s(t) = `cs(t)(t) otherwise. The confidence intervals in the tree represent the statistically plausible values in each node, hence the representative child can be interpreted as an “optimistic move” in a MAX node and a “pessimistic move” in a MIN node (assuming we play against the best possible adversary). This is reminiscent of the behavior of the UCT algorithm [17]. The construction of the confidence intervals and associated representative children are illustrated in Figure 1.\n(a) Children (b) Parent\nFigure 1: Construction of confidence interval and representative child (in red) for a MAX node."
    }, {
      "heading" : "2.2 The BAI-MCTS architecture",
      "text" : "In this section we present the generic BAI-MCTS algorithm, whose sampling rule combines two ingredients: a best arm identification step which selects an action at the root, followed by a confidence based exploration step, that goes down the tree starting from this depth-one node in order to select the representative leaf for evaluation.\nThe structure of a BAI-MCTS algorithm is presented in Figure 2. The algorithm depends on a Best Arm Identification (BAI) algorithm, and uses the three components of this algorithm:\n• the sampling rule BAIStep(S) selects an arm in the set S\n• the stopping rule BAIStop(S) returns True if the algorithm decides to stop\n• the recommendation rule BAIReco(S) selects an arm as a candidate for the best arm\nIn BAI-MCTS, the arms are the depth-one nodes, hence the information needed by the BAI algorithm to make a decision (e.g. BAIStep for choosing an arm, or BAIStop for stopping) is information about depth-one nodes, that has to be updated at the end of each round (last line in the while loop). Different BAI algorithms may require different information, and we now present two instances that rely on confidence intervals (and empirical estimates) for the value of the depth-one nodes."
    }, {
      "heading" : "2.3 UGapE-MCTS and LUCB-MCTS",
      "text" : "Several Best Arm Identification algorithms may be used within BAI-MCTS, and we now present two variants, that are respectively based on the UGapE [8] and the LUCB [13] algorithms. These two algorithms are very similar in that they exploit confidence intervals and use the same stopping rule, however the LUCB algorithm additionally uses the empirical means of the arms, which within BAI-MCTS requires defining an estimate V̂s(t) of the value of the depth-one nodes.\nThe generic structure of the two algorithms is similar. At round t + 1 two promising depth-one nodes are computed, that we denote by bt and ct. Among these two candidates, the node whose confidence interval is the largest (that is, the most uncertain node) is selected:\nRt+1 = argmax i∈{bt,ct} [Ui(t) −Li(t)] .\nThen, following the BAI-MCTS architecture, the representative leaf of Rt+1 (computed by going down the tree) is sampled: Lt+1 = `Rt+1(t). The algorithm stops whenever the confidence intervals of the two promising arms overlap by less than :\nτ = inf {t ∈ N ∶ Uct(t) −Lbt(t) < } ,\nand it recommends ŝτ = bτ .\nIn both algorithms that we detail below bt represents a guess for the best depth-one node, while ct is an “optimistic” challenger, that has the maximal possible value among the other depth-one nodes. Both nodes need to be explored enough in order to discover the best depth-one action quickly.\nUGapE-MCTS. In UGapE-MCTS, introducing for each depth-one node the index\nBs(t) = max s′∈C(s0)/{s} Us′(t) −Ls(t),\nthe promising depth-one nodes are defined as\nbt = argmin a∈C(s0) Ba(t) and ct = argmax b∈C(s0)/{bt} Ub(t).\nLUCB-MCTS. In LUCB-MCTS, the promising depth-one nodes are defined as\nbt = argmax a∈C(s0) V̂a(t) and ct = argmax b∈C(s0)/{bt} Ub(t),\nwhere V̂s(t) = µ̂`s(t)(t) is the empirical mean of the reprentative leaf of node s. Note that several alternative definitions of V̂s(t) may be proposed (such as the middle of the confidence interval Is(t), or maxa∈C(s) V̂a(t)), but our choice is crucial for the analysis of LUCB-MCTS, given in Appendix C."
    }, {
      "heading" : "3 Analysis of UGapE-MCTS",
      "text" : "In this section we first prove that UGapE-MCTS and LUCB-MCTS are both ( , δ)-correct. Then we give in Theorem 3 a high-probability upper bound on the number of samples used by UGapE-MCTS. A similar upper bound is obtained for LUCB-MCTS in Theorem 9, stated in Appendix C."
    }, {
      "heading" : "3.1 Choosing the Confidence Intervals",
      "text" : "From now on, we assume that the confidence intervals on the leaves are of the form\nL`(t) = µ̂`(t) −\n¿ Á ÁÀβ(N`(t), δ)\n2N`(t) and U`(t) = µ̂`(t) +\n¿ Á ÁÀβ(N`(t), δ)\n2N`(t) . (1)\nβ(s, δ) is some exploration function, that can be tuned to have a δ-PAC algorithm, as expressed in the following lemma, whose proof can be found in Appendix B.2\nLemma 2. If δ ≤ max(0.1∣L∣,1), for the choice\nβ(s, δ) = ln(∣L∣/δ) + 3 ln ln(∣L∣/δ) + (3/2) ln(ln s + 1) (2)\nboth UGapE-MCTS and LUCB-MCTS satisfy P(V (s∗) − V (ŝτ) ≤ ) ≥ 1 − δ.\nAn interesting practical feature of these confidence intervals is that they only depend on the local number of draws N`(t), whereas most of the BAI algorithms use exploration functions that depend on the number of rounds t. Hence the only confidence intervals that need to be updated at round t are those of the ancestors of the selected leaf, which can be done recursively.\nMoreover, β(s, δ) scales with ln(ln(s)), and not ln(s), leveraging some tools recently introduced to obtain tighter confidence intervals [12, 15]. The union bound over L (that may be an artifact of our current analysis) however makes the exploration function of Lemma 2 still a bit over-conservative and in practice, we recommend the use of β(s, δ) = ln (ln(es)/δ).\nFinally, similar correctness results (with slightly larger exploration functions) may be obtained for confidence intervals based on the Kullback-Leibler divergence (see [5]), which are known to lead to better performance in standard best arm identification problems [16] and also depth-two tree search problems [10]. However, the sample complexity analysis is much more intricate, hence we stick to the above Hoeffding-based confidence intervals for the next section."
    }, {
      "heading" : "3.2 Complexity term and sample complexity guarantees",
      "text" : "We first introduce some notation. Recall that s∗ is the optimal action at the root, identified with the depth-one node satisfying V (s∗) = V (s0), and define the second-best depth-one node as s∗2 =\nargmaxs∈C(s0)/{s∗} Vs. RecallP(s) denotes the parent of a node s different from the root. Introducing furthermore the set Anc(s) of all the ancestors of a node s, we define the complexity term by\nH∗ (µ) ∶= ∑ `∈L\n1\n∆2` ∨∆ 2 ∗ ∨\n2 , where ∆∗ ∶= V (s ∗) − V (s∗2) ∆` ∶= maxs∈Anc(`)/{s0} ∣Vs − V (P(s))∣\n(3)\nThe intuition behind these squared terms in the denominator is the following. We will sample a leaf ` until we either prune it (by determining that it or one of its ancestors is a bad move), prune everyone else (this happens for leaves below the optimal arm) or reach the required precision . Theorem 3. Let δ ≤ min(1,0.1∣L∣). UGapE-MCTS using the exploration function (2) is such that, with probability larger than 1 − δ, (V (s∗) − V (ŝτ) < ) and, letting ∆`, = ∆` ∨∆∗ ∨ ,\nτ ≤ 8H∗ (µ) ln ∣L∣\nδ +∑\n`\n16\n∆ 2\n`,\nln ln 1\n∆ 2\n`,\n+ 8H∗ (µ) [3 ln ln ∣L∣\nδ + 2 ln ln(8e ln\n∣L∣\nδ + 24e ln ln\n∣L∣\nδ )] + 1.\nRemark 4. If β(Na(t), δ) is changed to β(t, δ), one can still prove ( , δ) correctness and furthermore upper bound the expectation of τ . However the algorithm becomes less efficient to implement, since after each leaf observation, ALL the confidence intervals have to be updated. In practice, this change lowers the probability of error but does not effect significantly the number of play-outs used."
    }, {
      "heading" : "3.3 Comparison with previous work",
      "text" : "To the best of our knowledge1, the FindTopWinner algorithm [22] is the only algorithm from the literature designed to solve the best action identification problem in any-depth trees. The number of play-outs of this algorithm is upper bounded with high probability by\n∑ `∶∆`>2\n( 32\n∆2` ln\n16∣L∣\n∆`δ + 1) + ∑\n`∶∆`≤2\n( 8\n2 ln\n8∣L∣\nδ + 1)\nOne can first note the improvement in the constant in front of the leading term in ln(1/δ), as well as the presence of the ln ln(1/∆`, 2) second order, that is unavoidable in a regime in which the gaps are small [12]. The most interesting improvement is in the control of the number of draws of 2 -optimal leaves (such that ∆` ≤ 2 ). In UGapE-MCTS, the number of draws of such leaves is at most of order ( ∨∆2∗)\n−1 ln(1/δ), which may be significantly smaller than −1 ln(1/δ) if there is a gap in the best and second best value. Moreover, unlike FindTopWinner and M-LUCB [10] in the depth two case, UGapE-MCTS can also be used when = 0, with provable guarantees.\nRegarding the algorithms themselves, one can note that M-LUCB, an extension of LUCB suited for depth-two tree, does not belong to the class of BAI-MCTS algorithms. Indeed, it has a “reversed” structure, first computing the representative leaf for each depth-one node: ∀s ∈ C(s0),Rs,t = `s(t) and then performing a BAI step over the representative leaves: L̃t+1 = BAIStep(Rs,t, s ∈ C(s0)). This alternative architecture can also be generalized to deeper trees, and was found to have empirical performance similar to BAI-MCTS. M-LUCB, which will be used as a benchmark in Section 4, also distinguish itself from LUCB-MCTS by the fact that it uses an exploration rate that depends on the global time β(t, δ) and that bt is the empirical maximin arm (which can be different from the arm maximizing V̂s). This alternative choice is not yet supported by theoretical guarantees in deeper trees.\nFinally, the exploration step of BAI-MCTS algorithm bears some similarity with the UCT algorithm [17], as it goes down the tree choosing alternatively the move that yields the highest UCB or the lowest LCB. However, the behavior of BAI-MCTS is very different at the root, where the first move is selected using a BAI algorithm. Another key difference is that BAI-MCTS relies on exact confidence\n1In a recent paper, [11] independently proposed the LUCBMinMax algorithm, that differs from UGapEMCTS and LUCB-MCTS only by the way the best guess bt is picked. The analysis is very similar to ours, but features some refined complexity measure, in which ∆` (that is the maximal distance between consecutive ancestors of the leaf, see (3)) is replaced by the maximal distance between any ancestors of that leaf. Similar results could be obtained for our two algorithms following the same lines.\nintervals: each interval Is(t) is shown to contain with high probability the corresponding value Vs, whereas UCT uses more heuristic confidence intervals, based on the number of visits of the parent node, and aggregating all the samples from descendant nodes. Using UCT in our setting is not obvious as it would require to define a suitable stopping rule, hence we don’t include a comparison with this algorithm in Section 4. A hybrid comparison between UCT and FindTopWinner is proposed in [22], providing UCT with the random number of samples used by the the fixed-confidence algorithm. It is shown that FindTopWinner has the advantage for hard trees that require many samples. Our experiments show that our algorithms in turn always dominate FindTopWinner."
    }, {
      "heading" : "3.4 Proof of Theorem 3.",
      "text" : "Letting Et = ⋂`∈L (µ` ∈ I`(t)) and E = ⋂t∈N Et, we upper bound τ assuming the event E holds, using the following key result, which is proved in Appendix D.\nLemma 5. Let t ∈ N. Et ∩ (τ > t) ∩ (Lt+1 = `) ⇒ N`(t) ≤ 8β(N`(t),δ)∆2 ` ∨∆2∗∨ 2 .\nAn intuition behind this result is the following. First, using that the selected leaf ` is a representative leaf, it can be seen that the confidence intervals from sD = ` to s0 are nested (Lemma 11). Hence if Et holds, V (sk) ∈ I`(t) for all k = 1, . . . ,D, which permits to lower bound the width of this interval (and thus upper bound N`(t)) as a function of the V (sk) (Lemma 12). Then Lemma 13 exploits the mechanism of UGapE to further relate this width to ∆∗ and .\nAnother useful tool is the following lemma, that will allow to leverage the particular form of the exploration function β to obtain an explicit upper bound on N`(τ).\nLemma 6. Let β(s) = C + 3 2 ln(1 + ln(s)) and define S = sup{s ≥ 1 ∶ aβ(s) ≥ s}. Then\nS ≤ aC + 2a ln(1 + ln(aC)).\nThis result is a consequence of Theorem 16 stated in Appendix F, that uses the fact that for C ≥ − ln(0.1) and a ≥ 8, it holds that\n3\n2\nC(1 + ln(aC))\nC (1 + ln(aC)) − 3 2\n≤ 1.7995564 ≤ 2.\nOn the event E , letting τ` be the last instant before τ at which the leaf ` has been played before stopping, one has N`(τ − 1) = N`(τ`) that satisfies by Lemma 5\nN`(τ`) ≤ 8β(N`(τ`), δ)\n∆2` ∨∆ 2 ∗ ∨\n2 .\nApplying Lemma 6 with a = a` = 8∆2 ` ∨∆2∗∨ 2 and C = ln ∣L∣ δ + 3 ln ln ∣L∣ δ leads to\nN`(τ − 1) ≤ a` (C + 2 ln(1 + ln(a`C))) .\nLetting ∆`, = ∆` ∨∆∗ ∨ and summing over arms, we find\nτ = 1 +∑ ` N`(τ − 1)\n≤ 1 +∑ `\n8\n∆ 2\n`,\n⎛ ⎜ ⎝ ln ∣L∣ δ + 3 ln ln ∣L∣ δ + 2 ln ln ⎛ ⎜ ⎝ 8e ln ∣L∣ δ + 3 ln ln ∣L∣ δ ∆ 2\n`,\n⎞ ⎟ ⎠ ⎞ ⎟ ⎠\n= 1 +∑ `\n8\n∆ 2\n`,\n⎛ ⎜ ⎝ ln ∣L∣ δ + 2 ln ln 1 ∆ 2\n`,\n⎞ ⎟ ⎠ + 8H∗ (µ) [3 ln ln ∣L∣ δ + 2 ln ln(8e ln ∣L∣ δ + 24e ln ln ∣L∣ δ )] .\nTo conclude the proof, we remark that from the proof of Lemma 2 (see Appendix B.2) it follows that on E , V (s∗) − V (ŝτ) < and that E holds with probability larger than 1 − δ."
    }, {
      "heading" : "4 Experimental Validation",
      "text" : "In this section we evaluate the performance of our algorithms in three experiments. We evaluate on the depth-two benchmark tree from [10], a new depth-three tree and the random tree ensemble from [22]. We compare to the FindTopWinner algorithm from [22] in all experiments, and in the depth-two experiment we include the M-LUCB algorithm from [10]. Its relation to BAI-MCTS is discussed in Section 3.3. For our BAI-MCTS algorithms and for M-LUCB we use the exploration rate β(s, δ) = ln ∣L∣\nδ + ln(ln(s) + 1) (a stylized version of Lemma 2 that works well in practice), and\nwe use the KL refinement of the confidence intervals (1). To replicate the experiment from [22], we supply all algorithms with δ = 0.1 and = 0.01. For comparing with [10] we run all algorithms with = 0 and δ = 0.1∣L∣ (undoing the conservative union bound over leaves. This excessive choice, which might even exceed one, does not cause a problem, as the algorithms depend on δ\n∣L∣ = 0.1). In none of\nour experiments the observed error rate exceeds 0.1.\nFigure 3 shows the benchmark tree from [10, Section 5] and the performance of four algorithms on it. We see that the special-purpose depth-two M-LUCB performs best, very closely followed by both our new arbitrary-depth LUCB-MCTS and UGapE-MCTS methods. All three use significantly fewer samples than FindTopWinner. Figure 4 (displayed in Appendix A for the sake of readability) shows a full 3-way tree of depth 3 with leafs drawn uniformly from [0,1]. Again our algorithms outperform the previous state of the art by an order of magnitude. Finally, we replicate the experiment from [22, Section 4]. To make the comparison as fair as possible, we use the proven exploration rate from (2). On 10K full 10-ary trees of depth 3 with Bernoulli leaf parameters drawn uniformly at random from [0,1] the average numbers of samples are: LUCB-MCTS 141811, UGapE-MCTS 142953 and FindTopWinner 2254560. To closely follow the original experiment, we do apply the union bound over leaves to all algorithms, which are run with = 0.01 and δ = 0.1. We did not observe any error from any algorithm (even though we allow 10%). Our BAI-MCTS algorithms deliver an impressive 15-fold reduction in samples."
    }, {
      "heading" : "5 Lower bounds and discussion",
      "text" : "Given a tree T , a MCTS model is parameterized by the leaf values, µ ∶= (µ`)`∈L, which determine the best root action: s∗ = s∗(µ). For µ ∈ [0,1]∣L∣, We define Alt(µ) = {λ ∈ [0,1]∣L∣ ∶ s∗(λ) ≠ s∗(µ)}. Using the same technique as [9] for the classic best arm identification problem, one can establish the following (non explicit) lower bound. The proof is given in Appendix E.\nTheorem 7. Assume = 0. Any δ-correct algorithm satisfies\nEµ[τ] ≥ T ∗(µ)d(δ,1 − δ), where T ∗(µ)−1 ∶= sup w∈Σ∣L∣ inf λ∈Alt(µ) ∑ `∈L w`d (µ`, λ`) (4)\nwith Σk = {w ∈ [0,1]i ∶ ∑ k i=1wi = 1} and d(x, y) = x ln(x/y) + (1 − x) ln((1 − x)/(1 − y)) is the binary Kullback-Leibler divergence.\nThis result is however not directly amenable for comparison with our upper bounds, as the optimization problem defined in Lemma 7 is not easy to solve. Note that d(δ,1− δ) ≥ ln(1/(2.4δ)) [15], thus our upper bounds have the right dependency in δ. For depth-two trees with K (resp. M ) actions for player A (resp. B), we can moreover prove the following result, that suggests an intriguing behavior. Lemma 8. Assume = 0 and consider a tree of depth two with µ = (µi,j)1≤i≤K,1≤j≤M such that ∀(i, j), µ1,1 > µi,1, µi,1 < µi,j . The supremum in the definition of T ∗(µ)−1 can be restricted to\nΣ̃K,M ∶= {w ∈ ΣK×M ∶ wi,j = 0 if i ≥ 2 and j ≥ 2} and\nT ∗(µ)−1= max w∈Σ̃K,M min i=2,...,K a=1,...,M\n[w1,ad(µ1,a, w1,aµ1,a +wi,1µi,1\nw1,a +wi,1 )+wi,1d(µi,1,\nw1,aµ1,a +wi,1µi,1\nw1,a +wi,1 )] .\nIt can be extracted from the proof of Theorem 7 (see Appendix E) that the vector w∗(µ) that attains the supremum in (4) represents the average proportions of selections of leaves by any algorithm matching the lower bound. Hence, the sparsity pattern of Lemma 8 suggests that matching algorithms should draw many of the leaves much less than O(ln(1/δ)) times. This hints at the exciting prospect of optimal stochastic pruning, at least in the asymptotic regime δ → 0.\nAs an example, we numerically solve the lower bound optimization problem (which is a concave maximization problem) for µ corresponding to the benchmark tree displayed in Figure 3 to obtain\nT ∗(µ) = 259.9 and w∗ = (0.3633,0.1057,0.0532), (0.3738,0,0), (0.1040,0,0).\nWith δ = 0.1 we find kl(δ,1− δ) = 1.76 and the lower bound is Eµ[τ] ≥ 456.9. We see that there is a potential improvement of at least a factor 4.\nFuture directions An (asymptotically) optimal algorithm for BAI called Track-and-Stop was developed by [9]. It maintains the empirical proportions of draws close to w∗(µ̂), adding forced exploration to ensure µ̂→ µ. We believe that developing this line of ideas for MCTS would result in a major advance in the quality of tree search algorithms. The main challenge is developing efficient solvers for the general optimization problem (4). For now, even the sparsity pattern revealed by Lemma 8 for depth two does not give rise to efficient solvers. We also do not know how this sparsity pattern evolves for deeper trees, let alone how to compute w∗(µ).\nAcknowledgments. Emilie Kaufmann acknowledges the support of the French Agence Nationale de la Recherche (ANR), under grant ANR-16-CE40-0002 (project BADASS). Wouter Koolen acknowledges support from the Netherlands Organization for Scientific Research (NWO) under Veni grant 639.021.439."
    } ],
    "references" : [ {
      "title" : "Best Arm Identification in Multi-armed Bandits",
      "author" : [ "J-Y. Audibert", "S. Bubeck", "R. Munos" ],
      "venue" : "In Proceedings of the 23rd Conference on Learning Theory,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2010
    }, {
      "title" : "Finite-time analysis of the multiarmed bandit problem",
      "author" : [ "P. Auer", "N. Cesa-Bianchi", "P. Fischer" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2002
    }, {
      "title" : "An analysis of optimistic, best-first search for minimax sequential decision making",
      "author" : [ "L. Borsoniu", "R. Munos", "E. Páll" ],
      "venue" : "In ADPRL14,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2014
    }, {
      "title" : "A survey of monte carlo tree search methods",
      "author" : [ "C. Browne", "E. Powley", "D. Whitehouse", "S. Lucas", "P. Cowling", "P. Rohlfshagen", "S. Tavener", "D. Perez", "S. Samothrakis", "S. Colton" ],
      "venue" : "IEEE Transactions on Computational Intelligence and AI in games,,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2012
    }, {
      "title" : "Kullback-Leibler upper confidence bounds for optimal sequential allocation",
      "author" : [ "O. Cappé", "A. Garivier", "O-A. Maillard", "R. Munos", "G. Stoltz" ],
      "venue" : "Annals of Statistics,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2013
    }, {
      "title" : "Sequential halving applied to trees",
      "author" : [ "T. Cazenave" ],
      "venue" : "IEEE Transactions on Computational Intelligence and AI in Games,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2015
    }, {
      "title" : "Action Elimination and Stopping Conditions for the Multi-Armed Bandit and Reinforcement Learning Problems",
      "author" : [ "E. Even-Dar", "S. Mannor", "Y. Mansour" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2006
    }, {
      "title" : "Best Arm Identification: A Unified Approach to Fixed Budget and Fixed Confidence",
      "author" : [ "V. Gabillon", "M. Ghavamzadeh", "A. Lazaric" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2012
    }, {
      "title" : "Optimal best arm identification with fixed confidence",
      "author" : [ "A. Garivier", "E. Kaufmann" ],
      "venue" : "In Proceedings of the 29th Conference On Learning Theory (COLT),",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2016
    }, {
      "title" : "Maximin action identification: A new bandit framework for games",
      "author" : [ "A. Garivier", "E. Kaufmann", "W.M. Koolen" ],
      "venue" : "In Proceedings of the 29th Conference On Learning",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2016
    }, {
      "title" : "Structured best arm identification with fixed confidence",
      "author" : [ "Ruitong Huang", "Mohammad M. Ajallooeian", "Csaba Szepesvári", "Martin Müller" ],
      "venue" : "In 28th International Conference on Algorithmic Learning Theory (ALT),",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2017
    }, {
      "title" : "lil’UCB: an Optimal Exploration Algorithm for Multi-Armed Bandits",
      "author" : [ "K. Jamieson", "M. Malloy", "R. Nowak", "S. Bubeck" ],
      "venue" : "In Proceedings of the 27th Conference on Learning Theory,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2014
    }, {
      "title" : "PAC subset selection in stochastic multi-armed bandits",
      "author" : [ "S. Kalyanakrishnan", "A. Tewari", "P. Auer", "P. Stone" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2012
    }, {
      "title" : "Almost optimal Exploration in multi-armed bandits",
      "author" : [ "Z. Karnin", "T. Koren", "O. Somekh" ],
      "venue" : "In International Conference on Machine Learning (ICML),",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2013
    }, {
      "title" : "On the Complexity of Best Arm Identification in Multi-Armed Bandit Models",
      "author" : [ "E. Kaufmann", "O. Cappé", "A. Garivier" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2016
    }, {
      "title" : "Information complexity in bandit subset selection",
      "author" : [ "E. Kaufmann", "S. Kalyanakrishnan" ],
      "venue" : "In Proceeding of the 26th Conference On Learning Theory.,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2013
    }, {
      "title" : "Bandit based monte-carlo planning",
      "author" : [ "L. Kocsis", "C. Szepesvári" ],
      "venue" : "In Proceedings of the 17th European Conference on Machine Learning,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2006
    }, {
      "title" : "Asymptotically efficient adaptive allocation rules",
      "author" : [ "T.L. Lai", "H. Robbins" ],
      "venue" : "Advances in Applied Mathematics,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1985
    }, {
      "title" : "Minimizing simple and cumulative regret in monte-carlo tree search",
      "author" : [ "T. Pepels", "T. Cazenave", "M. Winands", "M. Lanctot" ],
      "venue" : "In Computer Games Workshop,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2014
    }, {
      "title" : "Best-first fixed-depth minimax algorithms",
      "author" : [ "Aske Plaat", "Jonathan Schaeffer", "Wim Pijls", "Arie de Bruin" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1996
    }, {
      "title" : "Mastering the game of go with deep neural networks and tree",
      "author" : [ "David Silver", "Aja Huang", "Chris J. Maddison", "Arthur Guez", "Laurent Sifre", "George van den Driessche", "Julian Schrittwieser", "Ioannis Antonoglou", "Veda Panneershelvam", "Marc Lanctot", "Sander Dieleman", "Dominik Grewe", "John Nham", "Nal Kalchbrenner", "Ilya Sutskever", "Timothy Lillicrap", "Madeleine Leach", "Koray Kavukcuoglu", "Thore Graepel", "Demis Hassabis" ],
      "venue" : "search. Nature,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2016
    }, {
      "title" : "Efficient sampling method for monte carlo tree search problem",
      "author" : [ "K. Teraoka", "K. Hatano", "E. Takimoto" ],
      "venue" : "IEICE Transactions on Infomation and Systems,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2014
    }, {
      "title" : "On the likelihood that one unknown probability exceeds another in view of the evidence of two samples",
      "author" : [ "W.R. Thompson" ],
      "venue" : null,
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1933
    } ],
    "referenceMentions" : [ {
      "referenceID" : 19,
      "context" : "For deterministic payoffs this search problem is primarily algorithmic, with several powerful pruning strategies available [20].",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 3,
      "context" : "They are also a core component of Monte Carlo tree search (MCTS) approaches for solving intractably large deterministic tree search problems, where an entire sub-tree is represented by a stochastic leaf in which randomized play-out and/or evaluations are performed [4].",
      "startOffset" : 265,
      "endOffset" : 268
    }, {
      "referenceID" : 20,
      "context" : "For example, MCTS is used within the AlphaGo system [21], and the evaluation of a leaf position combines supervised learning and (smart) play-outs.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 21,
      "context" : "For this purpose, we work under a simplified model for MCTS already studied by [22], and that generalizes the depth-two framework of [10].",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 9,
      "context" : "For this purpose, we work under a simplified model for MCTS already studied by [22], and that generalizes the depth-two framework of [10].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 21,
      "context" : "We consider here the same PAC learning framework as [22, 10], in which the strategy also requires a stopping rule, after which leaves are no longer evaluated, and a recommendation rule that outputs upon stopping a guess ŝτ ∈ C(s0) for the best move of player A.",
      "startOffset" : 52,
      "endOffset" : 60
    }, {
      "referenceID" : 9,
      "context" : "We consider here the same PAC learning framework as [22, 10], in which the strategy also requires a stopping rule, after which leaves are no longer evaluated, and a recommendation rule that outputs upon stopping a guess ŝτ ∈ C(s0) for the best move of player A.",
      "startOffset" : 52,
      "endOffset" : 60
    }, {
      "referenceID" : 22,
      "context" : "Bandits models have been studied since the 1930s [23], mostly with a focus on regret minimization, where the agent aims to maximize the sum of the samples collected, which are viewed as rewards [18].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 17,
      "context" : "Bandits models have been studied since the 1930s [23], mostly with a focus on regret minimization, where the agent aims to maximize the sum of the samples collected, which are viewed as rewards [18].",
      "startOffset" : 194,
      "endOffset" : 198
    }, {
      "referenceID" : 6,
      "context" : "The BAI problem in the fixed-confidence setting [7] is the special case of our simple model for a tree of depth one.",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 1,
      "context" : "Building on the UCB algorithm [2], a regret minimizing algorithm, variants of the UCT algorithm [17] have been used for MCTS in growing trees, leading to successful AIs for games.",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 16,
      "context" : "Building on the UCB algorithm [2], a regret minimizing algorithm, variants of the UCT algorithm [17] have been used for MCTS in growing trees, leading to successful AIs for games.",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 18,
      "context" : "In [19, 6] Sequential Halving [14] is used for exploring game trees.",
      "startOffset" : 3,
      "endOffset" : 10
    }, {
      "referenceID" : 5,
      "context" : "In [19, 6] Sequential Halving [14] is used for exploring game trees.",
      "startOffset" : 3,
      "endOffset" : 10
    }, {
      "referenceID" : 13,
      "context" : "In [19, 6] Sequential Halving [14] is used for exploring game trees.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 0,
      "context" : "The latter algorithm is a state-of-the-art algorithm for the fixed-budget BAI problem [1], in which the goal is to identify the best arm with the smallest probability of error based on a given budget of draws.",
      "startOffset" : 86,
      "endOffset" : 89
    }, {
      "referenceID" : 5,
      "context" : "The proposed SHOT (Sequential Halving applied tO Trees) algorithm [6] is compared empirically to the UCT approach of [17], showing improvements in some cases.",
      "startOffset" : 66,
      "endOffset" : 69
    }, {
      "referenceID" : 16,
      "context" : "The proposed SHOT (Sequential Halving applied tO Trees) algorithm [6] is compared empirically to the UCT approach of [17], showing improvements in some cases.",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 18,
      "context" : "A hybrid approach mixing SHOT and UCT is also studied [19], still without sample complexity guarantees.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 21,
      "context" : "In the fixed-confidence setting, [22] develop the first sample complexity guarantees in the model we consider.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 6,
      "context" : "The proposed algorithm, FindTopWinner is based on uniform sampling and eliminations, an approach that may be related to the Successive Eliminations algorithm [7] for fixed-confidence BAI in bandit models.",
      "startOffset" : 158,
      "endOffset" : 161
    }, {
      "referenceID" : 9,
      "context" : "For depth-two trees, [10] propose an elimination procedure that is not round-based.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 12,
      "context" : "In this simpler setting, an algorithm that exploits confidence intervals is also developed, inspired by the LUCB algorithm for fixed-confidence BAI [13].",
      "startOffset" : 148,
      "endOffset" : 152
    }, {
      "referenceID" : 7,
      "context" : "In particular, we study two specific instances, UGapE-MCTS and LUCB-MCTS, that rely on confidence-based BAI algorithms [8, 13].",
      "startOffset" : 119,
      "endOffset" : 126
    }, {
      "referenceID" : 12,
      "context" : "In particular, we study two specific instances, UGapE-MCTS and LUCB-MCTS, that rely on confidence-based BAI algorithms [8, 13].",
      "startOffset" : 119,
      "endOffset" : 126
    }, {
      "referenceID" : 21,
      "context" : "Both our theoretical and empirical results improve over the elimination-based state-of-the-art algorithm, FindTopWinner [22].",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 2,
      "context" : "A similar construction was used in the OMS algorithm of [3] in a different context.",
      "startOffset" : 56,
      "endOffset" : 59
    }, {
      "referenceID" : 16,
      "context" : "This is reminiscent of the behavior of the UCT algorithm [17].",
      "startOffset" : 57,
      "endOffset" : 61
    }, {
      "referenceID" : 7,
      "context" : "Several Best Arm Identification algorithms may be used within BAI-MCTS, and we now present two variants, that are respectively based on the UGapE [8] and the LUCB [13] algorithms.",
      "startOffset" : 146,
      "endOffset" : 149
    }, {
      "referenceID" : 12,
      "context" : "Several Best Arm Identification algorithms may be used within BAI-MCTS, and we now present two variants, that are respectively based on the UGapE [8] and the LUCB [13] algorithms.",
      "startOffset" : 163,
      "endOffset" : 167
    }, {
      "referenceID" : 11,
      "context" : "Moreover, β(s, δ) scales with ln(ln(s)), and not ln(s), leveraging some tools recently introduced to obtain tighter confidence intervals [12, 15].",
      "startOffset" : 137,
      "endOffset" : 145
    }, {
      "referenceID" : 14,
      "context" : "Moreover, β(s, δ) scales with ln(ln(s)), and not ln(s), leveraging some tools recently introduced to obtain tighter confidence intervals [12, 15].",
      "startOffset" : 137,
      "endOffset" : 145
    }, {
      "referenceID" : 4,
      "context" : "Finally, similar correctness results (with slightly larger exploration functions) may be obtained for confidence intervals based on the Kullback-Leibler divergence (see [5]), which are known to lead to better performance in standard best arm identification problems [16] and also depth-two tree search problems [10].",
      "startOffset" : 169,
      "endOffset" : 172
    }, {
      "referenceID" : 15,
      "context" : "Finally, similar correctness results (with slightly larger exploration functions) may be obtained for confidence intervals based on the Kullback-Leibler divergence (see [5]), which are known to lead to better performance in standard best arm identification problems [16] and also depth-two tree search problems [10].",
      "startOffset" : 266,
      "endOffset" : 270
    }, {
      "referenceID" : 9,
      "context" : "Finally, similar correctness results (with slightly larger exploration functions) may be obtained for confidence intervals based on the Kullback-Leibler divergence (see [5]), which are known to lead to better performance in standard best arm identification problems [16] and also depth-two tree search problems [10].",
      "startOffset" : 311,
      "endOffset" : 315
    }, {
      "referenceID" : 21,
      "context" : "3 Comparison with previous work To the best of our knowledge1, the FindTopWinner algorithm [22] is the only algorithm from the literature designed to solve the best action identification problem in any-depth trees.",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 11,
      "context" : "One can first note the improvement in the constant in front of the leading term in ln(1/δ), as well as the presence of the ln ln(1/∆`, 2) second order, that is unavoidable in a regime in which the gaps are small [12].",
      "startOffset" : 212,
      "endOffset" : 216
    }, {
      "referenceID" : 9,
      "context" : "Moreover, unlike FindTopWinner and M-LUCB [10] in the depth two case, UGapE-MCTS can also be used when = 0, with provable guarantees.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 16,
      "context" : "Finally, the exploration step of BAI-MCTS algorithm bears some similarity with the UCT algorithm [17], as it goes down the tree choosing alternatively the move that yields the highest UCB or the lowest LCB.",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 10,
      "context" : "Another key difference is that BAI-MCTS relies on exact confidence (1)In a recent paper, [11] independently proposed the LUCBMinMax algorithm, that differs from UGapEMCTS and LUCB-MCTS only by the way the best guess bt is picked.",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 21,
      "context" : "A hybrid comparison between UCT and FindTopWinner is proposed in [22], providing UCT with the random number of samples used by the the fixed-confidence algorithm.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 9,
      "context" : "We evaluate on the depth-two benchmark tree from [10], a new depth-three tree and the random tree ensemble from [22].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 21,
      "context" : "We evaluate on the depth-two benchmark tree from [10], a new depth-three tree and the random tree ensemble from [22].",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 21,
      "context" : "We compare to the FindTopWinner algorithm from [22] in all experiments, and in the depth-two experiment we include the M-LUCB algorithm from [10].",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 9,
      "context" : "We compare to the FindTopWinner algorithm from [22] in all experiments, and in the depth-two experiment we include the M-LUCB algorithm from [10].",
      "startOffset" : 141,
      "endOffset" : 145
    }, {
      "referenceID" : 21,
      "context" : "To replicate the experiment from [22], we supply all algorithms with δ = 0.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 9,
      "context" : "For comparing with [10] we run all algorithms with = 0 and δ = 0.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 9,
      "context" : "Figure 3: The 3 × 3 tree of depth 2 that is the benchmark in [10].",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 8,
      "context" : "Using the same technique as [9] for the classic best arm identification problem, one can establish the following (non explicit) lower bound.",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 14,
      "context" : "4δ)) [15], thus our upper bounds have the right dependency in δ.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 8,
      "context" : "Future directions An (asymptotically) optimal algorithm for BAI called Track-and-Stop was developed by [9].",
      "startOffset" : 103,
      "endOffset" : 106
    } ],
    "year" : 2017,
    "abstractText" : "Recent advances in bandit tools and techniques for sequential learning are steadily enabling new applications and are promising the resolution of a range of challenging related problems. We study the game tree search problem, where the goal is to quickly identify the optimal move in a given game tree by sequentially sampling its stochastic payoffs. We develop new algorithms for trees of arbitrary depth, that operate by summarizing all deeper levels of the tree into confidence intervals at depth one, and applying a best arm identification procedure at the root. We prove new sample complexity guarantees with a refined dependence on the problem instance. We show experimentally that our algorithms outperform existing elimination-based algorithms and match previous special-purpose methods for depth-two trees.",
    "creator" : "pdftk 2.02 - www.pdftk.com"
  }
}