{
  "name" : "5227b6aaf294f5f027273aebf16015f2.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Deep Hyperspherical Learning",
    "authors" : [ "Weiyang Liu", "Yan-Ming Zhang", "Xingguo Li", "Zhiding Yu", "Bo Dai", "Tuo Zhao", "Le Song" ],
    "emails" : [ "wyliu@gatech.edu,", "tourzhao@gatech.edu,", "ymzhang@nlpr.ia.ac.cn,", "lsong@cc.gatech.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Recently, deep convolutional neural networks have led to significant breakthroughs on many vision problems such as image classification [9, 18, 19, 6], segmentation [3, 13, 1], object detection [3, 16], etc. While showing stronger representation power over many conventional hand-crafted features, CNNs often require a large amount of training data and face certain training difficulties such as overfitting, vanishing/exploding gradient, covariate shift, etc. The increasing depth of recently proposed CNN architectures have further aggravated the problems.\nTo address the challenges, regularization techniques such as dropout [9] and orthogonality parameter constraints [21] have been proposed. Batch normalization [8] can also be viewed as an implicit regularization to the network, by normalizing each layer’s output distribution. Recently, deep residual learning [6] emerged as a promising way to overcome vanishing gradients in deep networks. However, [20] pointed out that residual networks (ResNets) are essentially an exponential ensembles of shallow networks where they avoid the vanishing/exploding gradient problem but do not provide direct solutions. As a result, training an ultra-deep network still remains an open problem. Besides vanishing/exploding gradient, network optimization is also very sensitive to initialization. Finding better initializations is thus widely studied [5, 14, 4]. In general, having a large parameter space is double-edged considering the benefit of representation power and the associated training difficulties. Therefore, proposing better learning frameworks to overcome such challenges remains important.\nIn this paper, we introduce a novel convolutional learning framework that can effectively alleviate training difficulties, while giving better performance over dot product based convolution. Our idea\n31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, USA.\nis to project parameter learning onto unit hyperspheres, where layer activations only depend on the geodesic distance between kernels and input signals1 instead of their inner products. To this end, we propose the SphereConv operator as the basic module for our network layers. We also propose softmax losses accordingly under such representation framework. Specifically, the proposed softmax losses supervise network learning by also taking the SphereConv activations from the last layer instead of inner products. Note that the geodesic distances on a unit hypersphere is the angles between inputs and kernels. Therefore, the learning objective is essentially a function of the input angles and we call it generalized angular softmax loss in this paper. The resulting architecture is the hyperspherical convolutional network (SphereNet), which is shown in Fig. 1.\nOur key motivation to propose SphereNet is that angular information matters in convolutional representation learning. We argue this motivation from several aspects: training stability, training efficiency, and generalization power. SphereNet can also be viewed as an implicit regularization to the network by normalizing the activation distributions. The weight norm is no longer important since the entire network operates only on angles. And as a result, the `2 weight decay is also no longer needed in SphereNet. SphereConv to some extent also alleviates the covariate shift problem [8]. The output of SphereConv operators are bounded from−1 to 1 (0 to 1 if considering ReLU), which makes the variance of each output also bounded.\nOur second intuition is that angles preserve the most abundant discriminative information in convolutional learning. We gain such intuition from 2D Fourier transform, where an image is decomposed by the combination of a set of templates with magnitude and phase information in 2D frequency domain. If one reconstructs an image with original magnitudes and random phases, the resulting images are generally not recognizable. However, if one reconstructs the image with random magnitudes and original phases. The resulting images are still recognizable. It shows that the most important structural information in an image for visual recognition is encoded by phases. This fact inspires us to project the network learning into angular space. In terms of low-level information, SphereConv is able to preserve the shape, edge, texture and relative color. SphereConv can learn to selectively drop the color depth but preserve the RGB ratio. Thus the semantic information of an image is preserved.\nSphereNet can also be viewed as a non-trivial generalization of [12, 11]. By proposing a loss that discriminatively supervises the network on a hypersphere, [11] achieves state-of-the-art performance on face recognition. However, the rest of the network remains a conventional convolution network. In contrast, SphereNet not only generalizes the hyperspherical constraint to every layer, but also to different nonlinearity functions of input angles. Specifically, we propose three instances of SphereConv operators: linear, cosine and sigmoid. The sigmoid SphereConv is the most flexible one with a parameter controlling the shape of the angular function. As a simple extension to the sigmoid SphereConv, we also present a learnable SphereConv operator. Moreover, the proposed generalized angular softmax (GA-Softmax) loss naturaly generalizes the angular supervision in [11] using the SphereConv operators. Additionally, the SphereConv can serve as a normalization method that is comparable to batch normalization, leading to an extension to spherical normalization (SphereNorm).\nSphereNet can be easily applied to other network architectures such as GoogLeNet [19], VGG [18] and ResNet [6]. One simply needs to replace the convolutional operators and the loss functions with the proposed SphereConv operators and hyperspherical loss functions. In summary, SphereConv can be viewed as an alternative to the original convolution operators, and serves as a new measure of correlation. SphereNet may open up an interesting direction to explore the neural networks. We ask the question whether inner product based convolution operator is an optimal correlation measure for all tasks? Our answer to this question is likely to be “no”.\n1Without loss of generality, we study CNNs here, but our method is generalizable to any other neural nets."
    }, {
      "heading" : "2 Hyperspherical Convolutional Operator",
      "text" : ""
    }, {
      "heading" : "2.1 Definition",
      "text" : "The convolutional operator in CNNs is simply a linear matrix multiplication, written as F(w,x) = w>x + bF where w is a convolutional filter, x denotes a local patch from the bottom feature map and bF is the bias. The matrix multiplication here essentially computes the similarity between the local patch and the filter. Thus the standard convolution layer can be viewed as patch-wise matrix multiplication. Different from the standard convolutional operator, the hyperspherical convolutional (SphereConv) operator computes the similarity on a hypersphere and is defined as:\nFs(w,x) = g(θ(w,x)) + bFs , (1) where θ(w,x) is the angle between the kernel parameter w and the local patch x. g(θ(w,x)) indicates a function of θ(w,x) (usually a monotonically decreasing function), and bFs is the bias. To simplify analysis and discussion, the bias terms are usually left out. The angle θ(w,x) can be interpreted as the geodesic distance (arc length) between w and x on a unit hypersphere. In contrast to the convolutional operator that works in the entire space, SphereConv only focuses on the angles between local patches and the filters, and therefore operates on the hypersphere space. In this paper, we present three specific instances of the SphereConv Operator. To facilitate the computation, we constrain the output of SphereConv operators to [−1, 1] (although it is not a necessary requirement). Linear SphereConv. In linear SphereConv operator, g is a linear function of θ(w,x), with the form:\ng(θ(w,x)) = aθ(w,x) + b, (2) where a and b are parameters for the linear SphereConv operator. In order to constrain the output range to [0, 1] while θ(w,x) ∈ [0, π], we use a = − 2π and b = 1 (not necessarily optimal design).\n0 0.5 1 1.5 2 2.5 3 -1\n-0.5\n0\n0.5 1 Cosine Linear Sigmoid (k=0.1) Sigmoid (k=0.3) Sigmoid (k=0.7)\nFigure 2: SphereConv operators.\nCosine SphereConv. The cosine SphereConv operator is a nonlinear function of θ(w,x), with its g being the form of\ng(θ(w,x)) = cos(θ(w,x)), (3)\nwhich can be reformulated as w Tx\n‖w‖2‖x‖2 . Therefore, it can be viewed as a doubly normalized convolutional operator, which bridges the SphereConv operator and convolutional operator.\nSigmoid SphereConv. The Sigmoid SphereConv operator is derived from the Sigmoid function and its g can be written as\ng(θ(w,x)) = 1 + exp(− π 2k ) 1− exp(− π 2k ) · 1− exp\n( θ(w,x) k\n− π 2k\n)\n1 + exp ( θ(w,x) k − π 2k\n) , (4) where k > 0 is the parameter that controls the curvature of the function. While k is close to 0, g(θ(w,x)) will approximate the step function. While k becomes larger, g(θ(w,x)) is more like a linear function, i.e., the linear SphereConv operator. Sigmoid SphereConv is one instance of the parametric SphereConv family. With more parameters being introduced, the parametric SphereConv can have richer representation power. To increase the flexibility of the parametric SphereConv, we will discuss the case where these parameters can be jointly learned via back-prop later in the paper."
    }, {
      "heading" : "2.2 Optimization",
      "text" : "The optimization of the SphereConv operators is nearly the same as the convolutional operator and also follows the standard back-propagation. Using the chain rule, we have the gradient of the SphereConv with respect to the weights and the feature input:\n∂g(θ(w,x)) ∂w = ∂g(θ(w,x)) ∂θ(w,x) · ∂θ(w,x) ∂w , ∂g(θ(w,x)) ∂x = ∂g(θ(w,x)) ∂θ(w,x) · ∂θ(w,x) ∂x . (5)\nFor different SphereConv operators, both ∂θ(w,x)∂w and ∂θ(w,x) ∂x are the same, so the only difference lies in the ∂g(θ(w,x))∂θ(w,x) part. For ∂θ(w,x) ∂w , we have\n∂θ(w,x) ∂w = ∂ arccos\n( wTx\n‖w‖2‖x‖2 ) ∂w , ∂θ(w,x) ∂x = ∂ arccos ( wTx ‖w‖2‖x‖2 ) ∂x , (6)\nwhich are straightforward to compute and therefore neglected here. Because ∂g(θ(w,x))∂θ(w,x) for the linear SphereConv, the cosine SphereConv and the Sigmoid SphereConv are a, − sin(θ(w,x)) and −2 exp(θ(w,x)/k−π/2k) k(1+exp(θ(w,x)/k−π/2k))2 respectively, all these partial gradients can be easily computed."
    }, {
      "heading" : "2.3 Theoretical Insights",
      "text" : "We provide a fundamental analysis for the cosine SphereConv operator in the case of linear neural network to justify that the SphereConv operator can improve the conditioning of the problem. In specific, we consider one layer of linear neural network, where the observation is F = U∗V ∗> (ignore the bias), U∗ ∈ Rn×k is the weight, and V ∗ ∈ Rm×k is the input that embeds weights from previous layers. Without loss of generality, we assume the columns satisfying ‖Ui,:‖2 = ‖Vj,:‖2 = 1 for all i = 1, . . . , n and j = 1, . . . ,m, and consider\nmin U∈Rn×k,V ∈Rm×k\nG(U ,V ) = 1 2 ‖F −UV >‖2F . (7)\nThis is closely related with the matrix factorization and (7) can be also viewed as the expected version for the matrix sensing problem [10]. The following lemma demonstrates a critical scaling issue of (7) for U and V that significantly deteriorate the conditioning without changing the objective of (7). Lemma 1. Consider a pair of global optimal points U ,V satisfying F = UV > and Tr(V >V ⊗ In) ≤ Tr(U>U ⊗ Im). For any real c > 1, let Ũ = cU and Ṽ = V /c, then we have κ(∇2G(Ũ , Ṽ )) = Ω(c2κ(∇2G(U ,V ))), where κ = λmaxλmin is the restricted condition number with λmax being the largest eigenvalue and λmin being the smallest nonzero eigenvalue.\nLemma 1 implies that the conditioning of the problem (7) at a unbalanced global optimum scaled by a constant c is Ω(c2) times larger than the conditioning of the problem at a balanced global optimum. Note that λmin = 0 may happen, thus we consider the restricted condition here. Similar results hold beyond global optima. This is an undesired geometric structure, which further leads to slow and unstable optimization procedures, e.g., using stochastic gradient descent (SGD). This motivates us to consider the SphereConv operator discussed above, which is equivalent to projecting data onto the hypersphere and leads to a better conditioned problem.\nNext, we consider our proposed cosine SphereConv operator for one-layer of the linear neural network. Based on our previous discussion on SphereConv, we consider an equivalent problem:\nmin U∈Rn×k,V ∈Rm×k\nGS(U ,V ) = 12‖F −DUUV >DV ‖2F , (8) where DU = diag (\n1 ‖U1,:‖2 , . . . , 1 ‖Un,:‖2\n) ∈ Rn×n and DV = diag ( 1\n‖V1,:‖2 , . . . , 1 ‖Vm,:‖2\n) ∈\nRm×m are diagonal matrices. We provide an analogous result to Lemma 1 for (8) . Lemma 2. For any real c > 1, let Ũ = cU and Ṽ = V /c, then we have λi(∇2GS(Ũ , Ṽ )) = λi(∇2GS(U ,V )) for all i ∈ [(n + m)k] = {1, 2, . . . , (n + m)k} and κ(∇2G(Ũ , Ṽ )) = κ(∇2G(U ,V )), where κ is defined as in Lemma 1.\nWe have from Lemma 2 that the issue of increasing condition caused by the scaling is eliminated by the SphereConv operator in the entire parameter space. This enhances the geometric structure over (7), which further results in improved convergence of optimization procedures. If we extend the result from one layer to multiple layers, the scaling issue propagates. Roughly speaking, when we train N layers, in the worst case, the conditioning of the problem can be cN times worse with a scaling factor c > 1. The analysis is similar to the one layer case, but the computation of the Hessian matrix and associated eigenvalues are much more complicated. Though our analysis is elementary, we provide an important insight and a straightforward illustration of the advantage for using the SphereConv operator. The extension to more general cases, e..g, using nonlinear activation function (e.g., ReLU), requires much more sophisticated analysis to bound the eigenvalues of Hessian for objectives, which is deferred to future investigation."
    }, {
      "heading" : "2.4 Discussion",
      "text" : "Comparison to convolutional operators. Convolutional operators compute the inner product between the kernels and the local patches, while the SphereConv operators compute a function of the angle between the kernels and local patches. If we normalize the convolutional operator in terms of both w and x, then the normalized convolutional operator is equivalent to the cosine SphereConv operator. Essentially, they use different metric spaces. Interestingly, SphereConv operators can also be interpreted as a function of the Geodesic distance on a unit hypersphere. Extension to fully connected layers. Because the fully connected layers can be viewed as a special convolution layer with the kernel size equal to the input feature map, the SphereConv operators could be easily generalized to the fully connected layers. It also indicates that SphereConv operators could be used not only to deep CNNs, but also to linear models like logistic regression, SVM, etc.\nNetwork Regularization. Because the norm of weights is no longer crucial, we stop using the `2 weight decay to regularize the network. SphereNets are learned on hyperspheres, so we regularize the network based on angles instead of norms. To avoid redundant kernels, we want the kernels uniformly spaced around the hypersphere, but it is difficult to formulate such constraints. As a tradeoff, we encourage the orthogonality. Given a set of kernels W where the i-th column Wi is the weights of the i-th kernel, the network will also minimize ‖W>W −I‖2F where I is an identity matrix. Determining the optimal SphereConv. In practice, we could treat different types of SphereConv as a hyperparameter and use the cross validation to determine which SphereConv is the most suitable one. For sigmoid SphereConv, we could also use the cross validation to determine its hyperparameter k. In general, we need to specify a SphereConv operator before using it, but prefixing a SphereConv may not be an optimal choice (even using cross validation). What if we treat the hyperparameter k in sigmoid SphereConv as a learnable parameter and use the back-prop to learn it? Following this idea, we further extend sigmoid SphereConv to a learnable SphereConv in the next subsection. SphereConv as normalization. Because SphereConv could partially address the covariate shift, it could also serve as a normalization method similar to batch normalization. Differently, SphereConv normalizes the network in terms of feature map and kernel weights, while batch normalization is for the mini-batches. Thus they do not contradict with each other and can be used simultaneously."
    }, {
      "heading" : "2.5 Extension: Learnable SphereConv and SphereNorm",
      "text" : "Learnable SphereConv. It is a natrual idea to replace the current prefixed SphereConv with a learnable one. There will be plenty of parametrization choices for the SphereConv to be learnable, and we present a very simple learnable SphereConv operator based on the sigmoid SphereConv. Because the sigmoid SphereConv has a hyperparameter k, we could treat it as a learnable parameter that can be updated by back-prop. In back-prop, k is updated using kt+1 = kt+η ∂L∂k where t denotes the current iteration index and ∂L∂k can be easily computed by the chain rule. Usually, we also require k to be positive. The learning of k is in fact similar to the parameter learning in PReLU [5]. SphereNorm: hyperspherical learning as a normalization method. Similar to batch normalization (BatchNorm), we note that the hyperspherical learning can also be viewed as a way of normalization, because SphereConv constrain the output value in [−1, 1] ([0, 1] after ReLU). Different from BatchNorm, SphereNorm normalizes the network based on spatial information and the weights, so it has nothing to do with the mini-batch statistic. Because SphereNorm normalize both the input and weights, it could avoid covariate shift due to large weights and large inputs while BatchNorm could only prevent covariate shift caused by the inputs. In such sense, it will work better than BatchNorm when the batch size is small. Besides, SphereConv is more flexible in terms of design choices (e.g. linear, cosine, and sigmoid) and each may lead to different advantages.\nSimilar to BatchNorm, we could use a rescaling strategy for the SphereNorm. Specifically, we rescale the output of SphereConv via βFs(w,x) + γ where β and γ are learned by back-prop (similar to BatchNorm, the rescaling parameters can be either learned or prefixed). In fact, SphereNorm does not contradict with the BatchNorm at all and can be used simultaneously with BatchNorm. Interestingly, we find using both is empirically better than using either one alone."
    }, {
      "heading" : "3 Learning Objective on Hyperspheres",
      "text" : "For learning on hyperspheres, we can either use the conventional loss function such as softmax loss, or use some loss functions that are tailored for the SphereConv operators. We present some possible choices for these tailored loss functions. Weight-normalized Softmax Loss. The input feature and its label are denoted as xi and yi, respectively. The original softmax loss can be written as L = 1N ∑ i Li = 1 N ∑ i− log ( efyi∑ j e fj ) where N is the number of training samples and fj is the score of the j-th class (j ∈ [1,K], K is the number of classes). The class score vector f is usually the output of a fully connected layer W , so we have fj=W > j xi+bj and fyi =W > yixi+byi in which xi, Wj , and Wyi are the i-th training sample, the j-th and yi-th column of W respectively. We can rewrite Li as\nLi = − log ( e W>yi\nxi+byi∑ j e W>j xi+bj\n) = − log ( e‖Wyi‖‖xi‖ cos(θyi,i)+byi∑ j e ‖Wj‖‖xi‖ cos(θj,i)+bj ) , (9)\nwhere θj,i(0≤θj,i≤π) is the angle between vector Wj and xi. The decision boundary of the original softmax loss is determined by the vector f . Specifically in the binary-class case, the\ndecision boundary of the softmax loss is W>1 x+b1 =W > 2 x+b2. Considering the intuition of the SphereConv operators, we want to make the decision boundary only depend on the angles. To this end, we normalize the weights (‖Wj‖=1) and zero out the biases (bj=0), following the intuition in [11] (sometimes we could keep the biases while data is imbalanced). The decision boundary becomes ‖x‖ cos(θ1)=‖x‖ cos(θ2). Similar to SphereConv, we could generalize the decision boundary to ‖x‖g(θ1)=‖x‖g(θ2), so the weight-normalized softmax (W-Softmax) loss can be written as\nLi = − log (\ne‖xi‖g(θyi,i)∑ j e ‖xi‖g(θj,i)\n) , (10)\nwhere g(·) can take the form of linear SphereConv, cosine SphereConv, or sigmoid SphereConv. Thus we also term these three difference weight-normalized loss functions as linear W-Softmax loss, cosine W-Softmax loss, and sigmoid W-Softmax loss, respectively. Generalized Angular Softmax Loss. Inspired by [11], we use a multiplicative parameter m to impose margins on hyperspheres. We propose a generalized angular softmax (GA-Softmax) loss which extends the W-Softmax loss to a loss function that favors large angular margin feature distribution. In general, the GA-Softmax loss is formulated as\nLi = − log (\ne‖xi‖g(mθyi,i) e‖xi‖g(mθyi,i) + ∑ j 6=yi e ‖xi‖g(θj,i)\n) , (11)\nwhere g(·) could also have the linear, cosine and sigmoid form, similar to the W-Softmax loss. We can see A-Softmax loss [11] is exactly the cosine GA-Softmax loss and W-Softmax loss is the special case (m = 1) of GA-Sofmtax loss. Note that we usually require θj,i ∈ [0, πm ], because cos(θj,i) is only monotonically decreasing in [0, π]. To address this, [12, 11] construct a monotonically decreasing function recursively using the [0, πm ] part of cos(mθj,i). Although it indeed partially addressed the issue, it may introduce a number of saddle points (w.r.t. W ) in the loss surfaces. Originally, ∂g∂θ will be close to 0 only when θ is close to 0 and π. However, in L-Softmax [12] or A-Softmax (cosine GA-Softmax), it is not the case. ∂g∂θ will be 0 when θ = kθ m , k = 0, · · · ,m. It will possibly cause instability in training. The sigmoid GA-Softmax loss also has similar issues. However, if we use the linear GA-Softmax loss, this problem will be automatically solved and the training will possibly become more stable in practice. There will also be a lot of choices of g(·) to design a specific GA-Sofmtax loss, and each one has different optimization dynamics. The optimal one may depend on the task itself (e.g. cosine GA-Softmax has been shown effective in deep face recognition [11]). Discussion of Sphere-normalized Softmax Loss. We have also considered the sphere-normalized softmax loss (S-Softmax), which simultaneously normalizes the weights (Wj) and the feature x. It seems to be a more natural choice than W-Softmax for the proposed SphereConv and makes the entire framework more unified. In fact, we have tried this and the empirical results are not that good, because the optimization seems to become very difficult. If we use the S-Softmax loss to train a network from scratch, we can not get reasonable results without using extra tricks, which is the reason we do not use it in this paper. For completeness, we give some discussions here. Normally, it is very difficult to make the S-Softmax loss value to be small enough, because we normalize the features to unit hypersphere. To make this loss work, we need to either normalize the feature to a value much larger than 1 (hypersphere with large radius) and then tune the learning rate or first train the network with the softmax loss from scratch and then use the S-Softmax loss for finetuning."
    }, {
      "heading" : "4 Experiments and Results",
      "text" : ""
    }, {
      "heading" : "4.1 Experimental Settings",
      "text" : "We will first perform comprehensive ablation study and exploratory experiments for the proposed SphereNets, and then evaluate the SphereNets on image classification. For the image classification task, we perform experiments on CIFAR10 (only with random left-right flipping), CIFAR10+ (with full data augmentation), CIFAR100 and large-scale Imagenet 2012 datasets [17]. General Settings. For CIFAR10, CIFAR10+ and CIFAR100, we follow the same settings from [7, 12]. For Imagenet 2012 dataset, we mostly follow the settings in [9]. We attach more details in Appendix B. For fairness, batch normalization and ReLU are used in all methods if not specified. All the comparisons are made to be fair. Compared CNNs have the same architecture with SphereNets. Training. Appendix A gives the network details. For CIFAR-10 and CIFAR-100, we use the ADAM, starting with the learning rate 0.001. The batch size is 128 if not specified. The learning rate is divided by 10 at 34K, 54K iterations and the training stops at 64K. For both A-Softmax and GA-Softmax loss,\nwe use m=4. For Imagenet-2012, we use the SGD with momentum 0.9. The learning rate starts with 0.1, and is divided by 10 at 200K and 375K iterations. The training stops at 550K iteration."
    }, {
      "heading" : "4.2 Ablation Study and Exploratory Experiments",
      "text" : "We perform comprehensive Ablation and exploratory study on the SphereNet and evaluate every component individually in order to analyze its advantages. We use the 9-layer CNN as default (if not specified) and perform the image classification on CIFAR-10 without any data augmentation.\nComparison of different loss functions. We first evaluate all the SphereConv operators with different loss functions. All the compared SphereConv operators use the 9-layer CNN architecture in the experiment. From the results in Table 1, one can observe that the SphereConv operators consistently outperforms the original convolutional operator. For the compared loss functions except A-Softmax and GA-Softmax, the effect on accuracy seems to less crucial than the SphereConv operators, but sigmoid W-Softmax is more flexible and thus works slightly better than the others. The sigmoid SphereConv operators with a suitably chosen parameter also works better than the others. Note that, W-Softmax loss is in fact comparable to the original softmax loss, because our SphereNet optimizes angles and the W-Softmax is derived from the original softmax loss. Therefore, it is fair to compare the SphereNet with W-Softmax and CNN with softmax loss. From Table 1, we can see SphereConv operators are consistently better than the covolutional operators. While we use a large-margin loss function like the A-Softmax [11] and the proposed GA-Softmax, the accuracy can be further boosted. One may notice that A-Softmax is actually cosine GA-Softmax. The superior performance of A-Softmax with SphereNet shows that our architecture is more suitable for the learning of angular loss. Moreover, our proposed large-margin loss (linear GA-Softmax) performs the best among all these compared loss functions. Comparison of different network architectures. We are also interested in how our SphereConv operators work in different architectures. We evaluate all the proposed SphereConv operators with the same architecture of different layers and a totally different architecture (ResNet). Our baseline CNN architecture follows the design of VGG network [18] only with different convolutional layers. For fair comparison, we use cosine W-Softmax for all SphereConv operators and original softmax for original convolution operators. From the results in Table 2, one can see that SphereNets greatly outperforms the CNN baselines, usually with more than 1% improvement. While applied to ResNet, our SphereConv operators also work better than the baseline. Note that, we use the similar ResNet architecture from the CIFAR-10 experiment in [6]. We do not use data augmentation for CIFAR-10 in this experiment, so the ResNet accuracy is much lower than the reported one in [6]. Our results on different network architectures show consistent and significant improvement over CNNs.\nComparison of different width (number of filters). We evaluate the SphereNet with different number of filters. Fig. 3(c) shows the convergence of different width of SphereNets. 16/32/48 means conv1.x, conv2.x and conv3.x have 16, 32 and 48 filters, respectively. One could observe that while the number of filters are small, SphereNet performs similarly to CNNs (slightly worse). However, while we increase the number of filters, the final accuracy will surpass the CNN baseline even faster and more stable convergence performance. With large width, we find that SphereNets perform consistently better than CNN baselines, showing that SphereNets can make better use of the width. Learning without ReLU. We notice that SphereConv operators are no longer a matrix multiplication, so it is essentially a non-linear function. Because the SphereConv operators already introduce certain\nnon-linearity to the network, we evaluate how much gain will such non-linearity bring. Therefore, we remove the ReLU activation and compare our SphereNet with the CNNs without ReLU. The results are given in Table 3. All the compared methods use 18-layer CNNs (with BatchNorm). Although removing ReLU greatly reduces the classification accuracy, our SphereNet still outperforms the CNN without ReLU by a significant margin, showing its rich non-linearity and representation power. Convergence. One of the most significant advantages of SphereNet is its training stability and convergence speed. We evaluate the convergence with two different architectures: CNN-9 and ResNet-32. For fair comparison, we use the original softmax loss for all compared methods (including SphereNets). ADAM is used for the stochastic optimization and the learning rate is the same for all networks. From Fig. 3(a), the SphereResNet converges significantly faster than the original ResNet baseline in both CIFAR-10 and CIFAR-10+ and the final accuracy are also higher than the baselines. In Fig. 3(b), we evaluate the SphereNet with and without orthogonality constraints on kernel weights. With the same network architecture, SphereNet also converges much faster and performs better than the baselines. The orthogonality constraints also can bring performance gains in some cases. Generally from Fig. 3, one could also observe that the SphereNet converges fast and very stably in every case while the CNN baseline fluctuates in a relative wide range. Optimizing ultra-deep networks. Partially because of the alleviation of the covariate shift problem and the improvement of conditioning, our SphereNet is able to optimize ultra-deep neural networks without using residual units or any form of shortcuts. For SphereNets, we use the cosine SphereConv operator with the cosine W-Softmax loss. We directly optimize a very deep plain network with 69 stacked convolutional layers. From Fig. 3(d), one can see that the convergence of SphereNet is much easier than the CNN baseline and the SphereNet is able to achieve nearly 90% final accuracy."
    }, {
      "heading" : "4.3 Preliminary Study towards Learnable SphereConv",
      "text" : "Although the learnable SphereConv is not a main theme of this paper, we still run some preliminary evaluations on it. For the proposed learnable sigmoid SphereConv, we learn the parameter k independently for each filter. It is also trivial to learn it in a layer-shared or network-shared fashsion. With the same 9-layer architecture used in Section 4.2, the learnable SphereConv (with cosine W-Softmax loss) achieves 91.64% on CIFAR-10 (without full data augmentation), while the best sigmoid SphereConv (with cosine W-Softmax loss) achieves 91.22%. In Fig. 4, we also plot the frequency histogram of k in Conv1.1 (64 filters), Conv2.1 (96 filters) and Conv3.1 (128 filters) of the final learned SphereNet.\nFrom Fig. 4, we observe that each layer learns different distribution of k. The first convolutional layer (Conv1.1) tends to uniformly distribute k into a large range of values from 0 to 1, potentially extracting information from all levels of angular similarity. The fourth convolutional layer (Conv2.1) tends to learn more concentrated distribution of k than Conv1.1, while the seventh convolutional layer (Conv3.1) learns highly concentrated distribution of k which is centered around 0.8. Note that, we initialize all k with a constant 0.5 and learn them with the back-prop."
    }, {
      "heading" : "4.4 Evaluation of SphereNorm",
      "text" : "From Section 4.2, we could clearly see the convergence advantage of SphereNets. In general, we can view the SphereConv as a normalization method (comparable to batch normalization) that can be applied to all kinds of networks. This section evaluates the challenging scenarios where the minibatch size is small (results under 128 batch size could be found in Section 4.2) and we use the same\n9-layer CNN as in Section 4.2. To be simple, we use the cosine SphereConv as SphereNorm. The softmax loss is used in both CNNs and SphereNets. From Fig. 5, we could observe that SphereNorm achieves the final accuracy similar to BatchNorm, but SphereNorm converges faster and more stably. SphereNorm plus the orthogonal constraint helps convergence a little bit and rescaled SphereNorm does not seem to work well. While BatchNorm and SphereNorm are used together, we obtain the fastest convergence and the highest final accuracy, showing excellent compatibility of SphereNorm."
    }, {
      "heading" : "4.5 Image Classification on CIFAR-10+ and CIFAR-100",
      "text" : "We first evaluate the SphereNet in a classic image classification task. We use the CIFAR-10+ and CIFAR100 datasets and perform random flip (both horizontal and vertical) and random crop as data augmentation (CIFAR-10 with full data augmentation is denoted as CIFAR-10+). We use the ResNet-32 as a baseline architecture. For the SphereNet of the same architecture, we evaluate sigmoid SphereConv operator (k = 0.3) with sigmoid W-Softmax (k = 0.3) loss (S-SW), linear SphereConv operator with linear W-Softmax loss\n(L-LW), cosine SphereConv operator with cosine W-Softmax loss (C-CW) and sigmoid SphereConv operator (k = 0.3) with GA-Softmax loss (S-G). In Table 4, we could see the SphereNet outperforms a lot of current state-of-the-art methods and is even comparable to the ResNet-1001 which is far deeper than ours. This experiment further validates our idea that learning on a hyperspheres constrains the parameter space to a more semantic and label-related one."
    }, {
      "heading" : "4.6 Large-scale Image Classification on Imagenet-2012",
      "text" : "We evaluate SphereNets on large-scale Imagenet2012 dataset. We only use the minimum data augmentation strategy in the experiment (details are in Appendix B). For the ResNet-18 baseline and SphereResNet-18, we use the same filter numbers in each layer. We develop two types of SphereResNet-18, termed as v1 and v2 respectively. In SphereResNet-18-v2, we do not use SphereConv in the 1×1 shortcut convolutions which are used to match the number of channels. In SphereResNet-18-v1, we use SphereConv in\nthe 1×1 shortcut convolutions. Fig. 6 shows the single crop validation error over iterations. One could observe that both SphereResNets converge much faster than the ResNet baseline, while SphereResNet18-v1 converges the fastest but yields a slightly worse yet comparable accuracy. SphereResNet-18-v2 not only converges faster than ResNet-18, but it also shows slightly better accuracy."
    }, {
      "heading" : "5 Limitations and Future Work",
      "text" : "Our work still has some limitations: (1) SphereNets have large performance gain while the network is wide enough. If the network is not wide enough, SphereNets still converge much faster but yield slightly worse (still comparable) recognition accuracy. (2) The computation complexity of each neuron is slightly higher than the CNNs. (3) SphereConvs are still mostly prefixed. Possible future work includes designing/learning a better SphereConv, efficiently computing the angles to reduce computation complexity, applications to the tasks that require fast convergence (e.g. reinforcement learning and recurrent neural networks), better angular regularization to replace orthogonality, etc."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank Zhen Liu (Georgia Tech) for helping with the experiments and providing suggestions. This project was supported in part by NSF IIS-1218749, NIH BIGDATA 1R01GM108341, NSF CAREER IIS-1350983, NSF IIS-1639792 EAGER, NSF CNS-1704701, ONR N00014-15-1-2340, Intel ISTC, NVIDIA and Amazon AWS. Xingguo Li is supported by doctoral dissertation fellowship from University of Minnesota. Yan-Ming Zhang is supported by the National Natural Science Foundation of China under Grant 61773376."
    } ],
    "references" : [ {
      "title" : "Semantic image segmentation with deep convolutional nets and fully connected crfs",
      "author" : [ "Liang-Chieh Chen", "George Papandreou", "Iasonas Kokkinos", "Kevin Murphy", "Alan L Yuille" ],
      "venue" : "In ICLR,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2015
    }, {
      "title" : "Fast and accurate deep network learning by exponential linear units (elus)",
      "author" : [ "Djork-Arné Clevert", "Thomas Unterthiner", "Sepp Hochreiter" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2015
    }, {
      "title" : "Rich feature hierarchies for accurate object detection and semantic segmentation",
      "author" : [ "Ross Girshick", "Jeff Donahue", "Trevor Darrell", "Jitendra Malik" ],
      "venue" : "In CVPR,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2014
    }, {
      "title" : "Understanding the difficulty of training deep feedforward neural networks",
      "author" : [ "Xavier Glorot", "Yoshua Bengio" ],
      "venue" : "In Aistats,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2010
    }, {
      "title" : "Delving deep into rectifiers: Surpassing human-level performance on imagenet classification",
      "author" : [ "Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun" ],
      "venue" : "In ICCV,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2015
    }, {
      "title" : "Deep residual learning for image recognition",
      "author" : [ "Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2016
    }, {
      "title" : "Identity mappings in deep residual networks",
      "author" : [ "Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2016
    }, {
      "title" : "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
      "author" : [ "Sergey Ioffe", "Christian Szegedy" ],
      "venue" : "In ICML,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2015
    }, {
      "title" : "Imagenet classification with deep convolutional neural networks",
      "author" : [ "Alex Krizhevsky", "Ilya Sutskever", "Geoffrey E Hinton" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2012
    }, {
      "title" : "Symmetry, saddle points, and global geometry of nonconvex matrix factorization",
      "author" : [ "Xingguo Li", "Zhaoran Wang", "Junwei Lu", "Raman Arora", "Jarvis Haupt", "Han Liu", "Tuo Zhao" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2016
    }, {
      "title" : "Sphereface: Deep hypersphere embedding for face recognition",
      "author" : [ "Weiyang Liu", "Yandong Wen", "Zhiding Yu", "Ming Li", "Bhiksha Raj", "Le Song" ],
      "venue" : null,
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2017
    }, {
      "title" : "Large-margin softmax loss for convolutional neural networks",
      "author" : [ "Weiyang Liu", "Yandong Wen", "Zhiding Yu", "Meng Yang" ],
      "venue" : "In ICML,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2016
    }, {
      "title" : "Fully convolutional networks for semantic segmentation",
      "author" : [ "Jonathan Long", "Evan Shelhamer", "Trevor Darrell" ],
      "venue" : "In CVPR,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2015
    }, {
      "title" : "All you need is a good init",
      "author" : [ "Dmytro Mishkin", "Jiri Matas" ],
      "venue" : null,
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2015
    }, {
      "title" : "Eigenvalue perturbation bounds for hermitian block tridiagonal matrices",
      "author" : [ "Yuji Nakatsukasa" ],
      "venue" : "Applied Numerical Mathematics,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "Faster r-cnn: Towards real-time object detection with region proposal networks. In Advances in neural information processing",
      "author" : [ "Shaoqing Ren", "Kaiming He", "Ross Girshick", "Jian Sun" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2015
    }, {
      "title" : "Imagenet large scale visual recognition challenge",
      "author" : [ "Olga Russakovsky", "Jia Deng", "Hao Su", "Jonathan Krause", "Sanjeev Satheesh", "Sean Ma", "Zhiheng Huang", "Andrej Karpathy", "Aditya Khosla", "Michael Bernstein" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2014
    }, {
      "title" : "Very deep convolutional networks for large-scale image recognition",
      "author" : [ "Karen Simonyan", "Andrew Zisserman" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2014
    }, {
      "title" : "Going deeper with convolutions",
      "author" : [ "Christian Szegedy", "Wei Liu", "Yangqing Jia", "Pierre Sermanet", "Scott Reed", "Dragomir Anguelov", "Dumitru Erhan", "Vincent Vanhoucke", "Andrew Rabinovich" ],
      "venue" : "In CVPR,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2015
    }, {
      "title" : "Residual networks behave like ensembles of relatively shallow networks",
      "author" : [ "Andreas Veit", "Michael J Wilber", "Serge Belongie" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2016
    }, {
      "title" : "All you need is beyond a good init: Exploring better solution for training extremely deep convolutional neural networks with orthonormality and modulation",
      "author" : [ "Di Xie", "Jiang Xiong", "Shiliang Pu" ],
      "venue" : null,
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2017
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "Recently, deep convolutional neural networks have led to significant breakthroughs on many vision problems such as image classification [9, 18, 19, 6], segmentation [3, 13, 1], object detection [3, 16], etc.",
      "startOffset" : 136,
      "endOffset" : 150
    }, {
      "referenceID" : 17,
      "context" : "Recently, deep convolutional neural networks have led to significant breakthroughs on many vision problems such as image classification [9, 18, 19, 6], segmentation [3, 13, 1], object detection [3, 16], etc.",
      "startOffset" : 136,
      "endOffset" : 150
    }, {
      "referenceID" : 18,
      "context" : "Recently, deep convolutional neural networks have led to significant breakthroughs on many vision problems such as image classification [9, 18, 19, 6], segmentation [3, 13, 1], object detection [3, 16], etc.",
      "startOffset" : 136,
      "endOffset" : 150
    }, {
      "referenceID" : 5,
      "context" : "Recently, deep convolutional neural networks have led to significant breakthroughs on many vision problems such as image classification [9, 18, 19, 6], segmentation [3, 13, 1], object detection [3, 16], etc.",
      "startOffset" : 136,
      "endOffset" : 150
    }, {
      "referenceID" : 2,
      "context" : "Recently, deep convolutional neural networks have led to significant breakthroughs on many vision problems such as image classification [9, 18, 19, 6], segmentation [3, 13, 1], object detection [3, 16], etc.",
      "startOffset" : 165,
      "endOffset" : 175
    }, {
      "referenceID" : 12,
      "context" : "Recently, deep convolutional neural networks have led to significant breakthroughs on many vision problems such as image classification [9, 18, 19, 6], segmentation [3, 13, 1], object detection [3, 16], etc.",
      "startOffset" : 165,
      "endOffset" : 175
    }, {
      "referenceID" : 0,
      "context" : "Recently, deep convolutional neural networks have led to significant breakthroughs on many vision problems such as image classification [9, 18, 19, 6], segmentation [3, 13, 1], object detection [3, 16], etc.",
      "startOffset" : 165,
      "endOffset" : 175
    }, {
      "referenceID" : 2,
      "context" : "Recently, deep convolutional neural networks have led to significant breakthroughs on many vision problems such as image classification [9, 18, 19, 6], segmentation [3, 13, 1], object detection [3, 16], etc.",
      "startOffset" : 194,
      "endOffset" : 201
    }, {
      "referenceID" : 15,
      "context" : "Recently, deep convolutional neural networks have led to significant breakthroughs on many vision problems such as image classification [9, 18, 19, 6], segmentation [3, 13, 1], object detection [3, 16], etc.",
      "startOffset" : 194,
      "endOffset" : 201
    }, {
      "referenceID" : 8,
      "context" : "To address the challenges, regularization techniques such as dropout [9] and orthogonality parameter constraints [21] have been proposed.",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 20,
      "context" : "To address the challenges, regularization techniques such as dropout [9] and orthogonality parameter constraints [21] have been proposed.",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 7,
      "context" : "Batch normalization [8] can also be viewed as an implicit regularization to the network, by normalizing each layer’s output distribution.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 5,
      "context" : "Recently, deep residual learning [6] emerged as a promising way to overcome vanishing gradients in deep networks.",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 19,
      "context" : "However, [20] pointed out that residual networks (ResNets) are essentially an exponential ensembles of shallow networks where they avoid the vanishing/exploding gradient problem but do not provide direct solutions.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 4,
      "context" : "Finding better initializations is thus widely studied [5, 14, 4].",
      "startOffset" : 54,
      "endOffset" : 64
    }, {
      "referenceID" : 13,
      "context" : "Finding better initializations is thus widely studied [5, 14, 4].",
      "startOffset" : 54,
      "endOffset" : 64
    }, {
      "referenceID" : 3,
      "context" : "Finding better initializations is thus widely studied [5, 14, 4].",
      "startOffset" : 54,
      "endOffset" : 64
    }, {
      "referenceID" : 7,
      "context" : "SphereConv to some extent also alleviates the covariate shift problem [8].",
      "startOffset" : 70,
      "endOffset" : 73
    }, {
      "referenceID" : 11,
      "context" : "SphereNet can also be viewed as a non-trivial generalization of [12, 11].",
      "startOffset" : 64,
      "endOffset" : 72
    }, {
      "referenceID" : 10,
      "context" : "SphereNet can also be viewed as a non-trivial generalization of [12, 11].",
      "startOffset" : 64,
      "endOffset" : 72
    }, {
      "referenceID" : 10,
      "context" : "By proposing a loss that discriminatively supervises the network on a hypersphere, [11] achieves state-of-the-art performance on face recognition.",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 10,
      "context" : "Moreover, the proposed generalized angular softmax (GA-Softmax) loss naturaly generalizes the angular supervision in [11] using the SphereConv operators.",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 18,
      "context" : "SphereNet can be easily applied to other network architectures such as GoogLeNet [19], VGG [18] and ResNet [6].",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 17,
      "context" : "SphereNet can be easily applied to other network architectures such as GoogLeNet [19], VGG [18] and ResNet [6].",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 5,
      "context" : "SphereNet can be easily applied to other network architectures such as GoogLeNet [19], VGG [18] and ResNet [6].",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 9,
      "context" : "This is closely related with the matrix factorization and (7) can be also viewed as the expected version for the matrix sensing problem [10].",
      "startOffset" : 136,
      "endOffset" : 140
    }, {
      "referenceID" : 4,
      "context" : "The learning of k is in fact similar to the parameter learning in PReLU [5].",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 10,
      "context" : "To this end, we normalize the weights (‖Wj‖=1) and zero out the biases (bj=0), following the intuition in [11] (sometimes we could keep the biases while data is imbalanced).",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 10,
      "context" : "Inspired by [11], we use a multiplicative parameter m to impose margins on hyperspheres.",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 10,
      "context" : "We can see A-Softmax loss [11] is exactly the cosine GA-Softmax loss and W-Softmax loss is the special case (m = 1) of GA-Sofmtax loss.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 11,
      "context" : "To address this, [12, 11] construct a monotonically decreasing function recursively using the [0, π m ] part of cos(mθj,i).",
      "startOffset" : 17,
      "endOffset" : 25
    }, {
      "referenceID" : 10,
      "context" : "To address this, [12, 11] construct a monotonically decreasing function recursively using the [0, π m ] part of cos(mθj,i).",
      "startOffset" : 17,
      "endOffset" : 25
    }, {
      "referenceID" : 11,
      "context" : "However, in L-Softmax [12] or A-Softmax (cosine GA-Softmax), it is not the case.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 10,
      "context" : "cosine GA-Softmax has been shown effective in deep face recognition [11]).",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 16,
      "context" : "For the image classification task, we perform experiments on CIFAR10 (only with random left-right flipping), CIFAR10+ (with full data augmentation), CIFAR100 and large-scale Imagenet 2012 datasets [17].",
      "startOffset" : 197,
      "endOffset" : 201
    }, {
      "referenceID" : 6,
      "context" : "For CIFAR10, CIFAR10+ and CIFAR100, we follow the same settings from [7, 12].",
      "startOffset" : 69,
      "endOffset" : 76
    }, {
      "referenceID" : 11,
      "context" : "For CIFAR10, CIFAR10+ and CIFAR100, we follow the same settings from [7, 12].",
      "startOffset" : 69,
      "endOffset" : 76
    }, {
      "referenceID" : 8,
      "context" : "For Imagenet 2012 dataset, we mostly follow the settings in [9].",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 10,
      "context" : "While we use a large-margin loss function like the A-Softmax [11] and the proposed GA-Softmax, the accuracy can be further boosted.",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 17,
      "context" : "Our baseline CNN architecture follows the design of VGG network [18] only with different convolutional layers.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 5,
      "context" : "Note that, we use the similar ResNet architecture from the CIFAR-10 experiment in [6].",
      "startOffset" : 82,
      "endOffset" : 85
    }, {
      "referenceID" : 5,
      "context" : "We do not use data augmentation for CIFAR-10 in this experiment, so the ResNet accuracy is much lower than the reported one in [6].",
      "startOffset" : 127,
      "endOffset" : 130
    } ],
    "year" : 2017,
    "abstractText" : "Convolution as inner product has been the founding basis of convolutional neural networks (CNNs) and the key to end-to-end visual representation learning. Benefiting from deeper architectures, recent CNNs have demonstrated increasingly strong representation abilities. Despite such improvement, the increased depth and larger parameter space have also led to challenges in properly training a network. In light of such challenges, we propose hyperspherical convolution (SphereConv), a novel learning framework that gives angular representations on hyperspheres. We introduce SphereNet, deep hyperspherical convolution networks that are distinct from conventional inner product based convolutional networks. In particular, SphereNet adopts SphereConv as its basic convolution operator and is supervised by generalized angular softmax loss a natural loss formulation under SphereConv. We show that SphereNet can effectively encode discriminative representation and alleviate training difficulty, leading to easier optimization, faster convergence and comparable (even better) classification accuracy over convolutional counterparts. We also provide some theoretical insights for the advantages of learning on hyperspheres. In addition, we introduce the learnable SphereConv, i.e., a natural improvement over prefixed SphereConv, and SphereNorm, i.e., hyperspherical learning as a normalization method. Experiments have verified our conclusions.",
    "creator" : null
  }
}